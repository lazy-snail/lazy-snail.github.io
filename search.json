[{"title":"cn","url":"/2018/06/03/cn/","content":"","categories":["cn"],"tags":["cn"]},{"title":"cs","url":"/2018/06/03/cs/","content":"","categories":[],"tags":[]},{"title":"db","url":"/2018/06/03/db/","content":"","categories":["db"],"tags":["db"]},{"title":"java","url":"/2018/06/03/java/","content":"类文件结构各种不同平台的 VM 与所有平台统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石。然而，VM 的目标显然不止于平台无关，其语言无关性也同样在发展：目前已经有 Groovy、Jython、JRuby、Scala 等语言同样能够运行在 JVM 上。而实现语言无关性的基础仍然是 VM 和字节码存储格式。JVM 不和包括 java 在内的任何语言绑定，它只和“class 文件”这种特定格式的二进制文件格式所关联，其中包含了 JVM 指令集和符号表以及若干其他辅助信息。任何其他语言同样可以使用合适的编译器将其代码编译为 class 文件从而在 JVM 上执行，JVM 本身不关心 class 文件来源于何种语言——只要该 class 文件符合 jvms 的语法和结构化约束即可。字节码所能提供的语义描述能力强于 java 语言。\nclass 类文件的结构&#x2F;字节码以 8-byte 为单位紧凑排列，大端字节序方式，不含任何分隔符，格式是严格定义的：数据项顺序、数量，字节序，哪个字节代表什么含义等等，都不允许改变。文件格式采用类似于 C 语言结构体的伪结构，只含有两种数据类型：无符号数和表。\n\n无符号数：基本数据类型，以 u1、u2、u4、u8 表示 1&#x2F;2&#x2F;4&#x2F;8 个字节的无符号数。可以用来描述数字、索引引用、数量值或按照 UTF-8 编码构成字符串值；\n表是由多个无符号数或其他表作为数据项构成的复合数据类型。所有表习惯性以“_info”结尾。用于描述有层次关系的复合结构的数据。整个 class 文件本质上就是一张表。数据项：\n\n无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。\n魔数与 class 文件版本每个 class 文件前 4 个字节称为魔数（Magic Number），唯一作用是确定该文件是不是一个能被 JVM 接受的 class 文件。_很多文件存储标准中都是用魔数进行身份识别，如图片格式（gif、jpeg等都在头文件中存有魔数），魔数值可以由文件制定者自由选取，但要避免引起混淆_。使用魔数而非扩展名是基于安全性方面的考虑：扩展名可随意改动。class 文件的魔数值为：0xCAFEBABE（咖啡宝贝？），这个值在 java 还称作“Oak”语言的时候（1991年前后）就已经确定下来了。紧接着魔数的 4 个字节存储的是 class 文件的版本号：56 字节是次版本号（Minor Version），78 字节是主版本号（Major Version）。Java 的版本号是从 45 开始的（JDK 1.xxx 为 45.xxx，而 JDK 1.8 为 52.xxx），JDK 1.1 之后的每个 JDK 大版本发布时，主版本号向上 +1（JDK 1.01.1 使用了 45.045.3 的版本号），高版本的 JDK 能向下兼容以前版本的 class 文件，但不能运行以后版本的 class 文件，即使文件格式未发生任何变化，JVM 也必须拒绝执行超过其版本号的 class 文件。\n常量池（Constant Pool）紧接着主次版本号之后的是常量池入口，常量池可以理解为 class 文件中的资源仓库，是 class 文件结构中与其他项目关联最多的数据类型，也是占用 class 文件空间最大的数据项之一，也是 class 文件中第一个出现的表类型数据项目。与 java 语言习惯不一样的是，常量池的容量计数器是从 1 而不是 0 开始的：为了满足某些索引在特定情况下需要表达“不引用任何一个常量池项目”的含义时，可以将索引值置 0。故总数量为 计数器值 - 1。class 文件中只有常量池的容量计数器是从 1 开始的。常量池主要存放两大类常量：\n\n字面量（Literal）：接近于 java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等；\n符号引用（Symbolic References）：属于编译原理方面的概念，包含以下 3 类常量：\n类和接口的全限定名（Fully Qualified Name）字段的名称和描述符（Descriptor）方法的名称和描述符\n\n\n\nclass 文件中不保存各个方法、字段的内存布局信息，当 JVM 运行时，需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。\n常量池中每一项常量都是一个表。目前（JDK1.8)共有 14 种结构各异的表数据结构（有 3 种新增于 JDK1.7，为更好地支持动态语言调用）。\n这 14 种 表都有一个共同特点：起始位置的 u1 标志位，代表当前这个常量属于哪种常量类型。每种常量项目的结构表如下：\n访问标志（Access flags）常量池结束之后，紧接着的是 2 字节的访问标志，用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。当前已使用了 8 位，其余位置 0：\n类索引 父类索引 接口索引集合类索引（this_class）、父类索引（super_class）是 2 字节，各自指向一个类型为 CONSTANT_Class_info 的类描述符常量；接口索引集合（interfaces）是一组 2 字节类型的数据的集合，入口是 u2 类型的接口计数器，如果该类没有实现任何接口，则置 0，后面的接口索引表不再占用任何字节。这 3 项数据用来确定这个类的继承关系：\n\n类索引：确定该类的全限定名；\n父类索引：确定该类的父类的全限定名（java 不允许多继承，故只有一个，除了 Object 类，其余都有父类）；\n接口索引集合：描述该类实现了哪些接口，按 implements（如果这个类本身是接口，则是 extends）语句后的接口顺序排列。\n\n字段表（field_info）集合用于描述接口&#x2F;类中声明的变量。字段包括类级变量和实例级变量，但不包括在方法内部声明的局部变量。一个字段可以包括的信息有：字段的作用域（public、private、protected），实例变量还是类变量（static），可变性（final），并发可见性（volatile，是否强制从主内存读写），可否被序列化（transient），字段数据类型（基本类型、对象、数组）、字段名称。字段表结构如下：\n其中，字段访问标志（access_flags） 与类中的 access_flags 类似：\n跟随在 access_flags 的是两项索引值：name_index 和 descriptor_index，它们是对常量池的引用，分别代表着字段的简单名称、字段和方法的描述符。\npackage io.neil.hust;\npublic class HelloWorld &#123;\n    private String str = \"Hello, World\";\n    public void sayHello(String str) &#123;\n        System.out.println(str);\n    &#125;\n&#125;\n\n\n全限定名：“io&#x2F;neil&#x2F;hust&#x2F;HelloWorld”是”HelloWorld”类的全限定名（仅仅是把类全名“io.neil.hust.HelloWorld”的“.”换成了“&#x2F;”）；\n简单名称：没有类型和参数修饰的方法或字段名称：sayHello()方法和 str 字段的简单名分别为“sayHello”和“str”；\n字段和方法的描述符：描述字段的数据类型、方法的参数列表（数量、类型、顺序）和返回值。其标识字符含义如下：\n\n字段表都包含的固定数据项目到descriptor_index为止，之后跟随一个 属性表(attribute_info)集合 用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。\n字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。\n方法表（method_info）集合class 文件格式对方法的描述和对字段的描述几乎完全一致，仅在访问标志和属性表集合的可选项中有所区别。方法表访问标志\n属性表（attribute_info）集合class 文件、字段表、方法表都可以携带自己的属性表集合，用以描述某些场景专有的信息。与 class 文件中其他数据项要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松：不要求各个属性表之间遵循严格顺序，只要不和已有属性名重复，任何自定义编译器都可以自定义属性信息。而 JVM 运行时会忽略它不认识的属性。为了能正确解析 class 文件，jvms 7 预定义了 21 项属性（目前的 jvms 10 为 26 项），这里以 jvms 10 为例。\n对每个属性，它的名称需要从常量池中引用一个 CONSTANT_UTF8_info 类型的常量来表示，而属性值的结构则完全是自定义的，只需要通过一个 u4 的长度属性说明所占用的位数即可：\n类加载JVM 把描述类的数据从 class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 JVM 直接使用的 java 类型，这就是 JVM 的类加载机制。java 中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略为应用程序提供了高度的灵活性。\n类加载时机类从被加载到 JVM 内存中开始，到卸载出内存为止，整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）。其中，验证、准备、解析3部分统称为连接（Linking）：\n其中，加载、验证、准备、初始化、卸载这 5 个阶段的顺序是确定的（但并非串行，通常是交叉混合式进行的，只是开始执行的顺序是确定的），而解析在某些情况下可能在初始化阶段之后再开始：为了支持 java 的运行时绑定（也称动态绑定&#x2F;晚期绑定）。jvms 规定了 5 种情况下，才能对类立即进行“初始化”：\n\n遇到 new、getstatic、putstatic、invokestatic 这4条字节码指令时，如果类没有进行过初始化，则先触发其初始化。常见场景是：使用 new 关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用一个类的静态方法；\n使用 java.lang.reflect 包的方法对类进行反射调用时，如果类没有进行过初始化，则先触发其初始化；\n初始化一个类时，如果发现其父类没有进行过初始化，则先触发其父类的初始化；\nJVM 启动时，用户需要指定一个要执行的主类，JVM 会先初始化该主类；\n使用JDK 1.7+ 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发其初始化。\n\n类加载过程加载“加载”是“类加载（Class Loading）”的一个阶段，jvms 要求这一阶段需要完成以下工作：\n\n通过一个类的全限定名来获取定义此类的二进制字节流；\n将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；\n在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。\n\n该阶段用户应用程序可以通过自定义类加载器参与，类加载其余过程由 JVM 主导并控制。\n验证是为了确保 class 文件的字节流中包含的信息符合当前 JVM 的要求，并且不会危害 JVM 自身的安全。是连接阶段的第一步。主要包括：\n\n文件格式验证，魔数、版本、常量池中常量是否被支持、是否含有 utf-8 以外的编码格式…\n元数据验证，对字节码描述信息进行语义分析校验，可能包括：该类是否有父类；父类是否继承了不允许继承的类（final 修饰的类）；如果不是抽象类，是否实现了父类&#x2F;接口必须实现的所有方法；字段、方法是否与父类产生矛盾…\n字节码验证，最复杂的验证阶段：通过数据流和控制流分析，确保程序语义合法、合乎逻辑；\n符号引用验证，JVM 将符号引用转化为直接引用，该校验发生在解析阶段。\n\n准备正式为类变量分配内存并设置类变量初始值（一般就是零值），这些变量所使用的内存都在方法区中分配：仅包括类变量（static 修饰）而不包括实例变量，实例变量将在对象实例化时随着对象一起分配在 java 堆中。\n解析JVM 将常量池内的符号引用替换为直接引用的过程。解析阶段的两者含义：\n\n符号引用（Symbolic References）：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。\n可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。\n\n初始化类加载过程的最后一步。\n类加载器类加载器（Class Loader）是 java 语言的一项创新。在类加载的第一阶段“加载”过程中，需要通过 类的全限定名 来获取定义此类的二进制字节流，完成这个操作的模块就是 类加载器。这一操作是在 JVM 外部实现的，以便让应用程序自己（开发者）决定如何获取所需的类。jvms 并没有指明类的二进制字节流要从一个 .class 文件获取，也没有指明从哪里获取、怎样获取。这种开放使得 java 在许多领域得到充分利用，目前有以下常用方式获取字节流：\n\n从 zip 包中读取：jar，ear，war 等；\n从网络中获取，最典型的应用就是 Applet；\n运行时计算生成，最典型的是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 “*$Proxy” 的代理类的二进制字节流；\n由其他文件生成，最典型的 jsp 应用，由 jsp 文件生成对应的 Class 类，etc.\n\n分类从 JVM 角度看，只存在两种类加载器：\n\n启动类加载器（Bootstrap ClassLoader），JVM 自身的一部分，C++ 实现。负责将 \\lib 目录中或被 -Xbootclasspath 参数所指定的路径中的类库加载到 JVM 内存中，这些类库必须能够被 JVM 识别（仅按照文件名识别，如 tr.jar，名称不符合的类库不会被加载）。_如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可_。\n所有其他的类加载器，独立于 JVM，java 实现，全部继承自抽象类 java.lang.ClassLoader。包括下面的扩展类加载器、应用程序类加载器等。\n\n从开发人员角度看，绝大部分 java 程序会使用到以下 3 种系统提供的类加载器：\n\n启动类加载器（Bootstrap ClassLoader）；\n扩展类加载器（Extension ClassLoader）,这个加载器由 sun.misc.Launcher $ExtClassLoader 实现，它负责加载\\lib\\ext目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器；\n应用程序类加载器（Application ClassLoader）：这个类加载器由 sun.misc.Launcher $App-ClassLoader 实现。这个类加载器是 ClassLoader 中的 getSystemClassLoader() 的返回值（所以也称它为系统类加载器）。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。如果应用程序中没有自定义类加载器，一般情况下它就是默认类加载器。\n\n双亲委派模型\n所谓的类加载器的双亲委派模型指的是 类加载器之间的层次关系。图中所示类加载器之间的层次关系，就是类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应有自己的父加载器。类加载器之间的父子关系一般不会以继承关系（Inheritance）的关系来实现，而是使用组合（Composition）关系来复用父加载器的代码。_双亲委派模型不是强制性约束模型，而是 java 设计者推荐给开发者的一种类加载器实现方式_。\n工作过程如果一个类收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成该加载请求（其搜索内没有找到所需的类）时，子类加载器才会尝试自己去加载。即搜索是从顶层加载器到发出加载请求的加载器各自维护的搜索范围依次进行搜索的。实现双亲委派模型的代码集中在 java.lang.ClassLoader 的 loadClass() 中，具体流程：先检查是否已经加载过该类，若没有，则调用父加载器的 loadClass()，若父加载器为 null，则默认使用启动类加载器作为父加载器。如果父加载器加载失败，抛出 ClassNotFoundException 后，调用自身 findClass() 进行加载。\nprotected Class&lt;?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException &#123;\n    synchronized (getClassLoadingLock(name)) &#123;\n        // 检查是否已经加载过该类\n        Class&lt;?> c = findLoadedClass(name);\n        if (c == null) &#123;\n            long t0 = System.nanoTime();\n            try &#123;\n                if (parent != null) &#123;\n                    c = parent.loadClass(name, false);\n                &#125; else &#123;\n                    c = findBootstrapClassOrNull(name);\n                &#125;\n            &#125; catch (ClassNotFoundException e) &#123;\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n            &#125;\n\n            if (c == null) &#123;\n                // If still not found, then invoke findClass in order\n                // to find the class.\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                // this is the defining class loader; record the stats\n                PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                PerfCounter.getFindClasses().increment();\n            &#125;\n        &#125;\n        if (resolve) &#123;\n            resolveClass(c);\n        &#125;\n        return c;\n    &#125;\n&#125;\n\n意义使用双亲委派模型来组织类加载器之间的关系，好处之一是：java 类随着它的类加载器一起，具备了一种带有优先级的层次关系。例如 java.lang.Object 类，它存放在 rt.jar 中，无论哪个类加载器请求加载这个类，最终都是委派给处于模型顶层的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相对地，如果不使用双亲委派模型，而是由各个类加载器自行加载请求类的话，如果开发者编写了一个名为 java.lang.Object 的类，并把它放在程序的 ClassPath 中，那么系统将会出现多个不同的 Object 类，这会导致 java 类型体系中最基础的行为也无法保证，应用程序也将变得非常混乱。内存模型中，判断一个对象是否为某个类型时，前提是比较对象与被比较对象都来自同一个类加载器，否则没有对比的意义——返回 false。\n破坏双亲委派模型上述已经提到，这只是一个推荐实现，而非强制约束，这就意味着有可能（有意&#x2F;无意）不被遵循。（详见《深入理解java虚拟机》）。\n自定义类加载器几个重要方法\nloadClass()上面已经提到。\nfindClass()protected Class&lt;?> findClass(String name) throws ClassNotFoundException &#123;\n    throw new ClassNotFoundException(name);\n&#125;\n可见，默认抛出异常。上面提到 locaClass() 在父加载器无法加载类时，会调用自身的 findClass() 进行加载，所以必须在 loadClass() 中实现将一个指定类名转换为 class 对象，转换中借助 defineClass 方法。\ndefineClass()protected final Class&lt;?> defineClass(String name, byte[] b, int off, int len)\n        throws ClassFormatError  &#123;\n        return defineClass(name, b, off, len, null);\n&#125;\n\n将一个字节数组转为 class 对象，这个字节数组是 class 文件读取后最终的字节数组。如，假设 class 文件是加密过的，则需要解密后作为形参传入。\n对象内存布局对象头64位：\n32位：\n实例数据对齐填充JMM内存模型：为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。其解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。\nJMM定义了JVM在计算机内存中的工作方式，主要涉及到 多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。\n高速缓存机制目前，CPU的运算速度比计算机存储设备有几个数量级的差距，所以现代计算机都有一层（三层）读写速度尽可能接近处理器的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。基于高速缓存的存储交互很好地解决了处理器与内存之间的矛盾，但也为计算机体系架构设计带来了更高的复杂度，因为引入了一个新的问题：缓存一致性（Cache Coherence）：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存（Main Memory），当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致，此时，同步回主存的数据以谁为准呢？为解决这种不一致，需要各个处理器访问缓存时都遵循一些协议来保证读写操作的正确性。这类协议有 MSI、MESI、MOSI、Synapse、Firefly、Dragon Protocol 等。而 内存模型，即可以理解为在特定的操作协议下，对特定的内存&#x2F;高速缓存进行读写访问的过程抽象。不同架构的物理机器可以有不同的内存模型，jvm 拥有自己的内存模型。\n重排序问题为使得处理器内部运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但 不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，jvm的即时编译器也有类似的指令重排（Instruction Reorder）优化。\njvms定义的java内存模型（Java Memory Model，JMM），试图屏蔽掉各种硬件和OS的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。目前已臻至成熟。JMM规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与上述物理硬件的主内存名字一样，两者也可以互相类比，但此处仅是jvm内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n这里所讲的主内存、工作内存，和java内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。\n内存间交互操作JMM 规定了以下 8 种操作，来完成主内存和工作内存之间具体的交互协议——即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节：\n\nlock（锁定）：作用于主内存变量，它把一个变量标识为仅能被一条线程独占的状态；\nunlock（解锁）：作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量可以被其他线程访问&#x2F;锁定；\nread（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后续的 load 操作使用；\nload（载入）：作用于工作内存的变量，它把 read 操作从主内存得到的变量值放入工作内存的变量副本中；\nuse（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；\nassgin（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作；\nstore（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传回到主内存中，以便后续的 write 操作使用；\nwrite（写入）：作用于主内存变量，它把 store 操作从工作内存中得到的变量的值放入到主内存的变量中。如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，JMM只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插入其他指令的。\n\n此外，JMM还规定了在执行上述8种基本操作时必须满足如下规则：\n\n不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现；\n不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存；\n不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中；\n一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。\n一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁；\n如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值；\n如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量；\n对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。\n\n8种内存访问操作和上述规则限定，再加上对volatile关键字的一些特殊规定，就已经完全确定了java程序中哪些内存访问操作在并发下是安全的。以上定义严谨但繁琐，其有一个等效判断原则——先行发生原则，也同样能够确定一个访问在并发环境下是否安全。\nvolatile关键字volatile可以被认为是jvm提供的最轻量级的同步机制。volatile变量在各个线程的工作内存中不存在一致性问题：在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题。当一个变量被定义为volatile后，它具备两个特性：\n\n保证此变量对所有线程的可见性这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。（回想普通变量，其值在线程间传递均需要通过主内存来完成，例如，线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见）。但可见性并不意味着线程安全，事实上，volatile 并不是线程安全的，它并不能保证操作符合原子性。所以在一些有依赖的运算中，仍然要通过加锁（使用 synchronized 或 java.util.concurrent 中的原子类）来保证原子性。\n禁止指令重排序优化普通变量仅保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不保证变量赋值操作的顺序与程序代码中的执行顺序一致。而在一个线程的方法执行过程中无法感知到这点，这也就是 JMM 描述的所谓“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。从硬件上讲，指令重排不是以指令顺序任意执行，而是CPU在正确处理依赖情况的前提下，可能会将没有依赖关系的指令（来自于代码汇编的字节码）不按程序中代码顺序分开发送给相应电路单元进行处理，并且保证在后续有对之前的操作结果有依赖的地方能够取到正确的值，这样从最终结果上看依然是像有序执行的结果；而有依赖关系的代码指令之间不能重排。volatile能够禁止指令的重排优化，通过汇编代码可见，有volatile修饰的变量在执行操作后，会多执行一句“lock addl $0x0，(%esp)”指令（把 ESP 寄存器的值加 0，显然是一个空操作），这相当于一道内存屏障使得指令重排序无法逾越，关键就在于其lock前缀，它的作用是使得本CPU的Cache写入内存，同时该写入动作会引起别的CPU或者别的内核无效化（Invalidate）其Cache，即相当于对Cache中的变量做了一次JMM中的“store和write”操作。所以通过这样一个空操作，可让volatile变量的修改对其他CPU立即可见。\n\nvolatile vs 锁显然，volatile并不等同于安全的锁，它也无法在多线程中保证安全性，但在特定场景下依然能够提供“足够的安全性”且比锁（synchronized 关键字或 java.util.concurrent 包里面的锁）效率更高。但随着 jvm 对锁的各种优化策略的进步——锁消除、锁粗化等，已无法简单定量分析究竟孰优孰劣。而如果让 volatile 自身对比，那可以确定一个原则：volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据应该是volatile的语义能否满足使用场景的需求。使用场景（满足以下条件时使用）\n\n对变量的写操作不依赖变量的当前值或其他的变量，或者能确保只有单个线程更新变量值；\n该变量不会与其他状态变量一起纳入不变性条件中；\n在访问变量时不需要加锁。\n\nlong 和 double对于64位的数据类型（long 和 double），JMM规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现不保证64位数据类型的load、store、read、write 这4个操作的原子性——但同时强烈建议jvm保证其操作的原子性，所以目前多数商用jvm都选择把64位数据的读写操作作为原子操作对待来实现。\n原子性 可见性 有序性JMM是围绕在并发过程中如何处理原子性、可见性和有序性这3个特性而建立起来的。\n原子性 AtomicityJMM直接保证基本数据类型（64位的姑且也可以包含在内）的读写访问（read、load、assign、use、store、write）具备原子性。如果场景需要更大范围的原子性保证（经常发生），JMM提供lock、unlock操作来满足这种需求。jvm并没有把这两个操作直接暴露给用户，而是提供了更高层次的字节码指令：monitorenter 和 monitorexit来隐式使用这两个操作。这两个字节码指令反映到java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。\n可见性 Visibility当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。JMM通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性。无论普通变量还是 volatile 变量都是如此，不同在于：volatile 的特殊规则保证了新值能够立即同步到主内存并且每次使用前立即从主内存刷新，从而保证了多线程操作中变量的可见性。除了 volatile 之外，synchronized 和 final也能保证可见性。同步块的可见性由“对一个变量执行 unlock 操作之前，必须把它同步回主内存中（执行 store、write 操作）”这条规则获得的；而 final 关键字的可见性是指：被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this 引用逃逸是危险操作，其他线程有可能通过这个引用访问到”初始化了一半”的对象），那么在其他线程中就能看见 final 字段的值，并且无须同步就能被线程正确访问。\n有序性 Ordering如果在本线程观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义（Within-Thread As-If-Serial Semantics）”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。这是 java 程序中天然的有序性。java 语言提供了 volatile 和 synchronized 关键字来保证线程之间操作的有序性，volatile 本身就包含了禁止对指令重排序的语义，而 synchronized 由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得有序性保证——该规则决定了持有同一个锁的两个同步块只能串行地进入。\n可见，synchronized 关键字在需要以上3种特性的时候都可以作为一种解决方案，事实上也是如此：大部分并发控制操作都可以使用它来完成。但滥用以及本可以考虑其他更优的方式而仍然选择使用synchronized，也将导致性能和效率的不同程度降低。\nHappen-Before 原则先行发生原则，JMM 定义的两项操作之间的偏序关系，是判断数据是否存在竞争、线程是否安全的主要依据：如果操作 A 先行发生于操作 B，i.e. 操作 A 发生在操作 B 之前，那么操作 A 产生的影响（应该保证）能被操作 B 观察到，“影响”包括修改了共享内存中变量的值、发送了消息、调用了方法等。以下为 JMM 天然存在的 Happen-Before 关系，这些先行发生关系无须任何同步器协助就能正常执行，即在编码过程中直接使用，并且如果两个操作之间的关系不在下述范围之列，或者无法从下述条目推导得出，那么它们就没有顺序性保证，jvm 就可以对它们进行重排序：\n\n程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作（更准确的说法是控制流顺序而不是代码顺序，因为有分支、循环等结构）；\n监视器锁规则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里强调同一个锁，而“后面”是指时间上的先后顺序；\nvolatile 变量规则（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。这里的“后面”同样是指时间上的先后顺序；\n传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么可以得出结论：操作 A 先行发生于 操作 C。\n线程启动规则（Thread Start Rule）：Thread 对象的 start() 方法先行于此线程的每一个动作；\n线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，可以通过 Thread.join()方法的结束、Thread.isAlive()的返回值等手段检测到线程是否已经终止；\n线程中断规则（Thread Interruption Rule）：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted()方法检测到线程是否有中断发生；\n对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始；可以根据以上规则判定一端代码是否可以保持线程安全，即是否需要采取线程安全的措施。\n\nref：Java内存模型是什么\nsynchronized &amp; Lock偏向锁假设当前场景只有一个线程，并没有线程竞争关系，不仅不存在多线程竞争，而且总是由同一线程多次获得，那么此时这个线程如果获取到锁资源，锁状态就是偏向锁，此时Synchronized修饰的锁对象会把当前线程的ID存入到MarkWord中，以后只要不发生竞争，这个对象就归该线程所有。\n轻量级锁如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。\n重量级锁重量级锁的使用场景就是多个线程竞争同一个锁资源，如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），此时需要进行锁膨胀，将轻量级锁变为重量级锁。\n优化锁膨胀jdk1.6之前，synchronized 是重量级锁。jdk1.6引入锁膨胀&#x2F;锁升级，即：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁，这时候在进行并发操作时，大部分的场景不再需要用户态到内核态的转换，从而大幅的提升 synchronized 的性能。\n锁消除JIT编译器在编译的时候，进行逃逸分析，分析synchronized锁对象是不是只可能被一个线程加锁，不存在其他线程来竞争加锁的情况。比如StringBuffer对象，属于一个局部变量，并且不会从该方法中逃逸出去，那么此时就可以使用锁消除（不加锁），替换为StringBuilder，来消除锁。\n锁粗化锁粗化是指，将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。比如for循环内对某个对象连续加锁。\n自适应自旋检测到重量级锁并进入阻塞状态的开销比较大。jdk1.4引入自旋锁，即当前线程先不进入阻塞状态，而是进行一定次数的忙循环，也就是所谓的自旋，来等待获取当前共享资源的锁，期间不让出CPU资源，如果获取失败，再进入阻塞。jdk1.6引入自适应自旋锁，所谓的自适应，即不再自旋固定的次数，而是一个动态的次数，一个实践中的规则是：自旋次数通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。如果线程【T1】自旋成功，自旋次数为17次，那么等到下一个线程【T2】自旋时，也会默认认为【T2】自旋17次；如果【T2】自旋了5次就成功了，那么此时自旋次数就会缩减到5次。\nReentrantLockvsJUCJUC包主要包括这么几个模块：\n\natomic: 原子性包，包含有AtomicBoolean、AtomicInteger、AtomicIntegerArray等原子变量类，持有它们各自的对应的类型变量value，而且被volatile关键字修饰，这样来保证每次一个线程要使用它都会拿到最新的值。\ncollections: 集合类包，主要提供线程安全的集合，包括ArrayList对应的CopyOnWriteArrayList，HashSet对应的CopyOnWriteArraySet，HashMap对应的ConcurrentHashMap等；\nlocks: 锁包，提供锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁。包含的实现类主要有：\nReentrantLock，独占锁，同一个时间点只能被一个线程锁获取到的锁；\nReentrantReadWriteLock，包括子类ReadLock和WriteLock，ReadLock是共享锁，WriteLock是独占锁；\nStampedLock，\nLockSupport，具备阻塞线程和解除阻塞线程的功能，并且不会引发死锁。\n\n\nexecutor: 执行器，Java线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有：\nScheduledExecutorService，解决那些需要任务重复执行的问题；\nScheduledThreadPoolExecutor，周期性任务调度的类实现；\n\n\ntools: 工具包，包含一些同步辅助工具类：\nCountDownLatch，闩锁，同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待；\nCyclicBarrier，栅栏，允许一组线程互相等待，直到到达某个公共屏障点 ，并且在释放等待线程后可以重用；\nSemaphore，信号量，计数信号量，它的本质是一个“共享锁“。信号量维护了一个信号量许可集。线程可以通过调用 acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。线程可以通过release()来释放它所持有的信号量许可。https://blog.csdn.net/weixin_43888181/article/details/116546374\n\n\n\n\nReentrantLockAQSAbstractQueuedSynchronizer，抽象队列同步器，使用原生java代码实现了并发访问控制语义，定义出一套多线程访问共享资源的同步器框架，是整个JUC包的基石，Lock、ReadWriteLock、CountDowndLatch、CyclicBarrier、Semaphore、ThreadPoolExecutor等都是在其基础上实现的。并发控制的核心是锁的获取与释放，AQS采用的是一种改进的CLH锁。\nCLH锁CLH(Craig, Landin, and Hagersten locks)是一种基于链表的可扩展、高性能、公平的自旋锁，能确保无饥饿性，提供先来先服务的公平性。申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。CLH队列中的节点QNode中含有一个locked字段，该字段若为true表示该线程需要获取锁，且不释放锁，为false表示线程释放了锁。节点之间是通过隐形的链表相连，之所以叫隐形的链表是因为这些节点之间没有明显的next指针，而是通过myPred所指向的节点的变化情况来影响myNode的行为。CLHLock上还有一个尾指针，始终指向队列的最后一个节点。\nAQS数据模型\nprivate transient volatile Node head;\nprivate transient volatile Node tail;\nprivate volatile int state;\nstatic final class ExclusiveNode extends Node &#123; &#125;\nstatic final class SharedNode extends Node &#123; &#125;\nabstract static class Node &#123; &#125;\n\n//原子的设置当前同步器的状态\nprotected final boolean compareAndSetState(int expect, int update) &#123;\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n&#125;\n\n\nCASCOWNIOsynchronizedvolatileThreadLocalMapUnsafe","categories":["java"],"tags":["java"]},{"title":"中间件","url":"/2018/06/03/mw/","content":"redisremote dictionary server, redis, 是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。采用 单进程单线程 方式运行。Redis 支持多种类型的数据结构，如字符串（Strings），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。redis 教程\n查询速度Redis 采用基于内存的、单进程单线程模型的 KV 数据库，由 C 语言编写。官方提供的数据是可以达到 100000+ 的 QPS（每秒内查询次数）。\n高效查询的原因\n纯内存操作，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；\n数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；\n采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；\n使用多路 I&#x2F;O 复用模型，非阻塞 IO；\n底层模型不同，Redis 直接构建了专用的 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。\n\n单线程的问题首先要明确，这里单线程是指，Redis 只使用一个线程来处理网络请求，而一个 Redis Server 处于运行状态时还是有多个线程的，比如用于持久化的子线程&#x2F;子进程。此外，进入 4.0 版本后，某些操作上开始支持多线程执行，不排除后续版本将整个服务都采用多线程的可能。显然，单线程无法发挥多核的优势，通常在单机开启多个 Redis 实例以充分利用多核环境资源。为什么说Redis是单线程的\n基于 Key-Value 的 NoSQL 内存数据库也称数据结构服务器。特点和优势：\n\n支持数据的持久化，可以将内存中的数据持久化到磁盘中，重启时再次加载使用；\n不仅支持简单的 key-value 类型数据，同时还提供 list、set、zset、hash 等数据结构的存储；\n支持数据备份，即 master-slave 模式的数据备份；\n性能极高：读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s；\n丰富的数据类型，提供了5种数据结构：String、List、Hash、Set、Ordered Set（ZSet）；\n原子操作：Redis 的所有操作都是原子性的，同时还支持对几个操作全并后的原子性执行；\n丰富的特性：支持 publish&#x2F;subscribe、通知 key 过期等特性。\n\n数据结构\n\nstring类似于其他编程语言中字符串的概念。redis 中的 string 类型是二进制安全的，i.e. 可以包含任何数据，比如一张 .jpg 格式的图片。一个键最大存储量为 512 MB。\n\n\nlist按照插入顺序有序存储多个字符串，相同元素可重复，双向操作（LPHSH、LPOP、RPUSH、RPOP）。每个 list 最多存储元素数量：2^32 - 1。\n\n\nset集合和列表都可以存储多个字符串，不同之处在于：列表可以存储多个相同的字符串，集合通过 散列表来保证存储的每个字符串都是不相同的。redis 的集合使用无序（unordered）方式存储元素，不支持像列表一样将元素从某一端 push&#x2F;pop 的操作，相应地，使用 SADD&#x2F;SREM 添加&#x2F;移除元素。由于是通过哈希表实现的，所以添加&#x2F;移除&#x2F;查找的时间复杂度为 O(1)。每个 set 最多存储元素数量：2^32 - 1。\n\n\nhash可以存储多个键值对之间的映射。官方推荐：尽可能使用hash存储数据。每个 hash 最多存储键值对数量：2^32 - 1。\n\n\nzset有序集合（zset）和散列一样，都用于存储键值对，不支持重复元素。不同之处在于：有序集合的键被称为成员（member），每个成员都是各不相同的；值被称为分值（score），必须为浮点数（分值可重复）。zset 既可以根据成员访问元素（和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。每个 zset 最多存储键值对数量：2^32 - 1。\nuse case作为分布式锁分布式锁至少要满足三个属性要求：  \n\n安全方面（Safety property）：互斥。在任一时刻，只有一个client可以获取锁；\n活性A（Liveness property）：无死锁。即便持有锁的client崩溃（crashed)或者网络被分裂（gets partitioned)，锁仍然可以被获取；\n活性B（Liveness property）：容错。只要多数Redis节点活着，client就可以获取和释放锁。\n\n参见 redlock\n作为LRU缓存redis提供多种key淘汰机制：  \n\nnoeviction: 不淘汰，当超过内存限制，抛出异常；\nallkeys-lru: 在所有键中，选取最近最少使用的数据抛弃；\nvolatile-lru: 在设置了过期时间的所有键中，选取最近最少使用的数据抛弃；\nallkeys-random: 在所有键中，随机抛弃；\nvolatile-random: 在设置了过期时间的所有键中，随机抛弃；\nvolatile-ttl: 在设置了过期时间的所有键中，抛弃存活时间最短的数据；4.0 新增：\nallkeys-lfu: 在所有键中，选取使用频率最少的数据抛弃；\nvolatile-lfu: 在设置了过期时间的所有键中，选取使用频率最少的数据抛弃；\n\nPersistenceredis提供不同的持久化选项：  \n\nRDB: 在指定的时间间隔内将内存中的数据集快照写入磁盘；\nAOF(append only file): 将server接收到的每个操作日志以追加的方式写入文件；\n\n多线程6.0版本开始支持多线程。\n","categories":["mw"],"tags":["mw"]},{"title":"os","url":"/2018/06/03/os/","content":"","categories":["os"],"tags":["os"]},{"title":"spring","url":"/2018/06/03/spring/","content":"核心模块包括Bean、Context、Core。\nbeanspring的核心思想常常被称作BOP(Bean Oriented Programming)，面向Bean编程。Bean模块解决以下问题：\n\nbean的定义；\nbean的创建；\nbean的解析；\n\n作为业务开发通常只需要关心bean的创建，其他两个过程由spring内部完成。Bean的整体架构是典型的工厂模式，最上层的接口是BeanFactory。ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBean是其子类，目的是为了区分Spring内部对象处理和转化的数据限制：ListableBeanFactory: 表示这些Bean是可列表的，定义bean的集合；HierarchicalBeanFactory: 表示这些Bean有继承关系，定义bean的关系；AutowireCapableBeanFactory: 定义Bean的自动装配规则，定义bean的行为；\nbean定义，主要由BeanDefinition描述，成功解析后都会被转化为BeanDefinition对象，之后所有的操作都会在BeanDefinition对象之上进行。层次关系如下：\ncontextBean包装的是一个个Object，Object中存储着业务所需的数据。那么，如何给这些数据以及它们之间的关系提供生存、运行环境——即保存对象的状态，就是Context要解决的问题。Context就是bean关系的集合，即IoC容器。ApplicationContext是Context最上层的接口，层次关系如下：ApplicationContext能够标识一个应用环境的基本信息，继承了5个接口，用于拓展Context的功能，其中BeanFactory用于创建Bean，同时继承了ResourceLoader接口，用于访问任何外部资源。子类主要包括：\n\nConfigurableApplicationContext: 可动态配置和修改信息的Context，其下AbstractRefreshableApplicationContext最为常用。\nWebApplicationContext: 为Web应用准备的Context，可以直接访问ServletContext。\n\n作为Ioc容器，Context是Spring其他大部分功能的基础，ApplicationContext必须完成的功能包括：\n\n标识一个应用环境；\n利用BeanFactory创建Bean对象；\n保存对象关系表；\n捕获各种事件。\n\ncoreSpring发现、建立和维护Bean之间关系的一系列工具，实际上就是各种util。\nResource：core最重要的组成部分，主要定义了资源的访问方式，所有资源都抽象到了Resource接口中，主要作用：\n\n资源包装。Resource向上继承了InputStreamSource接口，所有的资源都通过InputStream来获取，从而屏蔽了资源提供者；\n资源加载。Resource下的ResourceLoader接口，所有资源加载者统一实现该接口就能加载所有的资源，例如之前的ApplicationContext。\n\n与Context建立关系：ApplicationContext通过ResourcePatternResolver接口与ResourceLoader进行交互，来进行资源的加载、解析和描述。ResourcePatternResolver将资源封装整合，便于其他模块使用。\nIoC 容器结构Spring IoC容器用于创建并管理Spring Bean对象以及Bean属性注入。通过ResourceLoader&#x2F;Resolver读取Bean的配置文件并转换成统一资源对象（Resource），然后通过BeanDefinitionReader转换成pring内部对Bean的描述对象（BeanDefinition），然后将其注册（BeanRegister）到容器中（BeanFactory），供以后转换成Bean对象使用。spring项目源代码很好地把它们划分到了不同的模块中，即上面的三个模块。而从资源读取、描述对象转换、注册使用这些阶段，从源码中又可以抽出以下6个组件：\n\n资源组件：Resource，对资源文件的描述，不同资源文件如xml、properties文件等，格式不同，最终都将被ResourceLoader加载获得相应的Resource对象；\n资源加载组件：ResourceLoader：加载xml、properties等各类格式文件，解析文件，并生成Resource对象；\nBean容器组件：BeanFactory体系，IoC容器的核心；\nBean注册组件：SingletonBeanRegister&#x2F;AliasRegister，将BeanDefinition对象注册到BeanFactory（BeanDefinition Map）中去；\nBean描述组件：BeanDefinition体系，Spring内部对Bean描述的基本数据结构；\nBean构造组件：BeanDefinitionReader体系，读取Resource并将其数据转换成一个个BeanDefinition对象。\n\nResource如各类型的文件，二进制流数据都是资源，是Spring内部对资源的统一描述，整个体系类图网如下：\nResourceLoaderResourceLoader&#x2F;Resolver体系，负责资源的加载，这里的资源指的是xml、properties等文件资源，返回一个对应类型的Resource对象。\nBeanDefinition对bean对象描述的基本数据结构。\nBeanDefinitionReaderBean构造组件，BeanDefinitionReader体系，将Resource对象，转换成BeanDefinition对象，就是将内部资源数据转换成Spring Bean描述数据。就是将统一资源数据对象读取转换成相应内部对象。\nSingletonBeanRegister&#x2F;AliasRegisterBean注册组件，将BeanDefinition对象注册到BeanFactory中。\nBeanFactoryBean容器组件，整个IoC容器核心，所谓Bean容器，就是这里装着Bean对象以及所需要的各种数据。其中BeanFactory是纯粹的Bean容器，用来存储描述Bean，无关其他环境，而像ApplicationContext，也是Bean容器，但它和应用环境息息相关，所以被称为应用上下文（环境）更恰当，从图中也能看出来，ApplicationContext不仅有着BeanFactory“血统”，同时也继承了EnvironmentCapable、MessageSource、ApplicationEventPublisher，即扩展了其许多额外功能，而其实现类则是和具体应用相关。\nSpringBoot启动过程请求处理过程以典型的web应用为例，一个请求从接收到返回的处理过程相当复杂，如下图所示，主要经过DispatcherServlet、HandlerMapping、Controller、ViewResolver、Model等：\n\n客户端请求提交到DispatcherServlet；\n由DisPatcherServlet控制器寻找一个或多个HandlerMapping，找到处理请求的Controller；\nDispatcherServlet将请求提交到Controller；\nController调用业务逻辑处理后返回ModelAndView；\nDispatcherServlet寻找一个或多个ViewResolver视图解析器，找到ModelAndView指定的视图；\n视图负责将结果显示到客户端。\n\nSpring MVC所有的请求都经过DispatcherServlet来统一分发，在 DispatcherServlet将请求分发给Controller之前需要借助Spring MVC提供的 HandlerMapping定位到具体的Controller。HandlerMapping接口负责完成客户请求到Controller映射。Controller接口将处理用户请求，这和Java Servlet扮演的角色是一致的。一旦Controller处理完用户请求，将返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。ViewResolver接口（视图解析器）在Web应用中负责查找View对象，从而将相应结果渲染给客户。\n过滤器和拦截器这张图解释了典型spring应用常用组件及触发顺序：过滤器在请求进入容器之后、进入servlet之前就被触发，此时还没有进入spring的管辖范围。拦截器是spring提供并管理的，所以它能获取IoC容器信息，比如拿到容器里的bean。\n这张图解释了常用组件具体方法的执行顺序：\nfilterFilter是JavaEE中Servlet规范的一个组件，它可以在http请求到达Servlet之前，被N个Filter处理：过滤器的实现是基于函数回调。\n应用场景\n过滤敏感词汇（防止sql注入）\n设置字符编码\nURL级别的权限访问控制\n压缩响应信息\n\ninterceptor用于拦截Controller方法的执行，可以在方法执行、后添加自定义逻辑，类似于AOP编程思想。其实现是基于反射机制——动态代理。\n应用场景拦截器本质上是面向切面编程（AOP），符合横切关注点的功能都可以放在拦截器中来实现，主要的应用场景包括：\n\n登录验证，判断用户是否登录。\n权限验证，判断用户是否有权限访问资源，如校验token\n日志记录，记录请求操作日志（用户ip，访问时间等），以便统计请求访问量。\n处理cookie、本地化、国际化、主题等。\n性能监控，监控请求处理时长等。\n通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现）\n\n后处理器BeanFactoryPostProcessor容器级别的后处理器。\nBeanPostProcessor监听器三级缓存https://cloud.tencent.com/developer/article/1497692\nbean生命周期IoC容器初始化过程：Spring容器中Bean的生命周期由多个特定的阶段组成，每个阶段都允许外界对Bean加以控制。在Spring中可以从两个层面定义Bean的生命周期：Bean的作用范围；实例化Bean时所经历的一系列阶段。\n文字描述\nBean容器在配置文件中找到Spring Bean的定义。\n\nBean容器使用Java Reflection API创建Bean的实例。\n\n如果声明了任何属性，声明的属性会被设置。如果属性本身是Bean，则将对其进行解析和设置。以上步骤见“spring IoC 源码解析”。\n\n如果Bean类实现BeanNameAware接口，则将通过传递Bean的名称来调用setBeanName()方法。如果Bean类实现BeanClassLoaderAware接口，则将通过传递加载此Bean的ClassLoader对象的实例来调用setBeanClassLoader()方法。如果Bean类实现BeanFactoryAware接口，则将通过传递BeanFactory对象的实例来调用setBeanFactory()方法。如果有任何与BeanFactory关联的BeanPostProcessors对象已加载Bean，则将在设置Bean属性之前调用postProcessBeforeInitialization()方法。如果Bean类实现了InitializingBean接口，则在设置了配置文件中定义的所有Bean属性后，将调用afterPropertiesSet()方法。如果配置文件中的Bean定义包含init-method属性，则该属性的值将解析为Bean类中的方法名称，并将调用该方法。如果为Bean Factory对象附加了任何Bean 后置处理器，则将调用postProcessAfterInitialization()方法。如果Bean类实现DisposableBean接口，则当Application不再需要Bean引用时，将调用destroy()方法。如果配置文件中的Bean定义包含destroy-method属性，那么将调用Bean类中的相应方法定义。\n\n\nBeanFactory中Bean的生命周期具体过程：\n\n当调用者通过getBean(beanName)向容器请求某一个Bean时，如果容器注册了org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor接口，则在实例化Bean之前，将调用接口的postProcessBeforeInstantiation()；\n根据配置情况调用Bean构造方法或工厂方法实例化Bean；\n如果容器注册了InstantiationAwareBeanPostProcessor接口，那么在实例化Bean之后，调用该接口的postProcessAfterInstantiation()，可在这里对已经实例化的对象进行一些“梳妆打扮”；\n如果Bean配置了属性信息，那么容器在这一步着手将配置值设置到Bean对应的属性中，不过在设置每个属性之前将先调用InstantiationAwareBeanPostProcessor接口的postProcessPropertyValues()；\n调用Bean的属性设置方法设置属性值；\n如果Bean实现了org.springframework.beans.factory.BeanNameAware接口，则将调用setBeanName()，将配置文件中该Bean对应的名称设置到Bean中；\n如果Bean实现了org.springframework.beans.factory.BeanFactoryAware接口，则将调用setBeanFactory()，将BeanFactory容器实例设置到Bean中；\n如果BeanFactory装配了org.springframework.beans.factory.config.BeanPostProcessor后处理器，则将调用BeanPostProcessor的Object postProcessBeforeInitialization(Object bean, String beanName)对Bean进行加工操作。其中，入参bean是当前正在处理的bean，beanName时当前bean的配置名，返回的对象为加工处理后的Bean。可以使用该方法对Bean进行处理，甚至改变Bean的行为。BeanPostProcessor在Spring框架中占有重要地位，为容器提供对Bean进行后续加工处理的切入点，Spring容器所提供的各种“神奇功能”，如AOP，动态代理等，都是通过它来实施的；\n如果Bean实现了InitializingBean接口，则将调用接口的afterPropertiesSet()；\n如果在&lt;bean&gt;中通过init-method属性定义了初始化方法，则将执行这个方法；\nBeanPostProcessor后处理器定义了两个方法：其一是postProcessBeforeInitialization()，在(8)步调用；其二是Object postProcessAfterInitialization(Object bean, String beanName)，这个方法在此时调用，容器再次获得对Bean进行加工处理的机会；\n如果在&lt;bean&gt;中指定Bean的作用范围是scope&#x3D;”prototype”，则将Bean返回给调用者，调用者负责Bean后续生命周期的管理，Spring不再管理这个Bean的生命周期。如果将作用范围设置为scope&#x3D;”singleton”，则将Bean放入Spring IoC容器的缓存池中，并将Bean引用返回给调用者，Spring继续对这些Bean进行后续的生命管理；\n对于scope&#x3D;”singleton”的Bean（默认情况），当容器关闭时，将触发Spring对Bean后续生命周期的管理工作。如果Bean实现了DisposableBean接口，则将调用接口的destory()，可以在此编写释放资源、记录日志等操作；\n对于scope&#x3D;”singleton”的Bean，如果通过&lt;bean&gt;的destory-method属性指定了Bean的销毁方法，那么Spring将执行Bean的这个方法，完成Bean资源的释放等操作。\n\nBean的完整生命周期从Spring容器着手实例化Bean开始，直到最终销毁Bean。其中经过了许多关键点，每个关键点都涉及特定的方法调用，可以将这些方法大致分为4类：\n\nBean自身的方法：如调用Bean构造方法实例化Bean、调用setter设置Bean的属性值以及通过&lt;bean&gt;的init-method和destory-method所指定的方法；\nBean级生命周期接口方法：如BeanNameAware、BeanFactoryAware、InitializingBean和DisposableBean，这些接口方法由Bean类直接实现；\n容器级生命周期接口方法：图示中⭐标识的步骤是由InstantiationAwareBeanPostProcessor和BeanPostProcessor这两个接口实现的，一般称它们的实现类为“后处理器”。后处理器接口一般不由Bean本身实现，它们独立于Bean，实现类以容器附加装置的形式注册到Spring容器中，并通过接口反射为Spring容器扫描识别。当Spring创建任何Bean的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的。也可以自行编写后处理器，让其仅对感兴趣的Bean进行加工处理；\n工厂后处理器接口方法：包括AspectJWeavingEnabler、CustomAutowireConfigurer、ConfigurationClassPostProcessor等方法。工厂后处理器也是容器级的，在应用上下文装配配置文件后立即调用。\n\nApplicationContext中Bean的生命周期Bean在应用上下文中的生命周期和在BeanFactory中的生命周期类似，不同的是，如果Bean实现了org.springframework.context.ApplicationContextAware接口，则会增加一个调用接口方法setApplicationContext()的步骤。  \n作用域Spring定义了多种作用域：\n\n单例（singleton），在整个应用中，只创建bean的一个实例。\n原型（prototype），每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。\n会话（session），在web应用中，为每个会话创建一个bean实例。\n请求（request），在web应用中，为每个请求创建一个bean实例。\n\n默认情况下，Spring的所有bean都是单例（singleton）的。使用@Scope注解来选择其它作用域，它可与@Component、@Bean一起使用。两种方式（推荐1）：\n1. \n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class AClass&#123;...&#125;\n\n@Component\n@Scope(\"prototype\")\npublic class AClass&#123;...&#125;\n\n@Override\npublic Object getBean(String name) throws BeansException &#123;\n\treturn doGetBean(name, null, null, false);\n&#125;\n\t\n在xxxConfig类中使用@Bean注解声明bean时和上述方式相同。会话和请求作用域，使用场景是web应用，从命名理解：会话作用域是指该bean的生命周期和一个会话的起始保持一致，比如典型的电商场景，用户登录，搜索商品，加入购物车，购买，付费，结束，这个流程就是一个完整的会话；请求作用域是指用户从发起一个请求开始，到服务器相应该请求的过程。这两种作用域的bean就是在该场景下，随着会话&#x2F;请求的生命周期实例化到销毁，典型的，如电商场景中的”购物车”。\n\nprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123;\n\t// Make sure bean class is actually resolved at this point.\n\t// 解析出 Class\n\tClass&lt;?> beanClass = resolveBeanClass(mbd, beanName);\n\n\tif (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;\n\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName());\n\t&#125;\n\n\t// 如果工厂方法不为空，则是用工厂方法初始化\n\tif (mbd.getFactoryMethodName() != null)  &#123;\n\t\t// 相关知识点看另一篇文章关于FactoryBean的\n\t\treturn instantiateUsingFactoryMethod(beanName, mbd, args);\n\t&#125;\n\n\t// Shortcut when re-creating the same bean...\n\t// 如果不是第一次创建，比如第二次创建 prototype bean。\n\t// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化\n\t// 所以注释说叫shortcut\n\tboolean resolved = false;\n\tboolean autowireNecessary = false;\n\tif (args == null) &#123;\n\t\tsynchronized (mbd.constructorArgumentLock) &#123;\n\t\t\tif (mbd.resolvedConstructorOrFactoryMethod != null) &#123;\n\t\t\t\t// 有已经解析过的构造方法\n\t\t\t\tresolved = true;\n\t\t\t\tautowireNecessary = mbd.constructorArgumentsResolved;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t// 如果已经解析过则使用解析好的构造方法不需要再次锁定\n\tif (resolved) &#123;\n\t\tif (autowireNecessary) &#123;\n\t\t\t// 构造方法自动注入\n\t\t\treturn autowireConstructor(beanName, mbd, null, null);\n\t\t&#125;\n\t\telse &#123;\n\t\t\t// 默认构造方法\n\t\t\treturn instantiateBean(beanName, mbd);\n\t\t&#125;\n\t&#125;\n\n\t// Need to determine the constructor...\n\t// 判断是否采用有参构造函数\n\t// 构造器自动装配\n\tConstructor&lt;?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n\tif (ctors != null ||\n\t\t\tmbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n\t\t\tmbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;\n\t\treturn autowireConstructor(beanName, mbd, ctors, args);\n\t&#125;\n\n\t// No special handling: simply use no-arg constructor.\n\t// 使用无参构造器\n\treturn instantiateBean(beanName, mbd);\n&#125;\n\n\n\nBeanFactory vs FactoryBean首先，它们都是spring framework里比较顶层的接口：BeanFactory可以看做最简版的容器形式，也给具体的IOC容器实现提供规范，比如ApplicationContext；FactoryBean为IOC容器中的Bean创建提供更加灵活的方式，通过给Bean的实现加上一个简单的工厂模式和装饰器模式，使得对Bean的配置更加便捷灵活。从另一个角度讲，两者都是工厂，FactoryBean本身也是一个Factory，并且归BeanFactory管理。\nBeanFactory以Factory结尾的都是工厂类&#x2F;接口。它是IOC容器的核心接口，其职责包括：实例化、定位、配置应用程序中的对象，以及建立这些对象间的依赖。FactoryBean只是一个接口，并非IOC容器的具体实现，但spring给出了很多种实现：ApplicationContext、DefaultListableBeanFactory、AnnotationConfigApplicationContext等。其中AnnotationConfigApplicationContext是目前构建具体应用很常用的一个，它实现将以注解方式描述组成应用的对象和对象间的依赖关系。AnnotationConfigApplicationContext类将持有注解配置的所有元数据信息，并用这些元数据构建一个完全可配置的系统或应用。再如，ApplicationContext，派生自BeanFactory，仍然是一个接口，但它提供一种更面向框架的方式工作，并且对上下文进行分层和实现继承关系。同时它还派生自MessageSource、ApplicationEventPublisher、HierarchicalBeanFactory、ResourcePatternResolver等接口，从而扩充了以下能力：\n\nMessageSource, 提供国际化的消息访问;\n资源访问，如URL和文件;\n事件传播;\n载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层;\n\n其他各种BeanFactory的子接口、子类也都是扩展了某种功能的类工厂，用于特定场景。\n主要方法：\n使用场景\n从IOC容器中获取Bean(byName or byType)\n检索IOC容器中是否包含指定的Bean\n判断Bean是否为单例\n\nFactoryBean首先它是一个Bean，用于生产&#x2F;修饰其他Bean的工厂Bean，表现为一个工厂的职责，主要用到工厂模式、装饰器模式。通常情况下，spring容器担任工厂的角色，但也存在一些场景，比如某些Bean实例化过程复杂，需要配置大量信息，此时可以提供一个FactoryBean，用它来实现定制化的Bean实例化逻辑。FactoryBean接口对于Spring框架来说有着重要地位，自身就提供了70多个FactoryBean的实现。\n主要方法：\n使用场景FactoryBean在Spring中最为典型的一个应用就是用来创建AOP的代理对象。AOP实际上是Spring在运行时创建了一个代理对象，也就是说这个对象是在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说，AOP代理对象通过Java的反射机制，在运行时创建了一个代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——ProxyFactoryBean。\nIoCInversion of Control，控制反转，也称依赖注入（DI，Dependency Injection）。应用对象之间的解耦。通常所讨论的依赖注入是将一个bean的引用注入到另一个bean的属性或构造器参数中，即将一个对象与另一个对象关联起来。java的反射是实现依赖注入的底层技术。依赖注入是Spring容器的内核，AOP、声明式事务等功能也都基于此。Spring是一种容器框架，它帮助完成类的初始化和装配工作，让开发者从这些底层实现类的实例化、依赖关系装配等工作中解脱出来，专注于业务逻辑的开发工作。它通过配置文件或注解描述类和类之间的依赖关系，利用java的反射功能实例化Bean并建立Bean之间的依赖关系，自动完成类的初始化和依赖注入工作。此外，Spring还提供Bean实例缓存、生命周期管理、Bean实例代理、事件发布、资源装载等高级服务。BeanFactory(com.springframework.beans.factory.BeanFactory)是Spring框架最核心的接口，它提供了高级IoC的配置机制。BeanFactory使管理不同类型的java对象成为可能，应用上下文(com.springframework.context.ApplicationContext)建立在BeanFactory基础之上，提供了更多面向应用的功能，如i18n和框架事件体系等，更易于创建实际应用。一般称BeanFactory为IoC容器，称ApplicationContext为应用上下文，有时也称后者为Spring容器。用途上，BeanFactory是Spring框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都可以直接使用ApplicationContext而非底层的BeanFactory。\nApplicationContext如果说BeanFactory是Spring的”心脏“，那么ApplicationContext就是完整的”身躯“。ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置的方式实现。ApplicationContext的主要实现类是ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，前者默认从类路径加载配置文件，后者默认从文件系统中装载配置文件。可见，除继承HierarchicalBeanFactory和ListableBeanFactory接口外，ApplicationContext还通过多个其它接口扩展BeanFactory的功能：\n\nApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了ApplicationListener事件监听接口的Bean可以接收到容器事件，并对事件进行响应处理。在ApplicationContext抽象实现类AbstractApplicationContext中存在一个ApplicationEventMulticaster，它负责保存所有的监听器，以便在容器产生上下文事件时通知这些事件监听者；\nMessageSource：为应用提供i18n国际化消息访问的功能；\nResourcePatternResolver：所有ApplicationContext实现类都实现了类似于PathMatchingResourcePatternResolver的功能，可以通过带前缀的ant风格的资源文件路径装载Spring配置文件；\nLifeCycle：提供start()、和stop()，主要用于控制异步处理过程。在具体使用时，该接口同时被ApplicationContext实现以及具体Bean实现，ApplicationContext会将start&#x2F;stop的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度等目的。\n\nConfigurableApplicationContext扩展于ApplicationContext，它新增了两个主要方法：refresh()、close()，使得ApplicationContext具有启动、刷新、关闭应用上下文的能力。在应用上下文关闭的情况下可以调用refresh()即可启动应用上下文，在已经启动的状态下调用refresh()则可清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利，但作为开发者并不需要过多关心它们。  \n初始化和BeanFactory初始化类似，如果配置文件放在类路径下，优先考虑使用ClassPathXmlApplicationContext实现；如果放在文件系统路径下，则优先考虑FileSystemXmlApplicationContext实现。也可以指定一组配置文件，Spring会完成自动整合\u0010。获取ApplicationContext实例后，就可以像BeanFactory一样调用getBean(beaName)返回bean了。而ApplicationContext的初始化和BeanFactory有一个很大区别：后者在初始化容器时，并未初始化所有的Bean，直到第一次访问某个Bean时才实例化该目标Bean；而ApplicationContext则在初始化应用上下文时就实例化所有单实例的Bean。因此，ApplicationContext的初始化时间会比BeanFactory稍长。Spring支持基于类注解的配置方式，主要功能来自JavaConfig的子项目。一个标注了@Configuration注解的POJO即可提供Spring所需的Bean配置信息。而且Spring为基于注解类的配置专门提供了ApplicationContext实现类：AnnotationConfigApplicationContext，可以直接调用方法实例化Bean，启动容器并装配Bean。\nWebApplicationContextWebApplicationContext是专门为Web应用准备的，它允许从相对于Web根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext中可以获得ServletContext的引用，整个Web应用上下文对象将作为属性放置到ServletContext中，以便Web应用环境可以访问Spring应用上下文。Spring专门为此提供了一个工具类WebApplicationContextUtils，通过该类的getWebApplicationContext(ServletContext sc)，可以从ServletContext中获取WebApplicationContext实例。在非Web应用的环境下，Bean只有singleton、prototype两种作用域。WebApplicationContext为Bean添加了三个新的作用域：request、session、global session。ConfigurableWebApplicationContext扩展了WebApplicationContext，它允许通过配置的方式实例化WebApplicationContext，同时定义了两个重要方法：\n\nsetServletContext(ServletContext servletContext)：为Spring设置Web应用上下文，以便二者整合；\nsetConfigLocations(String[] configLocations)：设置Spring配置文件地址，一般是相对于Web根目录的地址，如&#x2F;WEB-INF&#x2F;xxx-dao.xml、&#x2F;WEB-INF&#x2F;xxx-service.xml。用户也可以使用带资源类型前缀的地址，如classpath:com&#x2F;baidu&#x2F;beans.xml等。\n\n初始化WebApplicationContext的初始化方式和BeanFactory、ApplicationContext有所区别，因为需要ServletContext实例。即必须在拥有Web容器的前提下才能完成启动工作，可以在web.xml中配置自启动的Servlet或定义Web容器监听器(ServletContextListener)，二者均可完成启动Spring Web应用上下文的工作。Spring为二者均提供了支持：\n\norg.springframework.web.context.ContextLoaderServlet\norg.springframework.web.context.ContextLoaderListener\n\n二者内部都实现了启动WebApplicationContext实例的逻辑，只需根据Web容器的具体情况选择其一并在web.xml中完成配置即可。\nWebApplicationContext同样需要日志功能，可以将Log4J配置文件放置在类路径&#x2F;WEB-INF&#x2F;classes下以便启动Log4J引擎。或在web.xml文件指定自定义的配置文件位置。\nAOPAOP是一种编程思想。日志、安全、事务管理、缓存等，在软件系统中都是非常重要的功能，但它们与软件本身所关注的“功能”即业务逻辑，从概念上讲（应该）是分离的，然而它们散布嵌入在业务逻辑之中，需要在业务逻辑功能执行的过程中被动地触发。这些功能通常被称为横切关注点（cross-cutting concern）。把这些横切关注点与业务逻辑相分离就是面向切面编程（AOP，Aspect Oriented Programming），实现横切关注点与它们所影响的对象之间的解耦。重用通用功能的方案一般为继承或委托，而切面是另一种实现该目标的方案。在使用面向切面编程时，仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以合何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。有两个好处：\n\n每个关注点都集中在一个地方，而不是分散在多处代码中；\n服务模块更加简洁，因为它们都只包含主要关注点（核心功能）的代码，而次要关注的代码被转移到切面中。\n\n相关术语增强 advice切面的工作被称为增强。增强定义了切面是什么以及何时使用（what and when）。除了描述切面要完成的工作，增强还解决了何时执行这个工作的问题：它应该应用在某个方法被调用之前、之后还是只在方法抛出异常时，等。Spring切面支持5种类型的增强：\n\n前置增强（Before）：在目标方法被调用之前调用增强功能；\n后置增强（After）：在目标方法完成之后调用增强，此时不会关心方法的输出是什么；\n环绕增强（Around）：在被增强方法调用前后都执行自定义的行为；\n返回增强（After-returning）：在目标方法成功执行之后调用增强；\n异常增强（After-throwing）：在目标方法抛出异常之后调用增强。\n\n连接点 join point应用增强的时机，被称为连接点。连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、甚至修改一个字段时，切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。\n切点 pointcut增强定义了切面的“what”和“when”，切点定义了切面的“where”，切点的定义会匹配增强所要织入的一个或多个连接点。通常使用明确的类和方法名，或利用正则表达式定义所匹配的类和方法名来指定这些切点。\n切面 aspect切面是增强和切点的结合。增强和切点共同定义了切面的全部内容——它是什么，在何时何处完成其功能。 \n引入 introduction引入允许向现有的类添加新方法或属性，从而在无需修改现有类的情况下，让这些类具有新的行为和状态。是一种特殊的增强。\n织入 weaving把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入：\n\n编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。\n类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。\n运行期：切面在应用运行的某个时刻被织入。一般，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。\n\nSpring中的AOPAOP框架在连接点模型上有强弱之分，比如有些允许在字段修饰符级别应用增强，有些只支持与方法调用相关的连接点。此外，框架织入切面的方式和时机也有所不同。但无论如何，创建切点来定义切面所织入的连接点是AOP框架的基本功能。\nSpring提供4种类型的AOP支持：\n\n基于代理的经典Spring AOP（现在来看笨重且复杂）；\n纯POJO切面（需要xml配置）；\n@AspectJ注解驱动的切面（本质上依然是基于代理的AOP）；\n注入式AspectJ切面（基本的方法调用级别切面满足不了需求时）。\n\n前三种都是Spring AOP实现的变体。Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。\n运行时增强对象通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理类封装了目标类，拦截被增强方法的调用，再把调用转发给真正的目标bean。即代理类处理方法的调用，执行额外的切面逻辑，并调用目标方法。Spring运行时才创建代理对象。\n切点类型Spring提供6种类型的切点：\n\n静态方法切点：org.springframework.aop.support.StaticMethodMatcherPointcut是静态方法切点的抽象基类，默认情况下它可以匹配所有的类。包含两个主要的子类：NameMatchMethodPointcut &amp; AbstractRegexpMethodPointcut，前者提供简单的字符串匹配方法签名，后者使用正则表达式匹配方法签名；\n动态方法切点：org.springframework.aop.support.DynamicMethodMatcherPointcut是动态方法切点的抽象基类，默认情况下匹配所有的类；\n注解切点：org.springframework.aop.support.annotation.AnnotationMatchingPointcut的实现类表示注解切点，支持在Bean中直接通过java5.0注解标签定义的切点；\n表达式切点：org.springframework.aop.support.ExpressionPointcut接口主要是为了支持AspectJ切点表达式语法而定义的接口；\n流程切点：org.springframework.aop.support.ControlFlowPointcut实现类表示控制流程切点。ControlFlowPointcut是一类特殊的切点，它根据程序执行堆栈的信息查看目标方法\n\n","categories":["java"],"tags":["java"]},{"title":"algs","url":"/2018/03/29/algs/","content":"sort初级排序几种基础排序算法，时间复杂度为O(n^2)。\n冒泡排序冒泡排序是最简单基础的排序算法：\n\n比较相邻的元素。如果第一个比第二个大，就交换他们两个；\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；\n针对所有的元素重复以上的步骤，除了最后一个；\n持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较；其时间复杂度为O(n^2)，在原地交换，不需要额外的空间开销。是一种稳定排序。C++实现：void BubbleSort(int *a, int length)\n&#123;\n    for (int i = 0; i &lt; length; ++i)\n        for (int j = 0; j &lt; length - 1 - i; ++j)\n            if (a[j] > a[j + 1])\n                swap(a[j], a[j + 1]);\n&#125;\n\n插入排序来源于整理扑克牌的排序算法：将每一个元素插入到已经有序的序列中合适的位置，即前向交换使之到达正确位置。\nvoid InsertionSort(int *a, int length)\n&#123;\n    for (int i = 1; i &lt; length; ++i)\n        for (int j = i; j > 0; --j)\n            if (a[j] > a[j - 1])\n                swap(a[j], a[j - 1]);\n&#125;\n\n选择排序每次（第 i 次：0..N-1）都选择出剩余元素的最小值，将其置换到 i 的位置上去。\nvoid SelectionSort(int *a, int length)\n&#123;\n    for (int i = 0; i &lt; length; ++i) &#123;\n        int min = i;  // 最小元素的索引\n        for (int j = i + 1; j &lt; length; ++j)\n            if (a[j] > a[min])\n                min = j;\n            swap(a[i], a[min]);\n    &#125;\n&#125;\n\n希尔排序思想：使数组中任意间隔为 h 的元素都是有序的。类似于插入排序，只不过插入排序是交换相邻（间隔为1）元素，而希尔排序是交换间隔为 h 的元素。\n\nvoid ShellSort(int *a, int length)\n&#123;\n    int h = 1;\n    while (h &lt; length / 3)\n        h = 3 * h;\n    while (h >= 1) &#123;\n        // 将数组变为h有序\n        for (int i = h; i &lt; length; ++) &#123;\n            // 将a[i]插入到a[i-h]，a[i-2*h]，a[i-3h]...中\n            for (int j = i; j >= h &amp;&amp; a[j] &lt; a[j - h]; j -= h)\n                swap(a[j], a[j - h]);\n        &#125;\n        h = h / 3;\n    &#125;\n&#125;\n\n快排采用分治策略，（两路快排）将一个序列分成两个子序列，独立排序。与归并排序互补：归并排序将序列分成两个部分分别排序，并将有序的子序列归并以将整个序列排序，递归调用发生在处理整个序列之前；而快排则是，当两个子序列都有序时，整个序列也就自然有序了，递归调用发生在处理整个序列之后。\nvoid sort(Comparable[] a, int lo, int hi) &#123;\n    if (lo >= hi) return;\n\n    int j = partition(a, lo, hi);\n    sort(a, lo, j - 1);\n    sort(a, j + 1, hi);\n&#125;\n\nint partition(Comparable[] a, int lo, int hi) &#123;\n    int i = lo, j = hi + 1;  // 左右扫描指针\n    Comparable v = a[lo];  // 切分元素，主元\n    while (true) &#123;\n        // 扫描左右，检查扫描是否结束并交换元素\n        while (less(a[++i], v)) if (i == hi) break;\n        while (less(v, a[--j])) if (j == lo) break;\n        if (i >= j) break;\n        exch(a, i, j);\n    &#125;\n    exch(a, lo, j);  // 将v=a[j]放入正确位置\n    return j;  // a[lo..j-1]&lt;=a[j]&lt;=a[j+1..hi]达成\n&#125;\n优点\n\n实现简单，适用于各种不同输入数据；\n原地排序，只需要 O(1) 的辅助空间；\n\n缺点实现中要避免低劣性能的影响：划分是否相对均衡，即主元的选取；\n优化\n\n小规模子序列（7 ~ 15）改用插入排序；\n三取样切分：使用子序列一小部分元素的中位数作主元，取样大小为 3 时效果较好；\n\n堆排两步操作：堆化、下沉（或上浮）。\npublic static void sort(Comparable[] pq) &#123;\n    int n = pq.length;\n    // 构造堆\n    // 从最下层一个非叶节点开始作为根节点，构造子堆\n    // 这样能够保证对该节点的父节点堆化时，下沉动作不会扩散到它的子节点\n    for (int k = n / 2; k >= 1; k--) &#123;\n        sink(pq, k, n);\n        show(pq);\n    &#125;\n\n    // 堆排序过程\n    // 依次下沉当前最大元素，保持堆\n    while (n > 1) &#123;\n        exch(pq, 1, n--);\n        sink(pq, 1, n);\n    &#125;\n&#125;\n\n// 下沉，使得以 k 位置为根节点，构造一个堆\nprivate static void sink(Comparable[] pq, int k, int n) &#123;\n    while (2 * k &lt;= n) &#123;\n        int j = 2 * k;\n        if (j &lt; n &amp;&amp; less(pq, j, j + 1)) j++;\n        if (less(pq, j, k)) break;\n        exch(pq, k, j);\n        k = j;\n    &#125;\n&#125;\n\n归并排序将已有序的子序列合并，得到完全有序的序列的过程，i.e. 先使子序列有序，再使序列段间有序。\n\n时间复杂度： O(NlogN) ;\n空间复杂度：辅助空间：O(N);\n稳定排序，常使用递归实现。\n\nvoid merge(Comparable[] a, int lo, int mid, int hi) &#123;\n    int i = lo, j = mid + 1;\n\n    for (int k = lo; k &lt;= hi; k++)\n        aux[k] = a[k];\n\n    for (int k = lo; k &lt;= hi; k++) &#123;\n        if (i > mid)\n            a[k] = aux[j++];\n        else if (j > hi)\n            a[k] = aux[i++];\n        else if (less(aux[j], aux[i]))\n            a[k] = aux[j++];\n        else\n            a[k] = aux[i++];\n    &#125;\n&#125;\n\n// 自顶向下递归：\nvoid sort(Comparable[] a, int lo, int hi) &#123;\n    if (lo >= hi) return;\n    int mid = lo + (hi - lo) / 2;\n    sort(a, lo, mid);\n    sort(a, mid + 1, hi);\n    merge(a, lo, mid, hi);\n&#125;\n\n// 自底向上循环：\nvoid sort(Comparable[] a) &#123;\n    int N = a.length;\n    aux = new Comparable[N];\n    for (int sz = 1; sz &lt; N; sz = sz + sz) &#123;\n        for (int lo = 0; lo &lt; N - sz; lo += sz + sz)\n            merge(a, lo, lo + sz - 1, Math.min(lo + +sz + sz - 1, N - 1));\n    &#125;\n&#125;\n\n优化\n\n小规模子序列（7 ~ 15）改用插入排序&#x2F;选择排序；\n测试子序列是否已经有序：a[mid] &lt;&#x3D; a[mid]，则这两个子序列无需调用接下来的 merge() ，直接拷贝即可；\n不将元素复制到辅助空间：将辅助空间也带入 sort()、merge() 方法，每次递归变换二者的位置，从而无需反复拷贝子序列到辅助空间，而是临时将辅助空间用于排序和归并。\n\n线性时间排序比较排序的时间复杂度下限 O(n*logn) 是确定的。在这篇博客里有各种比较排序的对比。还有一类非比较排序算法，适用于一些特定情况。这种特定情况一般是对集合的范围界定：当集合满足一定条件，可以不使用比较的方式实现排序，从而获得优于比较排序下限的时间复杂度：线性时间复杂度内完成排序。常见的线性时间复杂度排序算法有：\n\n计数排序（Counting Sort）\n基数排序（Radix Sort）\n桶排序（Bucket Sort）\n\n计数排序限制条件：取值范围在 [m, n] 之间的整数，wiki解释集合分布在 [0, 100] 时最适合使用计数排序。原理：对每一个输入元素x，确定出小于x的元素个数，有了这一信息，就可以把x直接放在它在最终输出数组的位置上，例如，如果有17个元素小于x，则x就是属于第18个输出位置。当几个元素相同是，方案要略作修改。时间复杂度：O(n)。空间复杂度：O(n)。这是一种稳定排序。伪代码：\nCOUNTING-SORT(A;B; k)\nlet C[0..k] be a new array\nfor i = 0 to k\n\tC[i] = 0;\nfor j = 1 to A.length\n\tC[A[j]] = C[A[j]] + 1\n// C[i] now contains the number of elements equal to i .\nfor i = 1 to k\n\tC[i] = C[i] + C[i-1]\n// C[i] now contains the number of elements less than or equal to i .\n for j = A.length downto 1\n \tB[C[A[j]]] = A[j]\n \tC[A[j]] = C[A[j]] - 1\n\n基数排序原理：以十进制数组n为例，k&#x3D;10，最大数字的位数是d。把元素从个位排好序，然后再从十位排好序，，，，一直到元素中最大数的最高位排好序，那么整个元素就排好序了。时间复杂度：O(d(n+r))。空间复杂度：O(n+r)。这是一种稳定排序。伪代码：\nRADIX-SORT(A, d)\nfor  i = 1 to d\n\tuse a stable sort  to sort array A on digit i.\n\n桶排序假定数据服从均匀分布，均匀独立分布在[0， 1)区间。假设有m个桶，即将区间划分为m个大小相同的子区间。将n个元素分别存放到相应的桶中，再对各个桶进行排序，如插入排序。最后遍历每个桶，按照次序列出所有元素即可。时间复杂度：平均为O(n)。空间复杂度：O(n)。伪代码：\nBUCKET-SORT(A)\nn = A.length\nlet B[0.. n-1] be a new array\nfor i = 0 to n-1\n\tmake B[i] an empty list\nfor i = 1 to n\n\tinsert A[i] into B[⌊A[i]⌋]\nfor i = 0 to n-1\n\tsort list B[i] with insertion sort\nconcatenate the lists B[0], B[i],...B[n-1] together in order.\n\n\ndp与分治相似：都是通过组合子问题的解来求解原问题。而，分治将问题划分为互不相交的子问题，递归地（思路上）求解子问题，再将它们的解组合起来，得到原问题的解；与之不同地，动态规划应用于子问题重叠的情况，i.e. 不同的子问题具有公共的子子问题（递归求解子问题，将其划分为更小的子子问题）。这种情况下，分治算法将做许多不必要的工作——反复求解公共子子问题；而动态规划对每个子问题只求解一次，将结果保存在一个表格（programming 的由来）中，从而避免重复计算子子问题，i.e. 剪枝。典型的时空权衡（time-memory trade-off）问题：以空间换时间。通常用来求解 最优化问题（Optimization Problem），即在很多可行解中寻找 （一个&#x2F;多个）最优解 的过程。\n设计步骤\n刻画一个最优解的结构特征；\n递归地定义最优解的值；\n计算最优解的值——同常采用自底向上的方法；\n利用计算的信息构造一个最优解。\n\n两种实现方法\n\n带备忘录的自顶向下方法（top-down with memoization）。用数组&#x2F;散列表保存递归过程中子问题的解，当要求解一个子问题时，先检查是否已保存过此解，无则计算之；\n自底向上方法（bottom-up method）。需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的”子问题的解。因而可以将子问题按规模排序，从小到大进行求解，当求解某个子问题时，它所依赖的更小的子问题已经求解完毕，结果已经保存。这样可以保证每个子问题只求解一次，并且求解它时，它所有的前提子问题都已完成。\n\n原理和适用条件适用场景：\n\n最优子结构；\n子问题重叠；\n\n贪心算法（greedy algorithm）每一步都做出当前看起来最佳的选择。即，总是做出 局部最优的选择。理论上，适用于贪心算法的问题，同样能用动态规划方法解决。\n设计步骤首先是基于动态规划的设计方式：\n\n确定问题的最优子结构；\n设计一个递归算法；\n证明如果做出一个贪心的选择，则只剩下一个子问题；并且，证明贪心选择总是安全的；\n设计一个递归算法实现贪心策略；\n将递归算法转换为迭代算法。\n\n更一般地，通过贪心选择改进最优子结构，使得选择后只剩下一个子问题：\n\n最优化问题转换为：做出一次选择后，只剩下一个子问题需要求解；\n证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的（没有因为这一次的选择而丢失客观的最优解）；\n证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，即得到了最优子结构。\n\n能否使用贪心的两个要素贪心选择性质（greedy-choice property）通过做出局部最优（贪心）选择来构造全局最优解。与动态规划不同，贪心算法进行选择时可能依赖之前做出的选择，但不依赖任何将来的选择或子问题的解。\n最优子结构同动态规划。\n与动态规划的差别考虑 0-1 背包问题和分数背包问题，显然，后者能够使用贪心算法解决，而 0-1 背包问题则只能使用动态规划。\nKMP算法经典的字符串匹配算法。但实现起来并不复杂。首先一个概念是：\n部分匹配表 The Partial Match Table参考这篇博文：The Knuth-Morris-Pratt Algorithm当弄清楚了什么是部分匹配表之后，接下来就是怎么使用它，在匹配失败的时候进行适当的跳跃。使用参考这部分内容从头到尾彻底理解KMP\n最后给出一个实现\n跳表算法 &amp; 数据结构$$程序 &#x3D; 算法 + 数据结构$$TAOCP中，Donald并没有直接给出“算法”的定义，而是在用了几页的篇幅追溯了一番“Algorithms”这个词的起源以尝试让读者理解它的含义之后，用了欧几里得求解两个正整数最大公因子的例子做阐述：其中最重要的是→，赋值&#x2F;代替。他的学生、红皮算法书的作者-Robert Sedgewick沿用这个例子并尝试给出了一个定义：The term algorithm is used in computer science to describe a finite, deterministic, and effective problem-solving method suitable for implementation as a computer program.同时指出了二者之间的关系：大多数算法需要适当地组织数据，为了组织数据就产生了数据结构。一脉相承的观点是，数据结构是算法的副产品&#x2F;结果（data structures exist as the byproducts or end products of algorithms）。\n\n  数据结构的作用\n\n数据结构的作用前面说算法需要组织数据，所谓组织，其实就是操作（增、删、改、查）。有关数据结构和算法的课程对中所涉及到的数据结构：数组、链表；以及以前面两者为基础的高级数据结构：堆、树、图；延展开到特定领域&#x2F;方向上优化的数据结构：各种队列，红黑树，B、B+树，拓扑图等等。所有的数据结构的目的都是在特定场景下，优化数据的操作效率。可以用算法书给的demo跑一遍十几条排序算法的效率，便能直观感受到，即使在现在这样高性能的计算机面前，$n^2$ → $n\\log(n)$所带来巨大效率的提升；而在特定场景下，采用位图、$O(n)$复杂度的排序算法所能带来的更可观的空间、时间上的节省。绝大多数场景下，我们期待的数据结构是：在保持“有序”的前提下，满足高效的增、删、查操作。其中“有序”是一个相对的概念，堆、单端&#x2F;双端队列、查找树、拓扑图等，都满足以我们所期待的方式的有序性、或者我们所关心的那部分数据的有序性。\n\n\n哈希、红黑树、跳表这里关注K-V型数据结构。\n合适的数据结构关注以下速查表数据。其中，常用的key-value数据结构有三种：Hash表：插入、查找最快，为$O(1)$；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。红黑树：插入、查找为$\\log(n)$，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。SkipList：插入、查找为$\\log(n)$，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。\n\n首先，如果能确定某些数据是静态的，以ACA为例，我们的文案数据目前就可以看成是静态的：可能有描述上的调整，但频次很低，并且数据量不大。这部分数据如果采用直接加载到内存或是中间缓存的话，结构化为HashMap是不错的选择；\n如前所述，大部分数据操作场景是需要增删改操作的，而非仅仅只有读操作。这里不再讨论堆、队列等使用场景，专注通常情况下的数据的存取操作，此时需要兼顾读取、和操作后恢复有序的效率，此时Hash表不再是好的选择：迭代、修改操作的时间复杂度比较高，\b而红黑树则能很好地满足功能需求；\n\n为什么还要有跳表作为平衡树的一种替代实现，跳表主要拥有以下优势：\n\n更简单的实现红黑树增删改元素需要进行旋转、变色，实现起来比较复杂，需要考虑的细节也比较多，到了并发场景下更难以写出可用且高效的红黑树实现；而跳表实现原理相当简单，就是升级版的链表，把链表的某一些元素随机抽出来再组成一个链表，作为一级索引，在该索引集中再次进行抽取，再做一级索引，依次实现多级链表索引，就组成了一个跳表。\n\n为了解决在高并发下，红黑树的锁实现导致的可能的死锁和并发度降低问题。首先这句话意味着，在单线程、低线程数场景下，红黑树可能是更好的选择：以jdk11为例，ConcurrentHashMap存取速度是ConcurrentSkipListMap的4倍左右，而随着并发的线程数增多，后者的性能优势会逐渐体现出来，它的存取时间复杂度几乎和线程数无关，且无锁开销。\n\n\n特点上述可见跳表也是一种典型的“空间换时间”的数据结构。其底层采用二维链表，而非通常采用的数组实现。基本特点：\n\n由很多层结构组成；\n每一层都是一个有序的链表；\n最底层(Level 1)的链表包含所有元素；\n如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现；\n每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。\n\n跳表实现构造考虑一个链表：从该有序表中搜索元素&lt; 23, 43, 59&gt;，需要比较的次数分别为&lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 &#x3D; 12 次。有没有优化的算法？链表是有序的，但不能使用二分查找。类似二叉搜索树，我们把一些节点提取出来，作为索引。得到如下结构：这里把&lt; 14, 34, 50, 72 &gt;提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构：\n\n  节点类\n\nstatic final class Node&lt;K,V> &#123;\n    final K key; // currently, never detached\n    V val;\n    Node&lt;K,V> next;\n    Node(K key, V value, Node&lt;K,V> next) &#123;\n        this.key = key;\n        this.val = value;\n        this.next = next;\n    &#125;\n&#125;\n\nredis 使用C实现，详见：https://github.com/antirez/redis/blob/unstable/src/server.h\n\n\n搜索元素查找元素 117：\n\n比较21，比 21 大，往后面找\n比较37，比 37大，比链表最大值小，从 37 的下面一层开始找\n比较71，比 71 大，比链表最大值小，从 71 的下面一层开始找\n比较85，比 85 大，从后面找\n比较117，等于 117， 找到了节点。\n\n\n  搜索\n\nprivate Node&lt;K,V> findNode(Object key) &#123;\n    if (key == null)\n        throw new NullPointerException(); // don't postpone errors\n    Comparator&lt;? super K> cmp = comparator;\n    Node&lt;K,V> b;\n    outer: while ((b = findPredecessor(key, cmp)) != null) &#123;\n        for (;;) &#123;\n            Node&lt;K,V> n; K k; V v; int c;\n            if ((n = b.next) == null)\n                break outer;               // empty\n            else if ((k = n.key) == null)\n                break;                     // b is deleted\n            else if ((v = n.val) == null)\n                unlinkNode(b, n);          // n is deleted\n            else if ((c = cpr(cmp, key, k)) > 0)\n                b = n;\n            else if (c == 0)\n                return n;\n            else\n                break outer;\n        &#125;\n    &#125;\n    return null;\n&#125;\n\n\n新增元素先确定该元素要占据的层数 K（丢硬币，随机），然后在 Level 1 … Level K 各个层的链表都插入元素：插入 119， K &#x3D; 2其中，然随机变量 K 满足参数为 $p &#x3D; 1&#x2F;2$ 的几何分布，期望值 $E[K] &#x3D; 1&#x2F;p &#x3D; 2$。即各个元素的层数，期望值是 2 层。\n\n  插入\n\nprivate V doPut(K key, V value, boolean onlyIfAbsent) &#123;\n    if (key == null)\n        throw new NullPointerException();\n    Comparator&lt;? super K> cmp = comparator;\n    for (;;) &#123;\n        Index&lt;K,V> h; Node&lt;K,V> b;\n        VarHandle.acquireFence();\n        int levels = 0;                    // number of levels descended\n        if ((h = head) == null) &#123;          // try to initialize\n            Node&lt;K,V> base = new Node&lt;K,V>(null, null, null);\n            h = new Index&lt;K,V>(base, null, null);\n            b = (HEAD.compareAndSet(this, null, h)) ? base : null;\n        &#125;\n        else &#123;\n            for (Index&lt;K,V> q = h, r, d;;) &#123; // count while descending\n                while ((r = q.right) != null) &#123;\n                    Node&lt;K,V> p; K k;\n                    if ((p = r.node) == null || (k = p.key) == null ||\n                        p.val == null)\n                        RIGHT.compareAndSet(q, r, r.right);\n                    else if (cpr(cmp, key, k) > 0)\n                        q = r;\n                    else\n                        break;\n                &#125;\n                if ((d = q.down) != null) &#123;\n                    ++levels;\n                    q = d;\n                &#125;\n                else &#123;\n                    b = q.node;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        if (b != null) &#123;\n            Node&lt;K,V> z = null;              // new node, if inserted\n            for (;;) &#123;                       // find insertion point\n                Node&lt;K,V> n, p; K k; V v; int c;\n                if ((n = b.next) == null) &#123;\n                    if (b.key == null)       // if empty, type check key now\n                        cpr(cmp, key, key);\n                    c = -1;\n                &#125;\n                else if ((k = n.key) == null)\n                    break;                   // can't append; restart\n                else if ((v = n.val) == null) &#123;\n                    unlinkNode(b, n);\n                    c = 1;\n                &#125;\n                else if ((c = cpr(cmp, key, k)) > 0)\n                    b = n;\n                else if (c == 0 &amp;&amp;\n                         (onlyIfAbsent || VAL.compareAndSet(n, v, value)))\n                    return v;\n\n                if (c &lt; 0 &amp;&amp;\n                    NEXT.compareAndSet(b, n,\n                                       p = new Node&lt;K,V>(key, value, n))) &#123;\n                    z = p;\n                    break;\n                &#125;\n            &#125;\n\n            if (z != null) &#123;\n                int lr = ThreadLocalRandom.nextSecondarySeed();\n                if ((lr &amp; 0x3) == 0) &#123;       // add indices with 1/4 prob\n                    int hr = ThreadLocalRandom.nextSecondarySeed();\n                    long rnd = ((long)hr &lt;&lt; 32) | ((long)lr &amp; 0xffffffffL);\n                    int skips = levels;      // levels to descend before add\n                    Index&lt;K,V> x = null;\n                    for (;;) &#123;               // create at most 62 indices\n                        x = new Index&lt;K,V>(z, x, null);\n                        if (rnd >= 0L || --skips &lt; 0)\n                            break;\n                        else\n                            rnd &lt;&lt;= 1;\n                    &#125;\n                    if (addIndices(h, skips, x, cmp) &amp;&amp; skips &lt; 0 &amp;&amp;\n                        head == h) &#123;         // try to add new level\n                        Index&lt;K,V> hx = new Index&lt;K,V>(z, x, null);\n                        Index&lt;K,V> nh = new Index&lt;K,V>(h.node, h, hx);\n                        HEAD.compareAndSet(this, h, nh);\n                    &#125;\n                    if (z.val == null)       // deleted while adding indices\n                        findPredecessor(key, cmp); // clean\n                &#125;\n                addCount(1L);\n                return null;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n删除元素采用标准的链表删除即可。删除 71\n\n  删除\n\nfinal V doRemove(Object key, Object value) &#123;\n    if (key == null)\n        throw new NullPointerException();\n    Comparator&lt;? super K> cmp = comparator;\n    V result = null;\n    Node&lt;K,V> b;\n    outer: while ((b = findPredecessor(key, cmp)) != null &amp;&amp;\n                  result == null) &#123;\n        for (;;) &#123;\n            Node&lt;K,V> n; K k; V v; int c;\n            if ((n = b.next) == null)\n                break outer;\n            else if ((k = n.key) == null)\n                break;\n            else if ((v = n.val) == null)\n                unlinkNode(b, n);\n            else if ((c = cpr(cmp, key, k)) > 0)\n                b = n;\n            else if (c &lt; 0)\n                break outer;\n            else if (value != null &amp;&amp; !value.equals(v))\n                break outer;\n            else if (VAL.compareAndSet(n, v, null)) &#123;\n                result = v;\n                unlinkNode(b, n);\n                break; // loop to clean up\n            &#125;\n        &#125;\n    &#125;\n    if (result != null) &#123;\n        tryReduceLevel();\n        addCount(-1L);\n    &#125;\n    return result;\n&#125;\n\n\n适用场景\njdk从1.6开始引入了两个跳表相关的实现类：ConcurrentSkipListMap、ConcurrentSkipListSet（基于ConcurrentSkipListMap），在jdk中主要是用于高并发场景下代替红黑树的实现，不过从jdk8开始，线程安全的Hash表：ConcurrentHashMap采用了CAS、取消分段锁改用大数组、哈希碰撞超过阈值时树化（红黑树）等手段进一步提升了线程安全Hash表相关实现，性能上也有了很大提升。\n\nredis：redis的有序集合zset是采用跳表实现的。分析一下zset所支持的操作就不难理解为啥采用跳表而非红黑树了：\n\n\n\n插入元素\n删除元素\n查找元素\n有序输出所有元素\n查找区间内所有元素除了易于实现这个因素外。zset所支持的操作中，前4项红黑树都可以完成，且时间复杂度与跳表一致。但是，最后一项，红黑树的效率就没有跳表高了。在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效。而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。\n\n\nLevelDB：Google 开源的 key&#x2F;value 存储引擎 LevelDB 以及 Facebook 基于 LevelDB 优化的 RocksDB 都是 LSM Tree 结构的数据库，内部的 MemTable 使用跳表实现。HBase MemStore 内部存储数据就使用的跳表。为什么呢？HBase 属于 LSM Tree 结构的数据库，LSM Tree 结构的数据库有个特点，实时写入的数据先写入到内存，内存达到阈值往磁盘 flush 的时候，会生成类似于 StoreFile 的有序文件，而跳表恰好就是天然有序的，所以在 flush 的时候效率很高，而且跳表查找、插入、删除性能都很高，这应该是 HBase MemStore 内部存储数据使用跳表的原因之一。HBase 使用的是 java.util.concurrent 下的 ConcurrentSkipListMap()。\n\nES：Lucene核心数据结构采用了跳表实现倒排表。使用FST保存词典，FST可以实现快速的Seek，这种结构在当查询可以表达成自动机时(PrefixQuery、FuzzyQuery、RegexpQuery等)效率很高。(可以理解成自动机取交集)此种场景主要用在对Query进行rewrite的时候。FST可以表达出Term倒排表所在的文件偏移。倒排表使用SkipList结构。从上面的讨论可知，求倒排表的交集、并集、差集需要各种SeekTo(docId)，SkipList能对Seek进行加速。\n\n\nref：https://stackoverflow.com/questions/256511/skip-list-vs-binary-search-treehttps://en.wikipedia.org/wiki/Skip_listhttps://blog.csdn.net/sunxianghuang/article/details/52221913https://www.iteye.com/blog/imtinx-1291165《algorithms》《the art of computer programming》\n","categories":["algs"],"tags":["algs"]},{"title":"about","url":"/about/index.html","content":"A computer programmer based in hangzhou, China.@alibaba.Ex@kwai.Ex@baidu ABC.\ngithub:https://github.com/lazy-snail\n","categories":[],"tags":[]}]