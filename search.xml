<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>database</title>
      <link href="//cs/db/"/>
      <url>//cs/db/</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h2><p>多数博客会用“书的目录”作解释，这是个很好的例子，为小白科普CS常识的时候可以用。<br>作为开发可以从另一个角度理解：假设我们有100w行单列的数据，比如人名，如何提高“找到特定名字”的效率呢？简单直接地，我们想到的是树结构来存储，比如最熟悉的BST，它的查找效率非常高，lg(n)级别的查询次数，百万数据的也只需要20次左右，但是考虑到数据是持久化到存储介质的，和内存、CPU存在巨大的执行速度的差异，20次依然太多了。继续优化的方向并没有转变，专门为数据库而设计的各种B-tree应运而生，简单理解就是，从原来的二分，所需数据在左侧或者右侧，改为比如，按首字母序，分为26块，所需数据肯定在26中的某一块，这样一次查找就可以把范围缩小到数据量的1&#x2F;26。<br>其他诸如平衡性、B树到B+树、聚簇&#x2F;非聚簇、聚集&#x2F;非聚集（注意和前一组不同）等概念，也都是在此基础上，结合软硬件特性所提出来的“优化手段”。（这里未讨论hash索引、位图索引、全文索引等特殊场景下的特殊方案。）</p><h2 id="为什么要有索引"><a href="#为什么要有索引" class="headerlink" title="为什么要有索引"></a>为什么要有索引</h2><p><em>上面这段话好像没有说明白为啥要有索引，我直接对100w数据排序到硬盘不就行了？</em><br>直接排序在单列数据当然是可行的，且操作效率也都很高。问题是数据库（问这个问题的应该回去重学数据库）表有很多字段，如果表只有一个索引，自然可以这样做。如果想添加两个&#x2F;多个索引，又不能同时按照两种方式对数据进行排序，比如一个关于姓名的索引和一个电话号码索引，这种情况就无法排序。将索引从数据行中整体分离出来，就可以创建多个索引，并且不需要对原始数据排序，但搜索过程即先在索引中找到对应值，然后根据匹配的记录找到对应的数据行。此外，索引行数据通常比表里的数据行更短，插入&#x2F;删除值时，为保持排序顺序，来回移动较短的索引值，比来回移动较长的数据行更加容易。</p><p><strong>IO 设备是计算机系统的瓶颈</strong><br><strong>索引是数据库中用来优化查询速度的最为重要的技术手段。</strong></p><h2 id="查询执行顺序"><a href="#查询执行顺序" class="headerlink" title="查询执行顺序"></a>查询执行顺序</h2><p>上述索引的作用中最关键的地方在于“优化查询速度”，那首先需要了解的是，一条sql语句，它的执行顺序是怎样的，才能更好地理解如何加速，以及背后的为什么能够加速。（比这个“首先”更首先需要了解的是，为什么要“优化”？无非一：数据量太大了；二：数据量太大了内存存不下而硬盘又太慢但又不得不放在硬盘上因为它很便宜。根因是数据量太大了，以至于不优化的话又回到了点个按钮可以喝杯咖啡再回来看结果的原始状态，用户就要爆炸，用户一爆炸老板就要爆炸，so…）<br>sql语句执行可能会划分为多个操作步骤，如下图，一个典型的sql查询，总共分为11步，其中每一步都会产生一张中间状态的虚表，作为下一步的输入，最后一步的虚表作为返回结果，其他步骤的虚表对用户透明。<br><img src="/cs/db/sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt="sql执行顺序" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class="lozad post-image"><br>其中，每一步的大致过程如下：</p><ol><li>FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1。</li><li>ON: 对虚表VT1进行ON筛选，只有那些符合&lt;join-condition&gt;的行才会被记录在虚表VT2中。</li><li>JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3，如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li><li>WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合&lt;where-condition&gt;的记录才会被插入到虚拟表VT4中。</li><li>GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5。</li><li>CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6。</li><li>HAVING： 对虚拟表VT6应用having过滤，只有符合&lt;having-condition&gt;的记录才会被 插入到虚拟表VT7中。</li><li>SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。</li><li>DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9。</li><li>ORDER BY: 将虚拟表VT9中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表VT10。</li><li>LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。</li></ol><p><strong>理解上述步骤之后，不难发现，为什么连接查询很可能导致低效（笛卡尔积：m * n），同时也可以看出，如果想要做一些查询优化工作，那么就要从 on、where 开始着手（join 中 on 等同于 where），对过滤条件中的字段加以优化（即挑选索引时的考虑因素）。</strong></p><h2 id="B-索引"><a href="#B-索引" class="headerlink" title="B+索引"></a>B+索引</h2><p>首先从大家默认的MySQL数据库默认的InnoDB存储引擎默认的用户创建索引类型说起：B+索引。它是目前关系型数据库系统中查找最为常用和最为有效的索引（大概是InnoDB团队自己说的）。<br>B+索引的发展和演变过程就是上面提到的那样，就是B-tree的一类变种。</p><p>这就不可避免地要继续延伸索引的发展史了，从BST开始，因缺乏社交活动而时间精力异常充沛的程序员（中的大神）们尝试了很多索引方案，<strong>BST</strong> 很快显露出其不仅仅在作为索引上的短板：最差性能是线性的；于是新的轮子–<strong>AVL</strong> 诞生了，它解决了平衡性的问题，把一棵树塞得满满的，新的问题又来了：维护平衡的代价太高，继续造轮子——<strong>RBT（红黑树）</strong>，这棵树已经非常优秀了，被广泛应用于STL、linux进程调度、IO多路复用（epoll）、nginx、java TreeMap等；看上去拿来作索引的底层数据结构也挺好，很快新的问题又来了：还是反复提到的，硬盘这个猪队友的速度实在太拖后腿，以至于这么优秀的轮子依然不能用，百万量级就需要20多次磁盘访问，这之间巨大的数据鸿沟是第一段内容提到的，具体就是至少为纳秒与毫秒的差距。具体可以看下这里：<a href="https://zhuanlan.zhihu.com/p/24726196">让 CPU 告诉你硬盘和网络到底有多慢</a></p><h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h3><p>B-tree就是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，每个内节点有多个分支)。<br><img src="/cs/db/B-tree.png" alt="B-tree" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/B-tree.png" class="lozad post-image"><br>B-tree已经具有了“有效降低磁盘查询次数”的特点，具有 <strong>高扇出性</strong> 的特点，一般高度在 2-4 层，意即查找某一键值的行记录最多只需要 2-4 次 I&#x2F;O。并且具有以下特点：</p><ol><li>定义任意非叶子结点最多只有M个儿子，且M&gt;2；</li><li>根结点的儿子数为[2, M]；</li><li>除根结点以外的非叶子结点的儿子数为[M&#x2F;2, M]；</li><li>每个结点存放至少M&#x2F;2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li><li>非叶子结点的关键字个数&#x3D;指向儿子的指针个数-1；</li><li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li><li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li><li>所有叶子结点位于同一层；</li></ol><p>它最终慢慢退出，或者说新的更合适的B+索引取而代之的原因是：<strong>B-tree在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题</strong>。在数据库中基于范围的查询是非常频繁的，而B-tree对于此类操作效率太低，因为它在节点中存储索引和数据，而数据域的存在导致B-tree一次能够读入内存的数据范围减少（相比于只把索引读入内存），从而在”减少磁盘IO“这一关键优化上依然存在很大空间。B+索引也就是B-tree的基础上，解决了这一问题：把数据域转移到叶子节点，所有非叶子节点只保存索引。</p><h3 id="B-tree-1"><a href="#B-tree-1" class="headerlink" title="B+tree"></a>B+tree</h3><p>在B-tree的基础上进行改造，具有不同于后者的特性：</p><ol><li>非叶子节点的子树指针与关键字个数相同；</li><li>非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复)；</li><li>为所有叶子节点增加一个链指针；</li><li>所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)；</li><li>非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层；</li><li>更适合于文件系统；<br><img src="/cs/db/B+tree.png" alt="B+tree" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/B+tree.png" class="lozad post-image"></li></ol><p>B+tree的优点，也就是它更适合作索引数据结构的原因：</p><ol><li>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</li><li>B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li><li>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</li></ol><p><strong>B+ 树索引并不能找到一个给定键值的具体行，而是查找该行所在的页，然后通过把页读入内存，再在内存中进行查找，最后得到要查找的数据行</strong>。且可以进一步分为聚集索引（Clustered Index）和辅助索引（Secondary Index），叶子节点存放着所有的数据，不同之处是，叶子节点存放的是否是一整行的信息。</p><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>按照每张表的主键构造一棵 B+ 树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点成为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同 B+ 树数据结构一样，每个数据页都通过一个双向链表来进行链接。由于实际的数据页只能按照一棵 B+ 树进行排序，因此每张表只能拥有一个聚集索引。查询优化器倾向于采用聚集索引，因为能够在叶子节点上直接找到数据，对于主键的排序查找和范围查找速度都非常快。聚集索引的存储并不是物理上连续的（维护成本将非常高），而是逻辑上连续的。</p><h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>叶子节点并不包含行记录的全部数据，除了包含键值以外，每个叶子节点的索引行中还包含了一个书签，用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来查找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后通过主键索引来找到一个完整的行记录。<br><em>例：如果在一棵高度为3的辅助索引树中查找数据，那么需要对这棵辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此共需要6次逻辑IO访问以得到最终的一个数据页。</em></p><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><p>基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（Hash Code），哈希码是一个比较小的值，并且不同键值的行计算出来的哈希码是不同的。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。<br>MySQL中，只有 Memory 引擎显式支持哈希索引，也是 Memory 引擎表默认索引类型，并且支持非唯一哈希索引。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中，所以哈希索引适合于精确查找；InnoDB 引擎支持的哈希索引是自适应的，会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p><h2 id="位图索引（BitMap-BitMap-index）"><a href="#位图索引（BitMap-BitMap-index）" class="headerlink" title="位图索引（BitMap BitMap index）"></a>位图索引（BitMap BitMap index）</h2><p>建立B+树索引的条件：高选择性的列(后续内容）。对于低选择性的列（这里应该描述成：只有固定几个值可选的列）如性别、婚否等，位图索引可能是个好的选择：<br><img src="/cs/db/%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95.jpg" alt="位图索引" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95.jpg" class="lozad post-image"><br><strong>适用场景</strong></p><ul><li>只有几个固定值的列；</li><li>不会频繁更新；<br><a href="https://www.cnblogs.com/LBSer/p/3322630.html">位图索引原理</a></li></ul><h2 id="全文索引（Full-Text-Search-Index"><a href="#全文索引（Full-Text-Search-Index" class="headerlink" title="全文索引（Full-Text Search Index)"></a>全文索引（Full-Text Search Index)</h2><p><strong>将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。</strong><br><em>MyISAM支持全文索引，InnoDB 从 1.2.x 版本开始支持全文索引。Memory、NDB、Archive等不支持全文索引。</em></p><details>  <summary>全文索引</summary>    <p>    </p><h3 id="倒排索引技术"><a href="#倒排索引技术" class="headerlink" title="倒排索引技术"></a>倒排索引技术</h3><p>全文索引通常使用倒排索引（Inverted Index）来实现：在辅助表（Auxiliary Table）中存储了单词与单词自身在一个&#x2F;多个文档中所在位置之间的映射，这通常利用关联数组实现，有两种表现形式：</p><ul><li>Inverted File Index，表现形式为 {单词，单词所在文档 ID}；</li><li>Full Inverted Index，表现形式为{单词，（单词所在文档 ID，在具体文档中的位置1，位置2…）}<br>示例如下：<br><img src="/cs/db/%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%E7%A4%BA%E4%BE%8B.PNG" alt="全文索引" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%E7%A4%BA%E4%BE%8B.PNG" class="lozad post-image"></li></ul><h3 id="InnoDB-全文索引"><a href="#InnoDB-全文索引" class="headerlink" title="InnoDB 全文索引"></a>InnoDB 全文索引</h3><p>采用 Full Inverted Index 的方式，将（DocumentId， Position1, Position2…）视为一个 ilist。故在全文索引的表中，有两个列：word字段、ilist字段，并且在word字段上设有索引。此外，由于 InnoDB 在ilist字段中存放了 Position 信息，故可以进行 Proximity Search（MyISAM不支持该特性）。<br>为提高全文检索的<strong>并行性能</strong>，InnoDB中共有6张 Auxiliary Table，目前每张表根据 word 的 Latin 编码进行分区。Auxiliary Table 是存放在磁盘上的持久表。此外，还有一个 FTS Index Cache（全文检索索引缓存），用来提高全文检索的行能。它是一个红黑树结构，根据（word，ilist）进行排序。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul><li>每张表只能有一个全文索引的索引；</li><li>由多列组合而成的全文索引的索引列必须使用相同的字符集和排序规则；</li><li>不支持没有单词界定符（delimiter）的语言，如中、日、韩等语言。</li></ul><h3 id="相关性："><a href="#相关性：" class="headerlink" title="相关性："></a>相关性：</h3><p>在 WHERE 中使用 MATCH 函数，查询返回的结果是根据相关性（Relevance）进行降序排序的，即相关性最高的结果放在第一位，0表示没有任何相关性。计算条件：</p><ul><li>word是否在文档中出现；</li><li>word在文档中出现的次数；</li><li>word在索引列中的数量；</li><li>多少个文档包含该word。</li></ul><h3 id="BOOLEAN"><a href="#BOOLEAN" class="headerlink" title="BOOLEAN"></a>BOOLEAN</h3><p>全文检索可以使用 IN BOOLEAN MODE 修饰符，此时查询字符串的前后字符会有特殊的含义，如：</p><ul><li>+ word：表示word必须存在；</li><li>- word：表示word必须被排除；</li><li>@distance：可选，表示字符字节间距最大值；</li><li>&gt;：表示出现该词时增加相关性；</li><li>&lt;：表示出现该词时降低相关性；</li><li>*：表示以该词开头的单词，如lik*，可以是lik、like、likes…</li><li>“：表示短语；</li><li>~：表示允许出现该单词，但相关性为负</li><li>etc.</li></ul><h3 id="Query-Expansion"><a href="#Query-Expansion" class="headerlink" title="Query Expansion"></a>Query Expansion</h3><p>全文索引的扩展查询，通常在查询的关键词太短，用户需要 implied knowledge（隐含知识）时进行。如，对于单词 database 的查询，用户可能希望查询的不仅仅是 database 的文档，可能还指那些包含 MySQL、Oracle、DB2、RDBMS 等的单词，这时可以使用 Query Expansion 模式来开启全文索引的 implied knowledge。<br>通过在查询短语中添加 WITH QUERY EXPANSION 或 IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION 可以开启 blind query expansion（automatic relevance feedback）。该查询分为两个阶段：</p><ol><li>根据索引的单词进行全文索引查询；</li><li>根据第一阶段产生的分词再进行一次全文检索的查询。</li></ol><p>由于 Query Expansion 的全文检索可能带来许多非相关性的查询，因此在使用时需要非常谨慎。<br>    </p><p></p></details><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>之所以InnoDB等数据库、数据库引擎选择B+而非其他类型的索引作为默认索引类型，除了上述B+索引的优势外，B+索引天然支持范围查找，这也是大部分关系型数据库的场景。</p><h2 id="哪些场景适合-x2F-需要索引"><a href="#哪些场景适合-x2F-需要索引" class="headerlink" title="哪些场景适合&#x2F;需要索引"></a>哪些场景适合&#x2F;需要索引</h2><p>承前，索引的出现是为了解决（大数据量）情况下的查询效率问题。</p><ol><li>根据前面说的sql执行顺序，可以确定第一条是否添加索引的判断依据：该列数据是不是出现在where后。</li><li>并非在所有的查询条件中出现的列都需要添加索引。对于添加 B+ 树索引的一般经验是，<strong>在访问表中很少一部分时考虑使用 B+ 树索引</strong>。<br>如果一个字段取值范围很广，重复出现较少，即属于高选择性字段，此时使用 B+ 树索引比较合适。否则，如性别、类型等字段，可取值范围很小（性别显然只能筛选 50%），即属于低选择性字段，此时不适合使用 B+ 树索引（适合使用前面说的位图索引）。事实上，在低选择性的字段上，即使建立了如 B 树索引，数据库可能也不会使用，而是仍然以全扫描（如果没有其他可用索引）的方式进行查找，因为此时使用这种索引可能反而降低性能。</li></ol><h2 id="哪些数据适合创建索引"><a href="#哪些数据适合创建索引" class="headerlink" title="哪些数据适合创建索引"></a>哪些数据适合创建索引</h2><ol><li><strong>为用于搜索、排序、分组的列创建索引，而对于用作输出显示的列不需要建立索引</strong>。<br>即，最佳索引候选列是出现在 WHERE、连接、ORDER BY、GROUP BY 子句中的列，而出现在 SELECT 关键字后面的输出列表里的列则不是很好的选择。<br><img src="/cs/db/%E7%B4%A2%E5%BC%95%E5%88%97%E9%80%89%E6%8B%A9.PNG" alt="索引列选择" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/%E7%B4%A2%E5%BC%95%E5%88%97%E9%80%89%E6%8B%A9.PNG" class="lozad post-image"></li><li><strong>认真考虑数据列基数</strong><br>列的基数（cardinality）是指它所容纳的所有非重复值的个数。相对于表的总行数来说，列的基数越大（也就是包含的唯一值越多，重复值越少，即上述的高选择性的列），使用索引的效果越好。</li><li><strong>选择合适的索引类型</strong><br>对于精确查找（使用 &#x3D;、&lt;&gt; 的查找），那么使用 MEMORY 的默认索引类型，即 hash 索引，可能效果更好：hash 的精确查找速度非常快，而对范围匹配表现欠佳；所以对于范围查找，使用 B+ 树类型的索引效果更好，InnoDB、MyISAM、MEMORY 等都支持 B 树索引。</li><li><strong>索引短小值</strong><br>应尽量选择较小的数据类型。如，当使用 MEDIUMINT 列便能够容纳所需要存储的数据时，就不要选用 BIGINT，如果值的长度都不会超过 25 个字符，那么就不要使用 CHAR(100)。短小的值可以提高索引的处理性能：<blockquote><p>短小的值操作更快，从而加快索引查找速度；<br>短小的值可以让索引更小，从而减少磁盘 I&#x2F;O；<br>对于短小的键值，键缓存里的索引块可以容纳更多的键值，也就可以在更少的磁盘 I&#x2F;O 下读取更多的索引块，从而提高找到键值的几率。</p></blockquote></li><li><strong>索引字符串值的前缀</strong><br>要对字符串列建立索引，应该尽可能指定前缀长度。如，对于一个 CHAR(200) 列，如果大多数值的前 10 个 或 20 个字符都是唯一的，那么就可以不用为整个列进行索引，而只为前 10 个或 20 个字符进行索引，这样可以节省大量的索引空间，而且能够加速查询；但只索引列的第一个字符恐怕不行，因为会导致索引无法获得大量的唯一值。</li><li><strong>不要建立过多的索引</strong><br>显然，索引的建立并非无代价的，要考虑对性能和存储的影响。过多的索引也会导致</li></ol><h3 id="辅助手段"><a href="#辅助手段" class="headerlink" title="辅助手段"></a>辅助手段</h3><p>为数据选择利于高效查询的数据类型。<br><strong>多用数字运算，少用字符串运算</strong><br>数字运算通常比字符串运算更快。尽可能使用数字表示数据，如以点记号表示的 IP 地址，可以采用 4 组数字依次存入 INT UNSIGNED，而非直接使用字符串，尽管更方便，但数字对数据操作更高效，且更加节省空间。<br><strong>把数据列声明为 NOT NULL</strong><br>这可以加快查询，因为查询处理期间不再需要检查该列的值是否可以为 NULL，也有利于编写更简洁的 sql 语句。如果必须考虑 NULL 的情况，也可以考虑默认值等方式。<br><strong>考虑使用 ENUM 列</strong><br>如果必须采用字符串的列，恰好其基数很小（差异值较少），可以考虑转用 ENUM 列，即内部实际上采用数字形式存储，从而获得数字运算的处理速度。<br><strong>使用 PROCEDURE ANALYSE()</strong><br>运行 PROCEDURE ANALYSE()，可以根据输出得出一些优化手段。<br><strong>整理表碎片</strong><br>对频繁修改的表，尤其是包含可变长数据列的表，往往会产生大量碎片，导致空间浪费。定期使用 OPTIMIZE TABLE，可以消除&#x2F;减少碎片化的 InnoDB、MyISAM 表的空间浪费，并有助于防止性能降低。适用于各存储引擎的碎片整理方式是：先用 mysqldump 转储表，再利用该转储文件重建之：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump db_name table_name <span class="token operator">></span> <span class="token keyword">dump</span><span class="token punctuation">.</span><span class="token keyword">sql</span>mysql db_name <span class="token operator">&lt;</span> <span class="token keyword">dump</span><span class="token punctuation">.</span><span class="token keyword">sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>压缩数据</strong><br>把数据压缩到 BLOB 或 TEXT 列。使用 BLOB 或 TEXT 列来存储那些可以在应用程序中对其进行压缩和解压的数据，使之能够使用单个索引操作找出所有内容的目的。这种方法特别适用于存储那些难以用标准表数据结构表示的数据，或者会随时间变化的数据。<br><strong>把 BLOB 或 TEXT 列剥离处出来形成一个单独的表</strong><br>将 BLOB 或 TEXT 列单独存入一个附表，可以更好地管理原表里的数据</p><h2 id="如何使用索引"><a href="#如何使用索引" class="headerlink" title="如何使用索引"></a>如何使用索引</h2><p><strong>一个索引是否适合某个查询的“三星系统”</strong></p><ul><li>索引将相关的记录放到一起则获得一星；</li><li>索引中的数据顺序和查找中的排练顺序一致则获得二星；</li><li>索引中的列包含了查询中需要的全部列则获得三星。</li></ul><p><strong>利用最左前缀</strong><br>当创建包含 n 个列的复合索引时，实际上会创建 n 个索引，即相当于多个索引，因为索引中最左边的任意数据列集合都可以用于匹配各个行。这样的集合即为 <strong>最左前缀</strong>。<br>假设：多个列的复合索引中包含列：county、state、city，索引中行的排列顺序为 country&#x2F;state&#x2F;city。那么，行首先会按照 county&#x2F;state 顺序排序，然后按 country 顺序排序，这意味着，即使在查询中只指定了 county 值，或者只指定了 country 和 state 值，MySQL 也可以充分利用索引。因此，索引可用于搜索这些列组合：<br>country, state, city<br>country, state<br>country<br>对于没有包含最左前缀的搜索，如按照 state 或者 city 来搜索，MySQL 则无法使用该索引；而如果要所搜 country 和 city（索引的第 1、3 列，跳过第 2 列），那么索引能够找到与 country 匹配的行以缩小搜索范围，但无法继续用于 city 列。</p><h2 id="索引代价"><a href="#索引代价" class="headerlink" title="索引代价"></a>索引代价</h2><p>主要体现在索引导致的写操作效率降低和空间占用两方面。</p><h3 id="降低写操作效率"><a href="#降低写操作效率" class="headerlink" title="降低写操作效率"></a>降低写操作效率</h3><p>写入操作（插入、删除、更新等）同时需要更新索引，所以表上的索引越多，需要做出的索引修改操作越多。所以在写操作频繁的表中，需要一些优化措施。</p><h3 id="占用空间"><a href="#占用空间" class="headerlink" title="占用空间"></a>占用空间</h3><p>索引会占用磁盘空间，尤其在多个索引的表中，索引可能导致很快达到表大小上限，这跟具体存储引擎有关：</p><ul><li>InnoDB 中，使用独立表空间的表，索引 + 数据行有文件大小限制，受操作系统影响；使用系统表空间则所有表和索引共享同一个存储空间池，添加索引会使存储空间减少得很快，但总大小不受操作系统的影响，逻辑上可以配置多个文件，所以可以使用磁盘扩容表空间。</li><li>MyISAM 中，大量的索引可能导致索引文件比数据文件更快达到文件大小的上限。</li></ul><h3 id="B-x2F-B-树索引的限制："><a href="#B-x2F-B-树索引的限制：" class="headerlink" title="B&#x2F;B+树索引的限制："></a>B&#x2F;B+树索引的限制：</h3><ul><li>如果不是按照索引的最左列开始查找，则无法使用该索引；</li><li>不能跳过索引中的列。即，如果一个索引中含有三个列，则只有在使用了第一、二列的情况下，才能使用第三列；</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引查找。如果范围查询列值的数量有限，可以通过使用多个等于条件替代之。<br>etc.</li></ul><h2 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h2><ul><li>对于 MyISAM 表，其数据保留在数据文件中，索引值保留在索引文件中，即使用数据的物理位置引用被索引的行，并使用前缀压缩技术使得索引更小，一个表可以有多个索引，但它们都保存在同一个索引文件里。索引文件里的每个索引都由一组有序的关键字行构成，这组关键字行主要用于快速访问数据文件；</li><li>对于 InnoDB 表，默认情况下，只使用一个表空间，用于管理所有的 InnoDB 数据存储和索引存储，也可以修改配置，让它创建的每个表都有自己的表空间，但此时，给定表的数据和索引也同样保存在同一个表空间文件。同样地，InnoDB 将索引值当作一组有序值。InnoDB 存储引擎表是索引组织表，即表中数据按照主键顺序存放，即根据主键引用被索引的行。</li></ul><h2 id="sql分析"><a href="#sql分析" class="headerlink" title="sql分析"></a>sql分析</h2><h3 id="explain分析"><a href="#explain分析" class="headerlink" title="explain分析"></a>explain分析</h3><p><strong>语法</strong>：explain + SQL语句<br>执行explain分析语句的结果列中，有几列是与索引使用情况相关的：</p><ol><li>type：join 类型，判断此次查询是全表扫描还是索引扫描等信息；</li><li>possible_keys：指出MySQL能使用哪个索引在该表中找到行；</li><li>key：显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL；</li><li>key_len：显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL；</li><li>ref：显示使用哪个列或常数与key一起从表中选择行。</li></ol><p><a href="https://juejin.im/post/5babb52c6fb9a05cd676c0f7">语句执行分析</a><br><a href="https://segmentfault.com/a/1190000008131735">Explain 使用分析</a></p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS</title>
      <link href="//cs/os/"/>
      <url>//cs/os/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="//cs/java/"/>
      <url>//cs/java/</url>
      
        <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p><strong>各种不同平台的 VM 与所有平台统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石。</strong><br>然而，VM 的目标显然不止于平台无关，其语言无关性也同样在发展：目前已经有 Groovy、Jython、JRuby、Scala 等语言同样能够运行在 JVM 上。而实现语言无关性的基础仍然是 VM 和字节码存储格式。JVM 不和包括 java 在内的任何语言绑定，它只和“class 文件”这种特定格式的二进制文件格式所关联，其中包含了 JVM 指令集和符号表以及若干其他辅助信息。任何其他语言同样可以使用合适的编译器将其代码编译为 class 文件从而在 JVM 上执行，JVM 本身不关心 class 文件来源于何种语言——只要该 class 文件符合 jvms 的语法和结构化约束即可。<br>字节码所能提供的语义描述能力强于 java 语言。</p><p><strong>class 类文件的结构&#x2F;字节码</strong><br><img src="/cs/java/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="class文件结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" class="lozad post-image"><br>以 8-byte 为单位紧凑排列，大端字节序方式，不含任何分隔符，格式是严格定义的：数据项顺序、数量，字节序，哪个字节代表什么含义等等，都不允许改变。<br>文件格式采用类似于 C 语言结构体的伪结构，只含有两种数据类型：<strong>无符号数和表</strong>。</p><ul><li>无符号数：基本数据类型，以 u1、u2、u4、u8 表示 1&#x2F;2&#x2F;4&#x2F;8 个字节的无符号数。可以用来描述数字、索引引用、数量值或按照 UTF-8 编码构成字符串值；</li><li>表是由多个无符号数或其他表作为数据项构成的复合数据类型。所有表习惯性以“_info”结尾。用于描述有层次关系的复合结构的数据。整个 class 文件本质上就是一张表。数据项：<br><img src="/cs/java/class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.PNG" alt="class文件格式" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.PNG" class="lozad post-image"></li></ul><p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。</p><h2 id="魔数与-class-文件版本"><a href="#魔数与-class-文件版本" class="headerlink" title="魔数与 class 文件版本"></a>魔数与 class 文件版本</h2><p>每个 class 文件前 4 个字节称为魔数（Magic Number），唯一作用是确定该文件是不是一个能被 JVM 接受的 class 文件。_很多文件存储标准中都是用魔数进行身份识别，如图片格式（gif、jpeg等都在头文件中存有魔数），魔数值可以由文件制定者自由选取，但要避免引起混淆_。使用魔数而非扩展名是基于安全性方面的考虑：扩展名可随意改动。class 文件的魔数值为：0xCAFEBABE（咖啡宝贝？），这个值在 java 还称作“Oak”语言的时候（1991年前后）就已经确定下来了。<br>紧接着魔数的 4 个字节存储的是 class 文件的版本号：5<del>6 字节是次版本号（Minor Version），7</del>8 字节是主版本号（Major Version）。Java 的版本号是从 45 开始的（JDK 1.xxx 为 45.xxx，而 JDK 1.8 为 52.xxx），JDK 1.1 之后的每个 JDK 大版本发布时，主版本号向上 +1（JDK 1.0<del>1.1 使用了 45.0</del>45.3 的版本号），高版本的 JDK 能向下兼容以前版本的 class 文件，但不能运行以后版本的 class 文件，即使文件格式未发生任何变化，JVM 也必须拒绝执行超过其版本号的 class 文件。</p><h2 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h2><p>紧接着主次版本号之后的是常量池入口，常量池可以理解为 class 文件中的资源仓库，是 class 文件结构中与其他项目关联最多的数据类型，也是占用 class 文件空间最大的数据项之一，也是 class 文件中第一个出现的表类型数据项目。<br>与 java 语言习惯不一样的是，常量池的容量计数器是从 1 而不是 0 开始的：为了满足某些索引在特定情况下需要表达“不引用任何一个常量池项目”的含义时，可以将索引值置 0。故总数量为 计数器值 - 1。class 文件中只有常量池的容量计数器是从 1 开始的。<br>常量池主要存放两大类常量：</p><ul><li>字面量（Literal）：接近于 java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等；</li><li>符号引用（Symbolic References）：属于编译原理方面的概念，包含以下 3 类常量：<blockquote><p>类和接口的全限定名（Fully Qualified Name）<br>字段的名称和描述符（Descriptor）<br>方法的名称和描述符</p></blockquote></li></ul><p>class 文件中不保存各个方法、字段的内存布局信息，当 JVM 运行时，需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。</p><p>常量池中每一项常量都是一个表。目前（JDK1.8)共有 14 种结构各异的表数据结构（有 3 种新增于 JDK1.7，为更好地支持动态语言调用）。<br><img src="/cs/java/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%9B%AE%E7%B1%BB%E5%9E%8B.png" alt="常量池项目类型" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%9B%AE%E7%B1%BB%E5%9E%8B.png" class="lozad post-image"></p><p>这 14 种 表都有一个共同特点：起始位置的 u1 标志位，代表当前这个常量属于哪种常量类型。每种常量项目的结构表如下：<br><img src="/cs/java/%E5%B8%B8%E9%87%8F%E9%A1%B9%E7%9A%84%E7%BB%93%E6%9E%84%E6%80%BB%E8%A1%A8.png" alt="常量项的结构总表" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E5%B8%B8%E9%87%8F%E9%A1%B9%E7%9A%84%E7%BB%93%E6%9E%84%E6%80%BB%E8%A1%A8.png" class="lozad post-image"></p><h2 id="访问标志（Access-flags）"><a href="#访问标志（Access-flags）" class="headerlink" title="访问标志（Access flags）"></a>访问标志（Access flags）</h2><p>常量池结束之后，紧接着的是 2 字节的访问标志，用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。当前已使用了 8 位，其余位置 0：<br><img src="/cs/java/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="访问标志" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" class="lozad post-image"></p><h2 id="类索引-父类索引-接口索引集合"><a href="#类索引-父类索引-接口索引集合" class="headerlink" title="类索引 父类索引 接口索引集合"></a>类索引 父类索引 接口索引集合</h2><p>类索引（this_class）、父类索引（super_class）是 2 字节，各自指向一个类型为 CONSTANT_Class_info 的类描述符常量；接口索引集合（interfaces）是一组 2 字节类型的数据的集合，入口是 u2 类型的接口计数器，如果该类没有实现任何接口，则置 0，后面的接口索引表不再占用任何字节。<br>这 3 项数据用来确定这个类的继承关系：</p><ul><li>类索引：确定该类的全限定名；</li><li>父类索引：确定该类的父类的全限定名（java 不允许多继承，故只有一个，除了 Object 类，其余都有父类）；</li><li>接口索引集合：描述该类实现了哪些接口，按 implements（如果这个类本身是接口，则是 extends）语句后的接口顺序排列。</li></ul><h2 id="字段表（field-info）集合"><a href="#字段表（field-info）集合" class="headerlink" title="字段表（field_info）集合"></a>字段表（field_info）集合</h2><p>用于描述接口&#x2F;类中声明的变量。字段包括类级变量和实例级变量，但不包括在方法内部声明的局部变量。一个字段可以包括的信息有：字段的作用域（public、private、protected），实例变量还是类变量（static），可变性（final），并发可见性（volatile，是否强制从主内存读写），可否被序列化（transient），字段数据类型（基本类型、对象、数组）、字段名称。字段表结构如下：<br><img src="/cs/java/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="字段表结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="lozad post-image"></p><p>其中，<strong>字段访问标志（access_flags）</strong> 与类中的 access_flags 类似：<br><img src="/cs/java/%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="字段访问标志" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" class="lozad post-image"></p><p>跟随在 access_flags 的是两项索引值：<strong>name_index 和 descriptor_index</strong>，它们是对常量池的引用，分别代表着字段的简单名称、字段和方法的描述符。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">io<span class="token punctuation">.</span>neil<span class="token punctuation">.</span>hust</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello, World"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>全限定名：“io&#x2F;neil&#x2F;hust&#x2F;HelloWorld”是”HelloWorld”类的全限定名（仅仅是把类全名“io.neil.hust.HelloWorld”的“.”换成了“&#x2F;”）；</li><li>简单名称：没有类型和参数修饰的方法或字段名称：sayHello()方法和 str 字段的简单名分别为“sayHello”和“str”；</li><li>字段和方法的描述符：描述字段的数据类型、方法的参数列表（数量、类型、顺序）和返回值。其标识字符含义如下：<br><img src="/cs/java/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%A0%87%E8%AF%86%E5%AD%97%E7%AC%A6%E5%90%AB%E4%B9%89.png" alt="描述符标识字符含义" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%A0%87%E8%AF%86%E5%AD%97%E7%AC%A6%E5%90%AB%E4%B9%89.png" class="lozad post-image"></li></ul><p>字段表都包含的固定数据项目到descriptor_index为止，之后跟随一个 <strong>属性表(attribute_info)集合</strong> 用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。</p><p>字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</p><h2 id="方法表（method-info）集合"><a href="#方法表（method-info）集合" class="headerlink" title="方法表（method_info）集合"></a>方法表（method_info）集合</h2><p>class 文件格式对方法的描述和对字段的描述几乎完全一致，仅在访问标志和属性表集合的可选项中有所区别。<br><strong>方法表访问标志</strong><br><img src="/cs/java/%E6%96%B9%E6%B3%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="方法表访问标志" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E6%96%B9%E6%B3%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" class="lozad post-image"></p><h2 id="属性表（attribute-info）集合"><a href="#属性表（attribute-info）集合" class="headerlink" title="属性表（attribute_info）集合"></a>属性表（attribute_info）集合</h2><p>class 文件、字段表、方法表都可以携带自己的属性表集合，用以描述某些场景专有的信息。<br>与 class 文件中其他数据项要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松：不要求各个属性表之间遵循严格顺序，只要不和已有属性名重复，任何自定义编译器都可以自定义属性信息。而 JVM 运行时会忽略它不认识的属性。为了能正确解析 class 文件，jvms 7 预定义了 21 项属性（目前的 jvms 10 为 26 项），这里以 jvms 10 为例。<br><img src="/cs/java/JVMS%E9%A2%84%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E8%A1%A8.png" alt="JVMS预定义属性表" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/JVMS%E9%A2%84%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E8%A1%A8.png" class="lozad post-image"></p><p>对每个属性，它的名称需要从常量池中引用一个 CONSTANT_UTF8_info 类型的常量来表示，而属性值的结构则完全是自定义的，只需要通过一个 u4 的长度属性说明所占用的位数即可：<br><img src="/cs/java/%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="属性表结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="lozad post-image"></p><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>JVM 把描述类的数据从 class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 JVM 直接使用的 java 类型，这就是 JVM 的类加载机制。<br>java 中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略为应用程序提供了高度的灵活性。</p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>类从被加载到 JVM 内存中开始，到卸载出内存为止，整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）。其中，验证、准备、解析3部分统称为连接（Linking）：<br><img src="/cs/java/%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类生命周期" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="lozad post-image"></p><p>其中，加载、验证、准备、初始化、卸载这 5 个阶段的顺序是确定的（但并非串行，通常是交叉混合式进行的，只是开始执行的顺序是确定的），而解析在某些情况下可能在初始化阶段之后再开始：为了支持 java 的运行时绑定（也称动态绑定&#x2F;晚期绑定）。<br>jvms 规定了 5 种情况下，才能对类立即进行“初始化”：</p><ul><li>遇到 new、getstatic、putstatic、invokestatic 这4条字节码指令时，如果类没有进行过初始化，则先触发其初始化。常见场景是：使用 new 关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用一个类的静态方法；</li><li>使用 java.lang.reflect 包的方法对类进行反射调用时，如果类没有进行过初始化，则先触发其初始化；</li><li>初始化一个类时，如果发现其父类没有进行过初始化，则先触发其父类的初始化；</li><li>JVM 启动时，用户需要指定一个要执行的主类，JVM 会先初始化该主类；</li><li>使用JDK 1.7+ 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发其初始化。</li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”是“类加载（Class Loading）”的一个阶段，jvms 要求这一阶段需要完成以下工作：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>该阶段用户应用程序可以通过自定义类加载器参与，类加载其余过程由 JVM 主导并控制。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>是为了确保 class 文件的字节流中包含的信息符合当前 JVM 的要求，并且不会危害 JVM 自身的安全。是连接阶段的第一步。<br>主要包括：</p><ol><li>文件格式验证，魔数、版本、常量池中常量是否被支持、是否含有 utf-8 以外的编码格式…</li><li>元数据验证，对字节码描述信息进行语义分析校验，可能包括：该类是否有父类；父类是否继承了不允许继承的类（final 修饰的类）；如果不是抽象类，是否实现了父类&#x2F;接口必须实现的所有方法；字段、方法是否与父类产生矛盾…</li><li>字节码验证，最复杂的验证阶段：通过数据流和控制流分析，确保程序语义合法、合乎逻辑；</li><li>符号引用验证，JVM 将符号引用转化为直接引用，该校验发生在解析阶段。</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为类变量分配内存并设置类变量初始值（一般就是零值），这些变量所使用的内存都在方法区中分配：仅包括类变量（static 修饰）而不包括实例变量，实例变量将在对象实例化时随着对象一起分配在 java 堆中。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>JVM 将常量池内的符号引用替换为直接引用的过程。解析阶段的两者含义：</p><ul><li>符号引用（Symbolic References）：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</li><li>可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><h3 id="初始化（类初始化）"><a href="#初始化（类初始化）" class="headerlink" title="初始化（类初始化）"></a>初始化（类初始化）</h3><p>类加载过程的最后一步。准备阶段已经为类变量赋了零值，这一步是执行类构造器<clinit>()方法，执行static域代码（静态类变量显式赋值代码和静态代码块）：</clinit></p><ol><li>编译器会在将 .java 文件编译成 .class 文件时，收集所有类初始化代码和 static {} 域的代码，收集在一起成为 <clinit>() 方法；</clinit></li><li>子类初始化时会首先调用父类的 <clinit>() 方法；</clinit></li><li>JVM 会保证 <clinit>() 方法的线程安全，保证同一时间只有一个线程执行；</clinit></li></ol><p>注意，这里仅指类的初始化，跟实例的初始化阶段不是一回事。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器（Class Loader）是 java 语言的一项创新。在类加载的第一阶段“加载”过程中，需要通过 <strong>类的全限定名</strong> 来获取定义此类的二进制字节流，完成这个操作的模块就是 <strong>类加载器</strong>。这一操作是在 JVM 外部实现的，以便让应用程序自己（开发者）决定如何获取所需的类。jvms 并没有指明类的二进制字节流要从一个 .class 文件获取，也没有指明从哪里获取、怎样获取。这种开放使得 java 在许多领域得到充分利用，目前有以下常用方式获取字节流：</p><ul><li>从 zip 包中读取：jar，ear，war 等；</li><li>从网络中获取，最典型的应用就是 Applet；</li><li>运行时计算生成，最典型的是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 “*$Proxy” 的代理类的二进制字节流；</li><li>由其他文件生成，最典型的 jsp 应用，由 jsp 文件生成对应的 Class 类，etc.</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>从 JVM 角度看，只存在两种类加载器：</strong></p><ul><li>启动类加载器（Bootstrap ClassLoader），JVM 自身的一部分，C++ 实现。负责将 <JAVA_HOME>\lib 目录中或被 -Xbootclasspath 参数所指定的路径中的类库加载到 JVM 内存中，这些类库必须能够被 JVM 识别（仅按照文件名识别，如 tr.jar，名称不符合的类库不会被加载）。_如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可_。</JAVA_HOME></li><li>所有其他的类加载器，独立于 JVM，java 实现，全部继承自抽象类 java.lang.ClassLoader。包括下面的扩展类加载器、应用程序类加载器等。</li></ul><p><strong>从开发人员角度看，绝大部分 java 程序会使用到以下 3 种系统提供的类加载器：</strong></p><ul><li>启动类加载器（Bootstrap ClassLoader）；</li><li>扩展类加载器（Extension ClassLoader）,这个加载器由 sun.misc.Launcher $ExtClassLoader 实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器；</JAVA_HOME></li><li>应用程序类加载器（Application ClassLoader）：这个类加载器由 sun.misc.Launcher $App-ClassLoader 实现。这个类加载器是 ClassLoader 中的 getSystemClassLoader() 的返回值（所以也称它为系统类加载器）。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。如果应用程序中没有自定义类加载器，一般情况下它就是默认类加载器。</li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="/cs/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="类加载器双亲委派模型" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" class="lozad post-image"></p><p>所谓的类加载器的双亲委派模型指的是 <strong>类加载器之间的层次关系</strong>。<br>图中所示类加载器之间的层次关系，就是类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应有自己的父加载器。类加载器之间的父子关系一般不会以继承关系（Inheritance）的关系来实现，而是使用组合（Composition）关系来复用父加载器的代码。_双亲委派模型不是强制性约束模型，而是 java 设计者推荐给开发者的一种类加载器实现方式_。</p><p><strong>工作过程</strong><br>如果一个类收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成该加载请求（其搜索内没有找到所需的类）时，子类加载器才会尝试自己去加载。即搜索是从顶层加载器到发出加载请求的加载器各自维护的搜索范围依次进行搜索的。<br>实现双亲委派模型的代码集中在 java.lang.ClassLoader 的 loadClass() 中，具体流程：先检查是否已经加载过该类，若没有，则调用父加载器的 loadClass()，若父加载器为 null，则默认使用启动类加载器作为父加载器。如果父加载器加载失败，抛出 ClassNotFoundException 后，调用自身 findClass() 进行加载。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>    <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 检查是否已经加载过该类</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// ClassNotFoundException thrown if class not found</span>                <span class="token comment">// from the non-null parent class loader</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// If still not found, then invoke findClass in order</span>                <span class="token comment">// to find the class.</span>                <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// this is the defining class loader; record the stats</span>                <span class="token class-name">PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>意义</strong><br>使用双亲委派模型来组织类加载器之间的关系，好处之一是：java 类随着它的类加载器一起，具备了一种带有优先级的层次关系。例如 java.lang.Object 类，它存放在 rt.jar 中，无论哪个类加载器请求加载这个类，最终都是委派给处于模型顶层的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相对地，如果不使用双亲委派模型，而是由各个类加载器自行加载请求类的话，如果开发者编写了一个名为 java.lang.Object 的类，并把它放在程序的 ClassPath 中，那么系统将会出现多个不同的 Object 类，这会导致 java 类型体系中最基础的行为也无法保证，应用程序也将变得非常混乱。<br>内存模型中，判断一个对象是否为某个类型时，前提是比较对象与被比较对象都来自同一个类加载器，否则没有对比的意义——返回 false。</p><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>上述已经提到，这只是一个推荐实现，而非强制约束，这就意味着有可能（有意&#x2F;无意）不被遵循。（详见《深入理解java虚拟机》）。<br><img src="/cs/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="自定义类加载器执行流程" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" class="lozad post-image"></p><h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p>一个对象在可以被使用之前必须要被正确地初始化，一个Java对象的创建过程包括初始化和实例化两个阶段。在实例化一个对象时，JVM首先会检查相关类是否已经加载并初始化，如果没有，则JVM立即进行加载并调用类构造器完成类的初始化。在类初始化过程中或初始化完毕后，根据具体情况对类进行实例化。</p><p>所谓的实例化，以下面一行代码为例：<br><code>Demo demo = new Demo();</code><br>这条语句的动作就是创建一个对象，也就是实例化，它包含四个动作：</p><ol><li>右边的<code>new Demo</code>，是以Demo类为模板，在堆空间里创建一个Demo类对象（也简称为Demo对象）；</li><li>末尾的<code>()</code>意味着，在对象创建后，立即调用Demo类的构造函数，对刚生成的对象进行初始化；</li><li>左边的<code>Demo demo</code>创建了一个Demo类引用变量，所谓Demo类引用，就是以后可以用来指向Demo对象的对象引用。</li><li><code>=</code>操作符使对象引用指向刚创建的那个Demo对象。</li></ol><h2 id="对象创建时机和方法"><a href="#对象创建时机和方法" class="headerlink" title="对象创建时机和方法"></a>对象创建时机和方法</h2><ul><li>使用new关键字创建对象；</li><li>使用Class类的newInstance方法(反射机制)<br>  通过Java的反射机制使用Class类的newInstance方法来创建对象，事实上，这个newInstance方法调用无参的构造器创建对象：  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Student</span> stu1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"Student类全限定名"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　<span class="token class-name">Student</span> stu2 <span class="token operator">=</span> <span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>使用Constructor类的newInstance方法(反射机制)<br>  　java.lang.relect.Constructor类里也有一个newInstance方法可以创建对象，该方法和Class类中的newInstance方法很像，但相比之下，Constructor类的newInstance方法更加强大些，我们可以通过这个newInstance方法调用有参数的和私有的构造函数：  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> constructor <span class="token operator">=</span> <span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Student</span> stu3 <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>使用Clone方法创建对象<br>  调用一个对象的clone方法，JVM会创建一个新的、一样的对象。用clone方法创建对象的过程中并不会调用任何构造函数，且被克隆对象必须实现Cloneable接口并实现其定义的clone方法（原型模式）。注意浅克隆 深克隆。</li><li>使用(反)序列化机制创建对象<br>  反序列化一个对象时，JVM会创建一个单独的对象，在此过程中，JVM并不会调用任何构造函数，类需要实现Serializable接口。</li></ul><p>当一个对象被创建，JVM会为其分配内存来存放对象的实例变量及其从父类继承过来的实例变量(即使这些从超类继承过来的实例变量有可能被隐藏也会被分配空间)。在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值(零值)。在内存分配完成之后，JVM就会开始对新创建的对象进行初始化，主要涉及三种执行对象初始化的结构：实例变量初始化、实例代码块初始化、构造函数初始化。</p><h2 id="初始化（实例化阶段）"><a href="#初始化（实例化阶段）" class="headerlink" title="初始化（实例化阶段）"></a>初始化（实例化阶段）</h2><p>在定义&#x2F;声明实例变量的同时，还可以直接对实例变量进行赋值或者使用实例代码块对其进行赋值。如果以这两种方式为实例变量进行初始化，那么它们将在<strong>构造函数执行之前</strong>完成这些初始化操作。实际上，如果对实例变量直接赋值或者使用实例代码块赋值，编译器会将这些代码放到类的构造函数中去，放在对超类构造函数的调用语句之后，本类构造函数代码之前：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InstanceVariableInitializer</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token class-name">InstanceVariableInitializer</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">var</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token keyword">var</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 实例代码块</span>    <span class="token punctuation">&#123;</span>        j <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">InstanceVariableInitializer</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/**Output:     1    5    8    5 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h1><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>64位：<br><img src="/cs/java/markword-64.png" alt="64位jvm对象头" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/markword-64.png" class="lozad post-image"></p><p>32位：<br><img src="/cs/java/markword-32.png" alt="32位jvm对象头" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/markword-32.png" class="lozad post-image"></p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>内存模型：为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。<br>其解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。</p><p>JMM定义了JVM在计算机内存中的工作方式，主要涉及到 <strong>多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步</strong>。<br>JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。</p><h2 id="高速缓存机制"><a href="#高速缓存机制" class="headerlink" title="高速缓存机制"></a>高速缓存机制</h2><p>目前，CPU的运算速度比计算机存储设备有几个数量级的差距，所以现代计算机都有一层（三层）读写速度尽可能接近处理器的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。<br>基于高速缓存的存储交互很好地解决了处理器与内存之间的矛盾，但也为计算机体系架构设计带来了更高的复杂度，因为引入了一个新的问题：缓存一致性（Cache Coherence）：<br>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存（Main Memory），当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致，此时，同步回主存的数据以谁为准呢？<br>为解决这种不一致，需要各个处理器访问缓存时都遵循一些协议来保证读写操作的正确性。这类协议有 MSI、MESI、MOSI、Synapse、Firefly、Dragon Protocol 等。而 <strong>内存模型</strong>，即可以理解为在特定的操作协议下，对特定的内存&#x2F;高速缓存进行读写访问的过程抽象。<br>不同架构的物理机器可以有不同的内存模型，jvm 拥有自己的内存模型。<br><img src="/cs/java/%E7%89%A9%E7%90%86%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="高速缓存交互关系" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/%E7%89%A9%E7%90%86%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B.png" class="lozad post-image"></p><h2 id="重排序问题"><a href="#重排序问题" class="headerlink" title="重排序问题"></a>重排序问题</h2><p>为使得处理器内部运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但 <strong>不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致</strong>。因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，jvm的即时编译器也有类似的指令重排（Instruction Reorder）优化。</p><p>jvms定义的java内存模型（Java Memory Model，JMM），试图屏蔽掉各种硬件和OS的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。目前已臻至成熟。<br>JMM规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与上述物理硬件的主内存名字一样，两者也可以互相类比，但此处仅是jvm内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。<br><img src="/cs/java/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="java内存模型交互关系" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" class="lozad post-image"></p><p>这里所讲的主内存、工作内存，和java内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。</p><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>JMM 规定了以下 8 种操作，来完成主内存和工作内存之间具体的交互协议——即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节：</p><ul><li>lock（锁定）：作用于主内存变量，它把一个变量标识为仅能被一条线程独占的状态；</li><li>unlock（解锁）：作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量可以被其他线程访问&#x2F;锁定；</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后续的 load 操作使用；</li><li>load（载入）：作用于工作内存的变量，它把 read 操作从主内存得到的变量值放入工作内存的变量副本中；</li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；</li><li>assgin（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作；</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传回到主内存中，以便后续的 write 操作使用；</li><li>write（写入）：作用于主内存变量，它把 store 操作从工作内存中得到的变量的值放入到主内存的变量中。<br>如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，JMM只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插入其他指令的。</li></ul><p>此外，JMM还规定了在执行上述8种基本操作时必须满足如下规则：</p><ul><li>不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现；</li><li>不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存；</li><li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中；</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁；</li><li>如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值；</li><li>如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量；</li><li>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。</li></ul><p><strong>8种内存访问操作和上述规则限定，再加上对volatile关键字的一些特殊规定，就已经完全确定了java程序中哪些内存访问操作在并发下是安全的</strong>。<br>以上定义严谨但繁琐，其有一个等效判断原则——<strong>先行发生原则</strong>，也同样能够确定一个访问在并发环境下是否安全。</p><h2 id="long-和-double"><a href="#long-和-double" class="headerlink" title="long 和 double"></a>long 和 double</h2><p>对于64位的数据类型（long 和 double），JMM规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现不保证64位数据类型的load、store、read、write 这4个操作的原子性——但同时强烈建议jvm保证其操作的原子性，所以目前多数商用jvm都选择把64位数据的读写操作作为原子操作对待来实现。</p><h2 id="原子性-可见性-有序性"><a href="#原子性-可见性-有序性" class="headerlink" title="原子性 可见性 有序性"></a>原子性 可见性 有序性</h2><p>JMM是围绕在并发过程中如何处理原子性、可见性和有序性这3个特性而建立起来的。</p><h3 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性 Atomicity"></a>原子性 Atomicity</h3><p>JMM直接保证基本数据类型（64位的姑且也可以包含在内）的读写访问（read、load、assign、use、store、write）具备原子性。如果场景需要更大范围的原子性保证（经常发生），JMM提供lock、unlock操作来满足这种需求。jvm并没有把这两个操作直接暴露给用户，而是提供了更高层次的字节码指令：monitorenter 和 monitorexit来隐式使用这两个操作。这两个字节码指令反映到java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p><h3 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性 Visibility"></a>可见性 Visibility</h3><p>当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。<strong>JMM通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性</strong>。无论普通变量还是 volatile 变量都是如此，不同在于：volatile 的特殊规则保证了新值能够立即同步到主内存并且每次使用前立即从主内存刷新，从而保证了多线程操作中变量的可见性。<br>除了 volatile 之外，synchronized 和 final也能保证可见性。同步块的可见性由“对一个变量执行 unlock 操作之前，必须把它同步回主内存中（执行 store、write 操作）”这条规则获得的；而 final 关键字的可见性是指：被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this 引用逃逸是危险操作，其他线程有可能通过这个引用访问到”初始化了一半”的对象），那么在其他线程中就能看见 final 字段的值，并且无须同步就能被线程正确访问。</p><h3 id="有序性-Ordering"><a href="#有序性-Ordering" class="headerlink" title="有序性 Ordering"></a>有序性 Ordering</h3><p>如果在本线程观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义（Within-Thread As-If-Serial Semantics）”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。这是 java 程序中天然的有序性。<br>java 语言提供了 volatile 和 synchronized 关键字来保证线程之间操作的有序性，volatile 本身就包含了禁止对指令重排序的语义，而 synchronized 由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得有序性保证——该规则决定了持有同一个锁的两个同步块只能串行地进入。</p><p>可见，synchronized 关键字在需要以上3种特性的时候都可以作为一种解决方案，事实上也是如此：大部分并发控制操作都可以使用它来完成。但滥用以及本可以考虑其他更优的方式而仍然选择使用synchronized，也将导致性能和效率的不同程度降低。</p><h2 id="Happen-Before-原则"><a href="#Happen-Before-原则" class="headerlink" title="Happen-Before 原则"></a>Happen-Before 原则</h2><p>先行发生原则，JMM 定义的两项操作之间的偏序关系，是判断数据是否存在竞争、线程是否安全的主要依据：如果操作 A 先行发生于操作 B，i.e. 操作 A 发生在操作 B 之前，那么操作 A 产生的影响（应该保证）能被操作 B 观察到，“影响”包括修改了共享内存中变量的值、发送了消息、调用了方法等。<br>以下为 JMM 天然存在的 Happen-Before 关系，这些先行发生关系无须任何同步器协助就能正常执行，即在编码过程中直接使用，并且如果两个操作之间的关系不在下述范围之列，或者无法从下述条目推导得出，那么它们就没有顺序性保证，jvm 就可以对它们进行重排序：</p><ul><li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作（更准确的说法是控制流顺序而不是代码顺序，因为有分支、循环等结构）；</li><li>监视器锁规则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里强调同一个锁，而“后面”是指时间上的先后顺序；</li><li>volatile 变量规则（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。这里的“后面”同样是指时间上的先后顺序；</li><li>传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么可以得出结论：操作 A 先行发生于 操作 C。</li><li>线程启动规则（Thread Start Rule）：Thread 对象的 start() 方法先行于此线程的每一个动作；</li><li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，可以通过 Thread.join()方法的结束、Thread.isAlive()的返回值等手段检测到线程是否已经终止；</li><li>线程中断规则（Thread Interruption Rule）：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted()方法检测到线程是否有中断发生；</li><li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始；<br>可以根据以上规则判定一端代码是否可以保持线程安全，即是否需要采取线程安全的措施。</li></ul><p>ref：<a href="https://mp.weixin.qq.com/s/ME_rVwhstQ7FGLPVcfpugQ">Java内存模型是什么</a></p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>关键字volatile可以被认为是jvm提供的最轻量级的同步机制。volatile变量在各个线程的工作内存中不存在一致性问题：在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题。<br>当一个变量被定义为volatile后，它具备两个特性：</p><h2 id="保证此变量对所有线程的可见性"><a href="#保证此变量对所有线程的可见性" class="headerlink" title="保证此变量对所有线程的可见性"></a>保证此变量对所有线程的可见性</h2><p>这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。（回想普通变量，其值在线程间传递均需要通过主内存来完成，例如，线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见）。但可见性并不意味着线程安全，事实上，volatile 并不是线程安全的，它并不能保证操作符合原子性。所以在一些有依赖的运算中，仍然要通过加锁（使用 synchronized 或 java.util.concurrent 中的原子类）来保证原子性。</p><h2 id="禁止指令重排序优化"><a href="#禁止指令重排序优化" class="headerlink" title="禁止指令重排序优化"></a>禁止指令重排序优化</h2><p>普通变量仅保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不保证变量赋值操作的顺序与程序代码中的执行顺序一致。而在一个线程的方法执行过程中无法感知到这点，这也就是 JMM 描述的所谓“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。<br>从硬件上讲，指令重排不是以指令顺序任意执行，而是CPU在正确处理<strong>依赖情况</strong>的前提下，可能会将没有依赖关系的指令（来自于代码汇编的字节码）不按程序中代码顺序分开发送给相应电路单元进行处理，并且保证在后续有对之前的操作结果有依赖的地方能够取到正确的值，这样从最终结果上看依然是像有序执行的结果；而有依赖关系的代码指令之间不能重排。<br>volatile能够禁止指令的重排优化，通过汇编代码可见，有volatile修饰的变量在执行操作后，会多执行一句“lock addl $0x0，(%esp)”指令（把 ESP 寄存器的值加 0，显然是一个空操作），这相当于一道内存屏障使得指令重排序无法逾越，关键就在于其lock前缀，它的作用是使得本CPU的Cache写入内存，同时该写入动作会引起别的CPU或者别的内核无效化（Invalidate）其Cache，即相当于对Cache中的变量做了一次JMM中的“store和write”操作。所以通过这样一个空操作，可让volatile变量的修改对其他CPU立即可见。</p><h2 id="volatile-vs-lock"><a href="#volatile-vs-lock" class="headerlink" title="volatile vs lock"></a>volatile vs lock</h2><p>显然，volatile并不等同于安全的锁，它也无法在多线程中保证安全性，但在特定场景下依然能够提供“足够的安全性”且比锁（synchronized 关键字或 java.util.concurrent 包里面的锁）效率更高。但随着 jvm 对锁的各种优化策略的进步——锁消除、锁粗化等，已无法简单定量分析究竟孰优孰劣。而如果让 volatile 自身对比，那可以确定一个原则：volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据应该是<strong>volatile的语义能否满足使用场景的需求</strong>。<br><strong>使用场景（满足以下条件时使用）</strong></p><ul><li>对变量的写操作不依赖变量的当前值或其他的变量，或者能确保只有单个线程更新变量值；</li><li>该变量不会与其他状态变量一起纳入不变性条件中；</li><li>在访问变量时不需要加锁。</li></ul><h2 id="单例模式双重校验"><a href="#单例模式双重校验" class="headerlink" title="单例模式双重校验"></a>单例模式双重校验</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DoubleCheckedLock</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 修饰禁止重排序</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">DoubleCheckedLock</span> instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">DoubleCheckedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//构造器必须私有  不然直接new就可以创建</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">DoubleCheckedLock</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//第一次判断，假设会有好多线程，如果doubleLock没有被实例化，那么就会到下一步获取锁,只有一个能获取到</span>        <span class="token comment">//如果已经实例化，那么直接返回，减少除了初始化时之外的所有锁获取等待过程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//同步</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">DoubleCheckedLock</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//第二次判断是因为假设有两个线程A、B,两个同时通过了第一个if，然后A获取了锁，进入然后判断doubleLock是null，</span>                <span class="token comment">// 他就实例化了doubleLock，然后他出了锁，这时候线程B经过等待A释放的锁，B获取锁了，</span>                <span class="token comment">// 如果没有第二个判断，那么他还是会去new DoubleLock()，再创建一个实例，所以为了防止这种情况，需要第二次判断</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//下面这句代码其实分为三步：</span>                    <span class="token comment">//1.开辟内存分配给这个对象</span>                    <span class="token comment">//2.初始化对象</span>                    <span class="token comment">//3.将内存地址赋给虚拟机栈内存中的doubleLock变量</span>                    <span class="token comment">//注意上面这三步，第2步和第3步的顺序是随机的，这是计算机指令重排序的问题</span>                    <span class="token comment">//假设有两个线程，其中一个线程执行下面这行代码，如果第三步先执行了，就会把没有初始化的内存赋值给doubleLock</span>                    <span class="token comment">//然后恰好这时候有另一个线程执行了第一个判断if(doubleLock == null)，然后就会发现doubleLock指向了一个内存地址</span>                    <span class="token comment">//这另一个线程就直接返回了这个没有初始化的内存，所以要防止第2步和第3步重排序</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleCheckedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>假设当前场景只有一个线程，并没有线程竞争关系，不仅不存在多线程竞争，而且总是由同一线程多次获得，那么此时这个线程如果获取到锁资源，锁状态就是偏向锁，此时Synchronized修饰的锁对象会把当前线程的ID存入到MarkWord中，以后只要不发生竞争，这个对象就归该线程所有。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁的使用场景就是多个线程竞争同一个锁资源，如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），此时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>jdk1.6之前，synchronized 是重量级锁。jdk1.6引入锁膨胀&#x2F;锁升级，即：<br>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁<br>有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁，这时候在进行并发操作时，大部分的场景不再需要用户态到内核态的转换，从而大幅的提升 synchronized 的性能。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>JIT编译器在编译的时候，进行逃逸分析，分析synchronized锁对象是不是只可能被一个线程加锁，不存在其他线程来竞争加锁的情况。<br>比如StringBuffer对象，属于一个局部变量，并且不会从该方法中逃逸出去，那么此时就可以使用锁消除（不加锁），替换为StringBuilder，来消除锁。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>锁粗化是指，将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。<br>比如for循环内对某个对象连续加锁。</p><h3 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h3><p>检测到重量级锁并进入阻塞状态的开销比较大。jdk1.4引入自旋锁，即当前线程先不进入阻塞状态，而是进行一定次数的忙循环，也就是所谓的自旋，来等待获取当前共享资源的锁，期间不让出CPU资源，如果获取失败，再进入阻塞。<br>jdk1.6引入自适应自旋锁，所谓的自适应，即不再自旋固定的次数，而是一个动态的次数，一个实践中的规则是：<br>自旋次数通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。如果线程【T1】自旋成功，自旋次数为17次，那么等到下一个线程【T2】自旋时，也会默认认为【T2】自旋17次；如果【T2】自旋了5次就成功了，那么此时自旋次数就会缩减到5次。</p><h2 id="vs"><a href="#vs" class="headerlink" title="vs"></a>vs</h2><p><img src="/cs/java/reentrantLock_vs_synchronized.png" alt="ReentrantLock vs synchronized" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/reentrantLock_vs_synchronized.png" class="lozad post-image"></p><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><p><img src="/cs/java/juc-pkg.png" alt="JUC包" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/juc-pkg.png" class="lozad post-image"><br>JUC包主要包括这么几个模块：</p><ul><li>atomic: 原子性包，包含有AtomicBoolean、AtomicInteger、AtomicIntegerArray等原子变量类，持有它们各自的对应的类型变量value，而且被volatile关键字修饰，这样来保证每次一个线程要使用它都会拿到最新的值。</li><li>collections: 集合类包，主要提供线程安全的集合，包括ArrayList对应的CopyOnWriteArrayList，HashSet对应的CopyOnWriteArraySet，HashMap对应的ConcurrentHashMap等；</li><li>locks: 锁包，提供锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁。包含的实现类主要有：<ul><li>ReentrantLock，独占锁，同一个时间点只能被一个线程锁获取到的锁；</li><li>ReentrantReadWriteLock，包括子类ReadLock和WriteLock，ReadLock是共享锁，WriteLock是独占锁；</li><li>StampedLock，</li><li>LockSupport，具备阻塞线程和解除阻塞线程的功能，并且不会引发死锁。</li></ul></li><li>executor: 执行器，Java线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有：<ul><li>ScheduledExecutorService，解决那些需要任务重复执行的问题；</li><li>ScheduledThreadPoolExecutor，周期性任务调度的类实现；</li></ul></li><li>tools: 工具包，包含一些同步辅助工具类：<ul><li>CountDownLatch，闩锁，同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待；</li><li>CyclicBarrier，栅栏，允许一组线程互相等待，直到到达某个公共屏障点，并且在释放等待线程后可以重用；</li><li>Semaphore，信号量，计数信号量，它的本质是一个“共享锁“。信号量维护了一个信号量许可集。线程可以通过调用 acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。线程可以通过release()来释放它所持有的信号量许可。<br><a href="https://blog.csdn.net/weixin_43888181/article/details/116546374">https://blog.csdn.net/weixin_43888181/article/details/116546374</a></li></ul></li></ul><p><img src="/cs/java/juc-arch.png" alt="JUC结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/juc-arch.png" class="lozad post-image"><br><a href="https://blog.csdn.net/weixin_43888181/article/details/116546374">JUC入门</a></p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>ReentrantLock继承了Lock，有三个内部类，关系如下：<br><img src="/cs/java/ReentrantLock.png" alt="ReentrantLock" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/ReentrantLock.png" class="lozad post-image"><br>ReentrantLock 类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与 FairSync类继承自 Sync类，Sync类继承自 AbstractQueuedSynchronizer抽象类。</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AbstractQueuedSynchronizer，抽象队列同步器，使用原生java代码实现了并发访问控制语义，定义出一套多线程访问共享资源的同步器框架，是整个JUC包的基石，Lock、ReadWriteLock、CountDownLatch、CyclicBarrier、Semaphore、ThreadPoolExecutor等都是在其基础上实现的。<br><strong>并发控制的核心是锁的获取与释放</strong>，AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用CLH队列的变体实现，将暂时获取不到锁的线程加入到队列中。</p><h2 id="CLH锁"><a href="#CLH锁" class="headerlink" title="CLH锁"></a>CLH锁</h2><p>CLH(Craig, Landin, and Hagersten locks)是一种基于链表的可扩展、高性能、公平的自旋锁，能确保无饥饿性，提供先来先服务的公平性。申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。<br>CLH队列中的节点QNode中含有一个locked字段，该字段若为true表示该线程需要获取锁，且不释放锁，为false表示线程释放了锁。节点之间是通过隐形的链表相连，之所以叫隐形的链表是因为这些节点之间没有明显的next指针，而是通过myPred所指向的节点的变化情况来影响myNode的行为。CLHLock上还有一个尾指针，始终指向队列的最后一个节点。<br><img src="/cs/java/aqs-clh-queue.png" alt="CLH锁" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/aqs-clh-queue.png" class="lozad post-image"><br><img src="/cs/java/clh-lock.png" alt="CLH锁" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/clh-lock.png" class="lozad post-image"></p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><img src="/cs/java/aqs-arch.png" alt="CLH锁" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/java/aqs-arch.png" class="lozad post-image"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> tail<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ExclusiveNode</span> <span class="token keyword">extends</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SharedNode</span> <span class="token keyword">extends</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token comment">//原子的设置当前同步器的状态</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/zhengzhaoyang122/article/details/110847701">ReentrantLock详解</a><br><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>Compare And Swap，比较并替换，在硬件&#x2F;底层层面是这样，而在java等语言层面的表述是 Compare And Set，如典型的Unsafe类、JUC很多同步类等。<br>CAS机制使用3个基本操作数：内存地址V，旧的预期值A，要更新的值B：更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B，这个过程在硬件层面保证是原子性的。</p><p><strong>主要场景</strong>：<br>Atomic系列类；<br>JUC Lock系列类的底层实现；<br>Synchronized升级成重量级锁之前，也会用到CAS；</p><p><strong>缺点</strong>：<br>ABA问题；<br>CPU开销较大，在高并发场景下，很多线程反复尝试更新某个变量，竞争过多，自旋会给CPU带来比较大的压力；<br>并不保证代码块的原子性，它只能保证一个变量的原子性，无法保证多个，不过这个问题可以转用AtomicReference，把多个变量封装在一个对象里：<a href="https://blog.csdn.net/weixin_42146366/article/details/87822781">举个例子</a></p><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>或称 Surrogate，中文“代理”，也作为一种设计模式，其解释为：为其他对象提供一种代理以控制对该对象的访问。可以简单理解成“中介”。代理模式可以在不修改被代理对象的基础上，通过扩展代理类，控制被代理对象的访问，也可以为代理类添加新的操作&#x2F;行为。这在 AOP 中经常见到。<br>一般使用工厂模式实现代理，这样可以将代理包装等操作实现封装在工厂的实现中。<br>要和“装饰者模式”区别开，装饰者模式是 <strong>为对象增加行为</strong>，代理模式是 <strong>控制对象的访问</strong>；同时和“适配器模式”的区别是：适配器会改变对象的接口，而代理使用相同的接口（业务接口不变）。<br>主要分为静态代理和动态代理两种，二者在功能上没有区别，这个划分依据是字节码的创建时机，前者在程序运行前就已经存在代理类的字节码文件，代理类和目标类的关系在运行前就确定了；后者的源码是在程序运行期间由JVM通过反射等机制动态生成的，在运行前并不存在代理类的字节码文件。</p><h2 id="jdk静态代理"><a href="#jdk静态代理" class="headerlink" title="jdk静态代理"></a>jdk静态代理</h2><p>一般是代理对象包装被代理对象。所谓静态，是指代理对象和目标对象都实现了相同的接口。<br>简单的例子：</p><details>  <summary>业务接口</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 增加一个用户</span>    <span class="token keyword">void</span> <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></details><details>  <summary>业务实现</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"增加一个用户。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><details>  <summary>静态代理类</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceProxy</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">UserServiceImpl</span> userImpl<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">UserServiceProxy</span><span class="token punctuation">(</span><span class="token class-name">UserServiceImpl</span> countImpl<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>userImpl <span class="token operator">=</span> countImpl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理类方法，进行增强。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"事务开始。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 调用委托类的方法;</span>        userImpl<span class="token punctuation">.</span><span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"处理结束。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details>在使用的时候，直接初始化一个proxy类，通过这个实例调用代理方法：<details>  <summary>测试</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">UserServiceImpl</span> userImpl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">UserServiceProxy</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceProxy</span><span class="token punctuation">(</span>userImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>    proxy<span class="token punctuation">.</span><span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p>也称接口代理，使用JDK API，动态地在JVM中构建出一个代理对象。<br>被代理类 A 需要实现业务接口，业务代理类 B 需要实现 InvocationHandler 接口：</p><details>  <summary>动态代理类</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 目标对象</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">ServiceInvocationHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">/**     * 创建代理实例     * @return     * @throws Throwable     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">/**     * 实现InvocationHandler接口方法     * 执行目标对象的方法，并进行增强     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理类方法，进行增强。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"事务开始。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 执行目标方法对象</span>        result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"事务结束。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><details>  <summary>测试</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token comment">/**    * jdk动态代理会生成一个动态代理类，生成相应的字节码，然后通过ClassLoader加载字节码。    * 该实例继承了Proxy类，并实现了业务接口，在实现的方法里通过反射调用了InvocationHandler接口实现类    * 的invoke()回调方法。    */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">UserService</span> userService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ServiceInvocationHandler</span> handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceInvocationHandler</span><span class="token punctuation">(</span>userService<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 根据目标生成代理对象</span>    <span class="token class-name">UserService</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserService</span><span class="token punctuation">)</span> handler<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    proxy<span class="token punctuation">.</span><span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><p>JDK动态代理的限制在于，被代理的对象必须实现一个或多个接口，这是java语言本身决定的：java只支持单继承，而代理类本身已经继承了Proxy类，因此只能通过实现(被代理对象也实现了的)接口的方式。</p><h2 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h2><p>如果某个类原本就没有实现任何接口，可以考虑cglib代理——对应地，它通过继承被代理的类，并覆写方法的方式，这就意味着，cglib不能代理final修饰的类。</p><details>  <summary>UserDao</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDao</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"保存数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><details>  <summary>代理对象</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span><span class="token comment">//维护一个目标对象</span>    <span class="token keyword">public</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">//为目标对象生成代理对象</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//工具类</span>        <span class="token class-name">Enhancer</span> en <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置父类</span>        en<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置回调函数</span>        en<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建子类对象代理</span>        <span class="token keyword">return</span> en<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> proxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开启事务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 执行目标对象的方法</span>        <span class="token class-name">Object</span> returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"关闭事务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><details>  <summary>测试</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCglibProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//目标对象</span>    <span class="token class-name">UserDao</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//代理对象</span>    <span class="token class-name">UserDao</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserDao</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//执行代理对象方法</span>    proxy<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li>静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。</li><li>静态代理在编译时产生class字节码文件，可以直接使用，效率高。</li><li>动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li><li>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，重写方法，所以目标对象不能为final类。</li></ul><h1 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h1><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>a question a day</title>
      <link href="//cs/aqad/"/>
      <url>//cs/aqad/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> aqad </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aqad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>algorithm</title>
      <link href="//cs/algs/"/>
      <url>//cs/algs/</url>
      
        <content type="html"><![CDATA[<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><h2 id="初级排序"><a href="#初级排序" class="headerlink" title="初级排序"></a>初级排序</h2><p>几种基础排序算法，时间复杂度为O(n^2)。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是最简单基础的排序算法：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较；<br>其时间复杂度为O(n^2)，在原地交换，不需要额外的空间开销。是一种稳定排序。<br>C++实现：<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>来源于整理扑克牌的排序算法：将每一个元素插入到已经有序的序列中合适的位置，即前向交换使之到达正确位置。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InsertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次（第 i 次：0..N-1）都选择出剩余元素的最小值，将其置换到 i 的位置上去。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">SelectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 最小元素的索引</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span>                min <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>思想：使数组中任意间隔为 h 的元素都是有序的。类似于插入排序，只不过插入排序是交换相邻（间隔为1）元素，而希尔排序是交换间隔为 h 的元素。</p><img src="/cs/algs/algs/Shell.PNG" class title="一个h有序数组，即h个有序子数组组成" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/algs/algs/Shell.PNG" class="lozad post-image"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;</span> length <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span>        h <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> h<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将数组变为h有序</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 将a[i]插入到a[i-h]，a[i-2*h]，a[i-3h]...中</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> h <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> h<span class="token punctuation">)</span>                <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        h <span class="token operator">=</span> h <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>采用分治策略，（两路快排）将一个序列分成两个子序列，独立排序。<br>与归并排序互补：归并排序将序列分成两个部分分别排序，并将有序的子序列归并以将整个序列排序，递归调用发生在处理整个序列之前；而快排则是，当两个子序列都有序时，整个序列也就自然有序了，递归调用发生在处理整个序列之后。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lo <span class="token operator">>=</span> hi<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> lo<span class="token punctuation">,</span> j <span class="token operator">=</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左右扫描指针</span>    <span class="token class-name">Comparable</span> v <span class="token operator">=</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 切分元素，主元</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 扫描左右，检查扫描是否结束并交换元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> hi<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> lo<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> j<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将v=a[j]放入正确位置</span>    <span class="token keyword">return</span> j<span class="token punctuation">;</span>  <span class="token comment">// a[lo..j-1]&lt;=a[j]&lt;=a[j+1..hi]达成</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点</p><ul><li>实现简单，适用于各种不同输入数据；</li><li>原地排序，只需要 O(1) 的辅助空间；</li></ul><p>缺点<br>实现中要避免低劣性能的影响：<br>划分是否相对均衡，即主元的选取；</p><p>优化</p><ul><li>小规模子序列（7 ~ 15）改用插入排序；</li><li>三取样切分：使用子序列一小部分元素的中位数作主元，取样大小为 3 时效果较好；</li></ul><h2 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h2><p>两步操作：堆化、下沉（或上浮）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pq<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> pq<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 构造堆</span>    <span class="token comment">// 从最下层一个非叶节点开始作为根节点，构造子堆</span>    <span class="token comment">// 这样能够保证对该节点的父节点堆化时，下沉动作不会扩散到它的子节点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sink</span><span class="token punctuation">(</span>pq<span class="token punctuation">,</span> k<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">show</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 堆排序过程</span>    <span class="token comment">// 依次下沉当前最大元素，保持堆</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">exch</span><span class="token punctuation">(</span>pq<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sink</span><span class="token punctuation">(</span>pq<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 下沉，使得以 k 位置为根节点，构造一个堆</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pq<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>pq<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>pq<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">exch</span><span class="token punctuation">(</span>pq<span class="token punctuation">,</span> k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>将已有序的子序列合并，得到完全有序的序列的过程，i.e. 先使子序列有序，再使序列段间有序。</p><ul><li>时间复杂度： O(NlogN) ;</li><li>空间复杂度：辅助空间：O(N);</li><li>稳定排序，常使用递归实现。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> lo<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> lo<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        aux<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> lo<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> mid<span class="token punctuation">)</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> hi<span class="token punctuation">)</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>aux<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> aux<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 自顶向下递归：</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lo <span class="token operator">>=</span> hi<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 自底向上循环：</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    aux <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> sz <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> sz <span class="token operator">=</span> sz <span class="token operator">+</span> sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> lo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> lo <span class="token operator">&lt;</span> <span class="token class-name">N</span> <span class="token operator">-</span> sz<span class="token punctuation">;</span> lo <span class="token operator">+=</span> sz <span class="token operator">+</span> sz<span class="token punctuation">)</span>            <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> lo <span class="token operator">+</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>lo <span class="token operator">+</span> <span class="token operator">+</span>sz <span class="token operator">+</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">N</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化</p><ul><li>小规模子序列（7 ~ 15）改用插入排序&#x2F;选择排序；</li><li>测试子序列是否已经有序：a[mid] &lt;&#x3D; a[mid]，则这两个子序列无需调用接下来的 merge() ，直接拷贝即可；</li><li>不将元素复制到辅助空间：将辅助空间也带入 sort()、merge() 方法，每次递归变换二者的位置，从而无需反复拷贝子序列到辅助空间，而是临时将辅助空间用于排序和归并。</li></ul><h2 id="线性时间排序"><a href="#线性时间排序" class="headerlink" title="线性时间排序"></a>线性时间排序</h2><p>比较排序的时间复杂度下限 O(n*logn) 是确定的。在这篇博客里有<a href="http://www.cnblogs.com/gaochundong/p/comparison_sorting_algorithms.html" title="各种比较排序的对比">各种比较排序的对比</a>。<br>还有一类非比较排序算法，适用于一些特定情况。这种特定情况一般是对集合的范围界定：当集合满足一定条件，可以不使用比较的方式实现排序，从而获得优于比较排序下限的时间复杂度：线性时间复杂度内完成排序。<br>常见的线性时间复杂度排序算法有：</p><ol><li>计数排序（Counting Sort）</li><li>基数排序（Radix Sort）</li><li>桶排序（Bucket Sort）</li></ol><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>限制条件：取值范围在 [m, n] 之间的整数，wiki解释集合分布在 [0, 100] 时最适合使用计数排序。<br>原理：对每一个输入元素x，确定出小于x的元素个数，有了这一信息，就可以把x直接放在它在最终输出数组的位置上，例如，如果有17个元素小于x，则x就是属于第18个输出位置。当几个元素相同是，方案要略作修改。<br>时间复杂度：O(n)。<br>空间复杂度：O(n)。<br>这是一种稳定排序。<br>伪代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">COUNTING<span class="token operator">-</span><span class="token function">SORT</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">;</span><span class="token class-name">B</span><span class="token punctuation">;</span> k<span class="token punctuation">)</span>let <span class="token class-name">C</span><span class="token punctuation">[</span><span class="token number">0.</span><span class="token punctuation">.</span>k<span class="token punctuation">]</span> be a <span class="token keyword">new</span> array<span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">to</span> <span class="token namespace">k</span><span class="token class-name">C</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">to</span> <span class="token class-name">A</span><span class="token punctuation">.</span>length<span class="token class-name">C</span><span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">C</span><span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token comment">// C[i] now contains the number of elements equal to i .</span><span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">to</span> <span class="token namespace">k</span><span class="token class-name">C</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">C</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token class-name">C</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment">// C[i] now contains the number of elements less than or equal to i .</span> <span class="token keyword">for</span> j <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">.</span>length downto <span class="token number">1</span> <span class="token class-name">B</span><span class="token punctuation">[</span><span class="token class-name">C</span><span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token class-name">C</span><span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">C</span><span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>原理：以十进制数组n为例，k&#x3D;10，最大数字的位数是d。把元素从个位排好序，然后再从十位排好序，，，，一直到元素中最大数的最高位排好序，那么整个元素就排好序了。<br>时间复杂度：O(d(n+r))。<br>空间复杂度：O(n+r)。<br>这是一种稳定排序。<br>伪代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">RADIX<span class="token operator">-</span><span class="token function">SORT</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token keyword">for</span>  i <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">to</span> <span class="token namespace">d</span>use a stable sort  <span class="token keyword">to</span> <span class="token namespace">sort</span> array <span class="token class-name">A</span> on digit i<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>假定数据服从均匀分布，均匀独立分布在[0， 1)区间。假设有m个桶，即将区间划分为m个大小相同的子区间。将n个元素分别存放到相应的桶中，再对各个桶进行排序，如插入排序。最后遍历每个桶，按照次序列出所有元素即可。<br>时间复杂度：平均为O(n)。<br>空间复杂度：O(n)。<br>伪代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BUCKET<span class="token operator">-</span><span class="token function">SORT</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">)</span>n <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">.</span>lengthlet <span class="token class-name">B</span><span class="token punctuation">[</span><span class="token number">0.</span><span class="token punctuation">.</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> be a <span class="token keyword">new</span> array<span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">to</span> <span class="token namespace">n</span><span class="token operator">-</span><span class="token number">1</span>make <span class="token class-name">B</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> an empty list<span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">to</span> <span class="token namespace">n</span>insert <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> into <span class="token class-name">B</span><span class="token punctuation">[</span>⌊<span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>⌋<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">to</span> <span class="token namespace">n</span><span class="token operator">-</span><span class="token number">1</span>sort list <span class="token class-name">B</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">with</span> <span class="token namespace">insertion</span> sortconcatenate the lists <span class="token class-name">B</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>B<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> together in order<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h1><p>与分治相似：都是通过组合子问题的解来求解原问题。而，分治将问题划分为互不相交的子问题，递归地（思路上）求解子问题，再将它们的解组合起来，得到原问题的解；与之不同地，动态规划应用于子问题重叠的情况，i.e. 不同的子问题具有公共的子子问题（递归求解子问题，将其划分为更小的子子问题）。这种情况下，分治算法将做许多不必要的工作——反复求解公共子子问题；而动态规划对每个子问题只求解一次，将结果保存在一个表格（programming 的由来）中，从而避免重复计算子子问题，i.e. 剪枝。<br>典型的时空权衡（time-memory trade-off）问题：以空间换时间。<br>通常用来求解 <strong>最优化问题（Optimization Problem）</strong>，即在很多可行解中寻找 <strong>（一个&#x2F;多个）最优解</strong> 的过程。</p><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><ol><li>刻画一个最优解的结构特征；</li><li>递归地定义最优解的值；</li><li>计算最优解的值——同常采用自底向上的方法；</li><li>利用计算的信息构造一个最优解。</li></ol><p><strong>两种实现方法</strong></p><ul><li>带备忘录的自顶向下方法（top-down with memoization）。用数组&#x2F;散列表保存递归过程中子问题的解，当要求解一个子问题时，先检查是否已保存过此解，无则计算之；</li><li>自底向上方法（bottom-up method）。需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的”子问题的解。因而可以将子问题按规模排序，从小到大进行求解，当求解某个子问题时，它所依赖的更小的子问题已经求解完毕，结果已经保存。这样可以保证每个子问题只求解一次，并且求解它时，它所有的前提子问题都已完成。</li></ul><h2 id="原理和适用条件"><a href="#原理和适用条件" class="headerlink" title="原理和适用条件"></a>原理和适用条件</h2><p>适用场景：</p><ul><li><strong>最优子结构；</strong></li><li><strong>子问题重叠；</strong></li></ul><h1 id="贪心算法（greedy-algorithm）"><a href="#贪心算法（greedy-algorithm）" class="headerlink" title="贪心算法（greedy algorithm）"></a>贪心算法（greedy algorithm）</h1><p><strong>每一步都做出当前看起来最佳的选择</strong>。即，总是做出 <strong>局部最优的选择</strong>。理论上，适用于贪心算法的问题，同样能用动态规划方法解决。</p><h2 id="设计步骤-1"><a href="#设计步骤-1" class="headerlink" title="设计步骤"></a>设计步骤</h2><p>首先是基于动态规划的设计方式：</p><ol><li>确定问题的最优子结构；</li><li>设计一个递归算法；</li><li>证明如果做出一个贪心的选择，则只剩下一个子问题；并且，证明贪心选择总是安全的；</li><li>设计一个递归算法实现贪心策略；</li><li>将递归算法转换为迭代算法。</li></ol><p>更一般地，通过贪心选择改进最优子结构，使得选择后只剩下一个子问题：</p><ol><li>最优化问题转换为：做出一次选择后，只剩下一个子问题需要求解；</li><li>证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的（没有因为这一次的选择而丢失客观的最优解）；</li><li>证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，即得到了最优子结构。</li></ol><h2 id="能否使用贪心的两个要素"><a href="#能否使用贪心的两个要素" class="headerlink" title="能否使用贪心的两个要素"></a>能否使用贪心的两个要素</h2><p><strong>贪心选择性质（greedy-choice property）</strong><br>通过做出局部最优（贪心）选择来构造全局最优解。与动态规划不同，贪心算法进行选择时可能依赖之前做出的选择，但不依赖任何将来的选择或子问题的解。</p><p><strong>最优子结构</strong><br>同动态规划。</p><h2 id="与动态规划的差别"><a href="#与动态规划的差别" class="headerlink" title="与动态规划的差别"></a>与动态规划的差别</h2><p>考虑 0-1 背包问题和分数背包问题，显然，后者能够使用贪心算法解决，而 0-1 背包问题则只能使用动态规划。</p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>经典的字符串匹配算法。但实现起来并不复杂。<br>首先一个概念是：</p><h2 id="部分匹配表-The-Partial-Match-Table"><a href="#部分匹配表-The-Partial-Match-Table" class="headerlink" title="部分匹配表 The Partial Match Table"></a>部分匹配表 The Partial Match Table</h2><p>参考这篇博文：<a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/">The Knuth-Morris-Pratt Algorithm</a><br>当弄清楚了什么是部分匹配表之后，接下来就是怎么使用它，在匹配失败的时候进行适当的跳跃。<br>使用参考这部分内容<a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解KMP</a></p><p>最后给出一个<a href="https://blog.csdn.net/biaobiaoqi/article/details/8975536">实现</a></p><h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><h2 id="算法-amp-数据结构"><a href="#算法-amp-数据结构" class="headerlink" title="算法 &amp; 数据结构"></a>算法 &amp; 数据结构</h2><p>$$程序 &#x3D; 算法 + 数据结构$$<br>TAOCP中，Donald并没有直接给出“算法”的定义，而是在用了几页的篇幅追溯了一番“Algorithms”这个词的起源以尝试让读者理解它的含义之后，用了欧几里得求解两个正整数最大公因子的例子做阐述：<br><img src="/cs/algs/Euclid-algorithm.png" alt="欧几里得算法" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/algs/Euclid-algorithm.png" class="lozad post-image"><br>其中最重要的是→，赋值&#x2F;代替。<br>他的学生、红皮算法书的作者-Robert Sedgewick沿用这个例子并尝试给出了一个定义：The term algorithm is used in computer science to describe a <strong>finite</strong>, <strong>deterministic</strong>, and <strong>effective</strong> problem-solving method suitable for implementation as a computer program.<br>同时指出了二者之间的关系：大多数算法需要适当地组织数据，<strong>为了组织数据就产生了数据结构</strong>。一脉相承的观点是，数据结构是算法的副产品&#x2F;结果（data structures exist as the byproducts or end products of algorithms）。</p><details>  <summary>数据结构的作用</summary><h2 id="数据结构的作用"><a href="#数据结构的作用" class="headerlink" title="数据结构的作用"></a>数据结构的作用</h2><p>前面说算法需要组织数据，所谓组织，其实就是操作（增、删、改、查）。有关数据结构和算法的课程对中所涉及到的数据结构：数组、链表；以及以前面两者为基础的高级数据结构：堆、树、图；延展开到特定领域&#x2F;方向上优化的数据结构：各种队列，红黑树，B、B+树，拓扑图等等。<br>所有的数据结构的目的都是在特定场景下，优化数据的操作效率。可以用算法书给的demo跑一遍十几条排序算法的效率，便能直观感受到，即使在现在这样高性能的计算机面前，$n^2$ → $n\log(n)$所带来巨大效率的提升；而在特定场景下，采用位图、$O(n)$复杂度的排序算法所能带来的更可观的空间、时间上的节省。<br>绝大多数场景下，我们期待的数据结构是：在保持“有序”的前提下，满足高效的增、删、查操作。其中“有序”是一个相对的概念，堆、单端&#x2F;双端队列、查找树、拓扑图等，都满足以我们所期待的方式的有序性、或者我们所关心的那部分数据的有序性。</p></details><h2 id="哈希、红黑树、跳表"><a href="#哈希、红黑树、跳表" class="headerlink" title="哈希、红黑树、跳表"></a>哈希、红黑树、跳表</h2><p>这里关注K-V型数据结构。</p><h3 id="合适的数据结构"><a href="#合适的数据结构" class="headerlink" title="合适的数据结构"></a>合适的数据结构</h3><p>关注以下速查表数据。<br><img src="/cs/algs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="数据结构复杂度" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/algs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E6%9D%82%E5%BA%A6.png" class="lozad post-image"><br>其中，常用的key-value数据结构有三种：<br>Hash表：插入、查找最快，为$O(1)$；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。<br>红黑树：插入、查找为$\log(n)$，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。<br>SkipList：插入、查找为$\log(n)$，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。</p><ul><li>首先，如果能确定某些数据是静态的，以ACA为例，我们的文案数据目前就可以看成是静态的：可能有描述上的调整，但频次很低，并且数据量不大。这部分数据如果采用直接加载到内存或是中间缓存的话，结构化为HashMap是不错的选择；</li><li>如前所述，大部分数据操作场景是需要增删改操作的，而非仅仅只有读操作。这里不再讨论堆、队列等使用场景，专注通常情况下的<strong>数据的存取操作</strong>，此时需要兼顾读取、和操作后恢复有序的效率，此时Hash表不再是好的选择：迭代、修改操作的时间复杂度比较高，而红黑树则能很好地满足功能需求；</li></ul><h2 id="为什么还要有跳表"><a href="#为什么还要有跳表" class="headerlink" title="为什么还要有跳表"></a>为什么还要有跳表</h2><p>作为平衡树的一种替代实现，跳表主要拥有以下优势：</p><ul><li><p><strong>更简单的实现</strong><br>红黑树增删改元素需要进行旋转、变色，实现起来比较复杂，需要考虑的细节也比较多，到了并发场景下更难以写出可用且高效的红黑树实现；而跳表实现原理相当简单，就是升级版的链表，把链表的某一些元素随机抽出来再组成一个链表，作为一级索引，在该索引集中再次进行抽取，再做一级索引，依次实现多级链表索引，就组成了一个跳表。</p></li><li><p><strong>为了解决在高并发下，红黑树的锁实现导致的可能的死锁和并发度降低问题</strong>。<br>首先这句话意味着，在单线程、低线程数场景下，红黑树可能是更好的选择：以jdk11为例，ConcurrentHashMap存取速度是ConcurrentSkipListMap的4倍左右，而随着并发的线程数增多，后者的性能优势会逐渐体现出来，它的存取时间复杂度几乎和线程数无关，且无锁开销。</p></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>上述可见跳表也是一种典型的“空间换时间”的数据结构。其底层采用二维链表，而非通常采用的数组实现。基本特点：</p><ul><li>由很多层结构组成；</li><li>每一层都是一个有序的链表；</li><li>最底层(Level 1)的链表包含所有元素；</li><li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现；</li><li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。<br><img src="/cs/algs/Skip_list.svg" alt="跳表结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/algs/Skip_list.svg" class="lozad post-image"></li></ul><h2 id="跳表实现"><a href="#跳表实现" class="headerlink" title="跳表实现"></a>跳表实现</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>考虑一个链表：<br><img src="/cs/algs/skipList%E6%9E%84%E9%80%A0-1.jpg" alt="跳表构造" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/algs/skipList%E6%9E%84%E9%80%A0-1.jpg" class="lozad post-image"><br>从该有序表中搜索元素&lt; 23, 43, 59&gt;，需要比较的次数分别为&lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 &#x3D; 12 次。<br>有没有优化的算法？链表是有序的，但不能使用二分查找。类似二叉搜索树，我们把一些节点提取出来，作为索引。得到如下结构：<br><img src="/cs/algs/skipList%E6%9E%84%E9%80%A0-2.jpg" alt="跳表构造" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/algs/skipList%E6%9E%84%E9%80%A0-2.jpg" class="lozad post-image"><br>这里把&lt; 14, 34, 50, 72 &gt;提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构：<br><img src="/cs/algs/skipList%E6%9E%84%E9%80%A0-3.jpg" alt="跳表构造" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/algs/skipList%E6%9E%84%E9%80%A0-3.jpg" class="lozad post-image"></p><details>  <summary>节点类</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span> <span class="token comment">// currently, never detached</span>    <span class="token class-name">V</span> val<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>redis 使用C实现，详见：<a href="https://github.com/antirez/redis/blob/unstable/src/server.h">https://github.com/antirez/redis/blob/unstable/src/server.h</a></p></details><h3 id="搜索元素"><a href="#搜索元素" class="headerlink" title="搜索元素"></a>搜索元素</h3><p>查找元素 117：<br><img src="/cs/algs/skipList%E6%9F%A5%E6%89%BE.jpg" alt="跳表构造" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/algs/skipList%E6%9F%A5%E6%89%BE.jpg" class="lozad post-image"></p><ol><li>比较21，比 21 大，往后面找</li><li>比较37，比 37大，比链表最大值小，从 37 的下面一层开始找</li><li>比较71，比 71 大，比链表最大值小，从 71 的下面一层开始找</li><li>比较85，比 85 大，从后面找</li><li>比较117，等于 117， 找到了节点。</li></ol><details>  <summary>搜索</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">findNode</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// don't postpone errors</span>    <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">></span></span> cmp <span class="token operator">=</span> comparator<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> b<span class="token punctuation">;</span>    outer<span class="token operator">:</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token function">findPredecessor</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> n<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span> <span class="token keyword">int</span> c<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> b<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> outer<span class="token punctuation">;</span>               <span class="token comment">// empty</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> n<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>                     <span class="token comment">// b is deleted</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> n<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token function">unlinkNode</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// n is deleted</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">cpr</span><span class="token punctuation">(</span>cmp<span class="token punctuation">,</span> key<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                b <span class="token operator">=</span> n<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> n<span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token keyword">break</span> outer<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><h3 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h3><p>先确定该元素要占据的层数 K（丢硬币，随机），然后在 Level 1 … Level K 各个层的链表都插入元素：<br>插入 119， K &#x3D; 2<br><img src="/cs/algs/skipList%E6%96%B0%E5%A2%9E-1.jpg" alt="跳表-新增元素" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/algs/skipList%E6%96%B0%E5%A2%9E-1.jpg" class="lozad post-image"><br>其中，然随机变量 K 满足参数为 $p &#x3D; 1&#x2F;2$ 的几何分布，期望值 $E[K] &#x3D; 1&#x2F;p &#x3D; 2$。即各个元素的层数，期望值是 2 层。<br><img src="/cs/algs/Skip_list_add_element.gif" alt="跳表-新增元素" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/algs/Skip_list_add_element.gif" class="lozad post-image"></p><details>  <summary>插入</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">V</span> <span class="token function">doPut</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">></span></span> cmp <span class="token operator">=</span> comparator<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Index</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> h<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> b<span class="token punctuation">;</span>        <span class="token class-name">VarHandle</span><span class="token punctuation">.</span><span class="token function">acquireFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> levels <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token comment">// number of levels descended</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// try to initialize</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> base <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Index</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            b <span class="token operator">=</span> <span class="token punctuation">(</span>HEAD<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> base <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Index</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> h<span class="token punctuation">,</span> r<span class="token punctuation">,</span> d<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// count while descending</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> q<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>node<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span>                        p<span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                        RIGHT<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> r<span class="token punctuation">,</span> r<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpr</span><span class="token punctuation">(</span>cmp<span class="token punctuation">,</span> key<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                        q <span class="token operator">=</span> r<span class="token punctuation">;</span>                    <span class="token keyword">else</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>d <span class="token operator">=</span> q<span class="token punctuation">.</span>down<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token operator">++</span>levels<span class="token punctuation">;</span>                    q <span class="token operator">=</span> d<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    b <span class="token operator">=</span> q<span class="token punctuation">.</span>node<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> z <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>              <span class="token comment">// new node, if inserted</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                       <span class="token comment">// find insertion point</span>                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> n<span class="token punctuation">,</span> p<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span> <span class="token keyword">int</span> c<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> b<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>       <span class="token comment">// if empty, type check key now</span>                        <span class="token function">cpr</span><span class="token punctuation">(</span>cmp<span class="token punctuation">,</span> key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>                    c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> n<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment">// can't append; restart</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> n<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">unlinkNode</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">cpr</span><span class="token punctuation">(</span>cmp<span class="token punctuation">,</span> key<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                    b <span class="token operator">=</span> n<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                         <span class="token punctuation">(</span>onlyIfAbsent <span class="token operator">||</span> VAL<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> v<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> v<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                    NEXT<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> n<span class="token punctuation">,</span>                                       p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    z <span class="token operator">=</span> p<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> lr <span class="token operator">=</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">nextSecondarySeed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>lr <span class="token operator">&amp;</span> <span class="token number">0x3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// add indices with 1/4 prob</span>                    <span class="token keyword">int</span> hr <span class="token operator">=</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">nextSecondarySeed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">long</span> rnd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>hr <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>lr <span class="token operator">&amp;</span> <span class="token number">0</span>xffffffffL<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> skips <span class="token operator">=</span> levels<span class="token punctuation">;</span>      <span class="token comment">// levels to descend before add</span>                    <span class="token class-name">Index</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// create at most 62 indices</span>                        x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Index</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>rnd <span class="token operator">>=</span> <span class="token number">0L</span> <span class="token operator">||</span> <span class="token operator">--</span>skips <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token keyword">else</span>                            rnd <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addIndices</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> skips<span class="token punctuation">,</span> x<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> skips <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                        head <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// try to add new level</span>                        <span class="token class-name">Index</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Index</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">Index</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> nh <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Index</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>node<span class="token punctuation">,</span> h<span class="token punctuation">,</span> hx<span class="token punctuation">)</span><span class="token punctuation">;</span>                        HEAD<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> h<span class="token punctuation">,</span> nh<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>z<span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>       <span class="token comment">// deleted while adding indices</span>                        <span class="token function">findPredecessor</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// clean</span>                <span class="token punctuation">&#125;</span>                <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>采用标准的链表删除即可。<br>删除 71<br><img src="/cs/algs/skipList%E5%88%A0%E9%99%A4.jpg" alt="跳表-新增元素" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/algs/skipList%E5%88%A0%E9%99%A4.jpg" class="lozad post-image"></p><details>  <summary>删除</summary><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">doRemove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">></span></span> cmp <span class="token operator">=</span> comparator<span class="token punctuation">;</span>    <span class="token class-name">V</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> b<span class="token punctuation">;</span>    outer<span class="token operator">:</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token function">findPredecessor</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>                  result <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> n<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span> <span class="token keyword">int</span> c<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> b<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> outer<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> n<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> n<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token function">unlinkNode</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">cpr</span><span class="token punctuation">(</span>cmp<span class="token punctuation">,</span> key<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                b <span class="token operator">=</span> n<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> outer<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> outer<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>VAL<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> v<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result <span class="token operator">=</span> v<span class="token punctuation">;</span>                <span class="token function">unlinkNode</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// loop to clean up</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">tryReduceLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li><p>jdk从1.6开始引入了两个跳表相关的实现类：ConcurrentSkipListMap、ConcurrentSkipListSet（基于ConcurrentSkipListMap），在jdk中主要是用于高并发场景下代替红黑树的实现，不过从jdk8开始，线程安全的Hash表：ConcurrentHashMap采用了CAS、取消分段锁改用大数组、哈希碰撞超过阈值时树化（红黑树）等手段进一步提升了线程安全Hash表相关实现，性能上也有了很大提升。</p></li><li><p>redis：redis的有序集合zset是采用跳表实现的。分析一下zset所支持的操作就不难理解为啥采用跳表而非红黑树了：</p></li></ol><ul><li>插入元素</li><li>删除元素</li><li>查找元素</li><li>有序输出所有元素</li><li>查找区间内所有元素<br>除了易于实现这个因素外。zset所支持的操作中，前4项红黑树都可以完成，且时间复杂度与跳表一致。但是，最后一项，红黑树的效率就没有跳表高了。在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效。而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。</li></ul><ol start="3"><li><p>LevelDB：Google 开源的 key&#x2F;value 存储引擎 LevelDB 以及 Facebook 基于 LevelDB 优化的 RocksDB 都是 LSM Tree 结构的数据库，内部的 MemTable 使用跳表实现。HBase MemStore 内部存储数据就使用的跳表。为什么呢？HBase 属于 LSM Tree 结构的数据库，LSM Tree 结构的数据库有个特点，实时写入的数据先写入到内存，内存达到阈值往磁盘 flush 的时候，会生成类似于 StoreFile 的有序文件，而跳表恰好就是天然有序的，所以在 flush 的时候效率很高，而且跳表查找、插入、删除性能都很高，这应该是 HBase MemStore 内部存储数据使用跳表的原因之一。HBase 使用的是 java.util.concurrent 下的 ConcurrentSkipListMap()。</p></li><li><p>ES：Lucene核心数据结构采用了跳表实现倒排表。使用FST保存词典，FST可以实现快速的Seek，这种结构在当查询可以表达成自动机时(PrefixQuery、FuzzyQuery、RegexpQuery等)效率很高。(可以理解成自动机取交集)此种场景主要用在对Query进行rewrite的时候。FST可以表达出Term倒排表所在的文件偏移。倒排表使用SkipList结构。从上面的讨论可知，求倒排表的交集、并集、差集需要各种SeekTo(docId)，SkipList能对Seek进行加速。</p></li></ol><p>ref：<br><a href="https://stackoverflow.com/questions/256511/skip-list-vs-binary-search-tree">https://stackoverflow.com/questions/256511/skip-list-vs-binary-search-tree</a><br><a href="https://en.wikipedia.org/wiki/Skip_list">https://en.wikipedia.org/wiki/Skip_list</a><br><a href="https://blog.csdn.net/sunxianghuang/article/details/52221913">https://blog.csdn.net/sunxianghuang/article/details/52221913</a><br><a href="https://www.iteye.com/blog/imtinx-1291165">https://www.iteye.com/blog/imtinx-1291165</a><br>《algorithms》<br>《the art of computer programming》</p>]]></content>
      
      
      <categories>
          
          <category> algs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cn</title>
      <link href="//cs/cn/"/>
      <url>//cs/cn/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      <categories>
          
          <category> cn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS</title>
      <link href="//cs/cs/"/>
      <url>//cs/cs/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="//cs/spring/"/>
      <url>//cs/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h1><p>包括Bean、Context、Core。<br><img src="/cs/spring/overview.png" alt="overview" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/overview.png" class="lozad post-image"></p><h2 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h2><p>spring的核心思想常常被称作BOP(Bean Oriented Programming)，面向Bean编程。Bean模块解决以下问题：</p><ol><li>bean的定义；</li><li>bean的创建；</li><li>bean的解析；</li></ol><p>作为业务开发通常只需要关心bean的创建，其他两个过程由spring内部完成。<br>Bean的整体架构是典型的工厂模式，最上层的接口是BeanFactory。ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBean是其子类，目的是为了区分Spring内部对象处理和转化的数据限制：<br>ListableBeanFactory: 表示这些Bean是可列表的，定义bean的集合；<br>HierarchicalBeanFactory: 表示这些Bean有继承关系，定义bean的关系；<br>AutowireCapableBeanFactory: 定义Bean的自动装配规则，定义bean的行为；<br><img src="/cs/spring/BeanFactory-hierarchy.png" alt="BeanFactory-hierarchy" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/BeanFactory-hierarchy.png" class="lozad post-image"></p><p>bean定义，主要由BeanDefinition描述，成功解析后都会被转化为BeanDefinition对象，之后所有的操作都会在BeanDefinition对象之上进行。层次关系如下：<br><img src="/cs/spring/BeanDefinition-hierarchy.png" alt="BeanDefinition-hierarchy" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/BeanDefinition-hierarchy.png" class="lozad post-image"></p><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>Bean包装的是一个个Object，Object中存储着业务所需的数据。那么，如何给这些数据以及它们之间的关系提供生存、运行环境——即保存对象的状态，就是Context要解决的问题。Context就是bean关系的集合，即IoC容器。<br>ApplicationContext是Context最上层的接口，层次关系如下：<br><img src="/cs/spring/ApplicationContext-hierarchy.png" alt="ApplicationContext-hierarchy" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/ApplicationContext-hierarchy.png" class="lozad post-image"><br>ApplicationContext能够标识一个应用环境的基本信息，继承了5个接口，用于拓展Context的功能，其中BeanFactory用于创建Bean，同时继承了ResourceLoader接口，用于访问任何外部资源。<br>子类主要包括：</p><ul><li>ConfigurableApplicationContext: 可动态配置和修改信息的Context，其下AbstractRefreshableApplicationContext最为常用。</li><li>WebApplicationContext: 为Web应用准备的Context，可以直接访问ServletContext。</li></ul><p>作为Ioc容器，Context是Spring其他大部分功能的基础，ApplicationContext必须完成的功能包括：</p><ul><li>标识一个应用环境；</li><li>利用BeanFactory创建Bean对象；</li><li>保存对象关系表；</li><li>捕获各种事件。</li></ul><h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><p>Spring发现、建立和维护Bean之间关系的一系列工具，实际上就是各种util。</p><p>Resource：core最重要的组成部分，主要定义了资源的访问方式，所有资源都抽象到了Resource接口中，主要作用：</p><ul><li>资源包装。Resource向上继承了InputStreamSource接口，所有的资源都通过InputStream来获取，从而屏蔽了资源提供者；</li><li>资源加载。Resource下的ResourceLoader接口，所有资源加载者统一实现该接口就能加载所有的资源，例如之前的ApplicationContext。</li></ul><p>与Context建立关系：ApplicationContext通过ResourcePatternResolver接口与ResourceLoader进行交互，来进行资源的加载、解析和描述。ResourcePatternResolver将资源封装整合，便于其他模块使用。<br><img src="/cs/spring/ResourceLoader-ApplicationContext.png" alt="ResourceLoader-ApplicationContext" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/ResourceLoader-ApplicationContext.png" class="lozad post-image"></p><h1 id="IoC-容器结构"><a href="#IoC-容器结构" class="headerlink" title="IoC 容器结构"></a>IoC 容器结构</h1><p>Spring IoC容器用于创建并管理Spring Bean对象以及Bean属性注入。通过ResourceLoader&#x2F;Resolver读取Bean的配置文件并转换成统一资源对象（Resource），然后通过BeanDefinitionReader转换成pring内部对Bean的描述对象（BeanDefinition），然后将其注册（BeanRegister）到容器中（BeanFactory），供以后转换成Bean对象使用。spring项目源代码很好地把它们划分到了不同的模块中，即上面的三个模块。而从资源读取、描述对象转换、注册使用这些阶段，从源码中又可以抽出以下6个组件：</p><ul><li>资源组件：Resource，对资源文件的描述，不同资源文件如xml、properties文件等，格式不同，最终都将被ResourceLoader加载获得相应的Resource对象；</li><li>资源加载组件：ResourceLoader：加载xml、properties等各类格式文件，解析文件，并生成Resource对象；</li><li>Bean容器组件：BeanFactory体系，IoC容器的核心；</li><li>Bean注册组件：SingletonBeanRegister&#x2F;AliasRegister，将BeanDefinition对象注册到BeanFactory（BeanDefinition Map）中去；</li><li>Bean描述组件：BeanDefinition体系，Spring内部对Bean描述的基本数据结构；</li><li>Bean构造组件：BeanDefinitionReader体系，读取Resource并将其数据转换成一个个BeanDefinition对象。</li></ul><h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p>如各类型的文件，二进制流数据都是资源，是Spring内部对资源的统一描述，整个体系类图网如下：<br><img src="/cs/spring/resource.png" alt="Resource" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/resource.png" class="lozad post-image"></p><h2 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h2><p>ResourceLoader&#x2F;Resolver体系，负责资源的加载，这里的资源指的是xml、properties等文件资源，返回一个对应类型的Resource对象。<br><img src="/cs/spring/ResourceLoader.png" alt="ResourceLoader" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/ResourceLoader.png" class="lozad post-image"></p><h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p>对bean对象描述的基本数据结构。<br><img src="/cs/spring/BeanDefinition.png" alt="BeanDefinition" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/BeanDefinition.png" class="lozad post-image"></p><h2 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h2><p>Bean构造组件，BeanDefinitionReader体系，将Resource对象，转换成BeanDefinition对象，就是将内部资源数据转换成Spring Bean描述数据。就是将统一资源数据对象读取转换成相应内部对象。<br><img src="/cs/spring/BeanDefinitionReader.png" alt="BeanDefinitionReader" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/BeanDefinitionReader.png" class="lozad post-image"></p><h2 id="SingletonBeanRegister-x2F-AliasRegister"><a href="#SingletonBeanRegister-x2F-AliasRegister" class="headerlink" title="SingletonBeanRegister&#x2F;AliasRegister"></a>SingletonBeanRegister&#x2F;AliasRegister</h2><p>Bean注册组件，将BeanDefinition对象注册到BeanFactory中。<br><img src="/cs/spring/BeanRegister.png" alt="BeanRegister" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/BeanRegister.png" class="lozad post-image"></p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>Bean容器组件，整个IoC容器核心，所谓Bean容器，就是这里装着Bean对象以及所需要的各种数据。其中BeanFactory是纯粹的Bean容器，用来存储描述Bean，无关其他环境，而像ApplicationContext，也是Bean容器，但它和应用环境息息相关，所以被称为应用上下文（环境）更恰当，从图中也能看出来，ApplicationContext不仅有着BeanFactory“血统”，同时也继承了EnvironmentCapable、MessageSource、ApplicationEventPublisher，即扩展了其许多额外功能，而其实现类则是和具体应用相关。<br><img src="/cs/spring/BeanFactory-component.png" alt="BeanFactory" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/BeanFactory-component.png" class="lozad post-image"></p><h1 id="SpringBoot启动过程"><a href="#SpringBoot启动过程" class="headerlink" title="SpringBoot启动过程"></a>SpringBoot启动过程</h1><h1 id="请求处理过程"><a href="#请求处理过程" class="headerlink" title="请求处理过程"></a>请求处理过程</h1><p>以典型的web应用为例，一个请求从接收到返回的处理过程相当复杂，如下图所示，主要经过DispatcherServlet、HandlerMapping、Controller、ViewResolver、Model等：<br><img src="/cs/spring/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="request handle" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" class="lozad post-image"></p><ol><li>客户端请求提交到DispatcherServlet；</li><li>由DisPatcherServlet控制器寻找一个或多个HandlerMapping，找到处理请求的Controller；</li><li>DispatcherServlet将请求提交到Controller；</li><li>Controller调用业务逻辑处理后返回ModelAndView；</li><li>DispatcherServlet寻找一个或多个ViewResolver视图解析器，找到ModelAndView指定的视图；</li><li>视图负责将结果显示到客户端。</li></ol><p>Spring MVC所有的请求都经过DispatcherServlet来统一分发，在 DispatcherServlet将请求分发给Controller之前需要借助Spring MVC提供的 HandlerMapping定位到具体的Controller。<br>HandlerMapping接口负责完成客户请求到Controller映射。<br>Controller接口将处理用户请求，这和Java Servlet扮演的角色是一致的。一旦Controller处理完用户请求，将返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。<br>从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。<br>ViewResolver接口（视图解析器）在Web应用中负责查找View对象，从而将相应结果渲染给客户。</p><h1 id="过滤器和拦截器"><a href="#过滤器和拦截器" class="headerlink" title="过滤器和拦截器"></a>过滤器和拦截器</h1><p>这张图解释了典型spring应用常用组件及触发顺序：<br><img src="/cs/spring/request.png" alt="request handle" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/request.png" class="lozad post-image"><br>过滤器在请求进入容器之后、进入servlet之前就被触发，此时还没有进入spring的管辖范围。拦截器是spring提供并管理的，所以它能获取IoC容器信息，比如拿到容器里的bean。</p><p>这张图解释了常用组件具体方法的执行顺序：<br><img src="/cs/spring/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt="执行顺序" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class="lozad post-image"></p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>Filter是JavaEE中Servlet规范的一个组件，它可以在http请求到达Servlet之前，被N个Filter处理：<br><img src="/cs/spring/filter.webp" alt="过滤器" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/filter.webp" class="lozad post-image"><br>过滤器的实现是基于函数回调。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>过滤敏感词汇（防止sql注入）</li><li>设置字符编码</li><li>URL级别的权限访问控制</li><li>压缩响应信息</li></ul><h2 id="interceptor"><a href="#interceptor" class="headerlink" title="interceptor"></a>interceptor</h2><p>用于拦截Controller方法的执行，可以在方法执行、后添加自定义逻辑，类似于AOP编程思想。其实现是基于反射机制——动态代理。</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>拦截器本质上是面向切面编程（AOP），符合横切关注点的功能都可以放在拦截器中来实现，主要的应用场景包括：</p><ul><li>登录验证，判断用户是否登录。</li><li>权限验证，判断用户是否有权限访问资源，如校验token</li><li>日志记录，记录请求操作日志（用户ip，访问时间等），以便统计请求访问量。</li><li>处理cookie、本地化、国际化、主题等。</li><li>性能监控，监控请求处理时长等。</li><li>通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现）</li></ul><h1 id="后处理器"><a href="#后处理器" class="headerlink" title="后处理器"></a>后处理器</h1><h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>容器级别的后处理器。</p><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><h1 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h1><p><a href="https://cloud.tencent.com/developer/article/1497692">https://cloud.tencent.com/developer/article/1497692</a></p><h1 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h1><p>IoC容器初始化过程：<br><img src="/cs/spring/ioc-initialization.png" alt="IoC初始化过程" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/ioc-initialization.png" class="lozad post-image"><br>Spring容器中Bean的生命周期由多个特定的阶段组成，每个阶段都允许外界对Bean加以控制。在Spring中可以从两个层面定义Bean的生命周期：Bean的作用范围；实例化Bean时所经历的一系列阶段。</p><h2 id="文字描述"><a href="#文字描述" class="headerlink" title="文字描述"></a>文字描述</h2><ol><li><p>Bean容器在配置文件中找到Spring Bean的定义。</p></li><li><p>Bean容器使用Java Reflection API创建Bean的实例。</p></li><li><p>如果声明了任何属性，声明的属性会被设置。如果属性本身是Bean，则将对其进行解析和设置。<br>以上步骤见“spring IoC 源码解析”。</p></li><li><p>如果Bean类实现BeanNameAware接口，则将通过传递Bean的名称来调用setBeanName()方法。<br>如果Bean类实现BeanClassLoaderAware接口，则将通过传递加载此Bean的ClassLoader对象的实例来调用setBeanClassLoader()方法。<br>如果Bean类实现BeanFactoryAware接口，则将通过传递BeanFactory对象的实例来调用setBeanFactory()方法。<br>如果有任何与BeanFactory关联的BeanPostProcessors对象已加载Bean，则将在设置Bean属性之前调用postProcessBeforeInitialization()方法。<br>如果Bean类实现了InitializingBean接口，则在设置了配置文件中定义的所有Bean属性后，将调用afterPropertiesSet()方法。<br>如果配置文件中的Bean定义包含init-method属性，则该属性的值将解析为Bean类中的方法名称，并将调用该方法。<br>如果为Bean Factory对象附加了任何Bean 后置处理器，则将调用postProcessAfterInitialization()方法。<br>如果Bean类实现DisposableBean接口，则当Application不再需要Bean引用时，将调用destroy()方法。<br>如果配置文件中的Bean定义包含destroy-method属性，那么将调用Bean类中的相应方法定义。</p></li></ol><h2 id="BeanFactory中Bean的生命周期"><a href="#BeanFactory中Bean的生命周期" class="headerlink" title="BeanFactory中Bean的生命周期"></a>BeanFactory中Bean的生命周期</h2><p><img src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/Spring-Bean-LifeCycle.png" alt="Bean生命周期" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/Spring-Bean-LifeCycle.png" class="lozad post-image"><br>具体过程：</p><ol><li>当调用者通过getBean(beanName)向容器请求某一个Bean时，如果容器注册了org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor接口，则在实例化Bean之前，将调用接口的postProcessBeforeInstantiation()；</li><li>根据配置情况调用Bean构造方法或工厂方法实例化Bean；</li><li>如果容器注册了InstantiationAwareBeanPostProcessor接口，那么在实例化Bean之后，调用该接口的postProcessAfterInstantiation()，可在这里对已经实例化的对象进行一些“梳妆打扮”；</li><li>如果Bean配置了属性信息，那么容器在这一步着手将配置值设置到Bean对应的属性中，不过在设置每个属性之前将先调用InstantiationAwareBeanPostProcessor接口的postProcessPropertyValues()；</li><li>调用Bean的属性设置方法设置属性值；</li><li>如果Bean实现了org.springframework.beans.factory.BeanNameAware接口，则将调用setBeanName()，将配置文件中该Bean对应的名称设置到Bean中；</li><li>如果Bean实现了org.springframework.beans.factory.BeanFactoryAware接口，则将调用setBeanFactory()，将BeanFactory容器实例设置到Bean中；</li><li>如果BeanFactory装配了org.springframework.beans.factory.config.BeanPostProcessor后处理器，则将调用BeanPostProcessor的Object postProcessBeforeInitialization(Object bean, String beanName)对Bean进行加工操作。其中，入参bean是当前正在处理的bean，beanName时当前bean的配置名，返回的对象为加工处理后的Bean。可以使用该方法对Bean进行处理，甚至改变Bean的行为。BeanPostProcessor在Spring框架中占有重要地位，为容器提供对Bean进行后续加工处理的切入点，Spring容器所提供的各种“神奇功能”，如AOP，动态代理等，都是通过它来实施的；</li><li>如果Bean实现了InitializingBean接口，则将调用接口的afterPropertiesSet()；</li><li>如果在&lt;bean&gt;中通过init-method属性定义了初始化方法，则将执行这个方法；</li><li>BeanPostProcessor后处理器定义了两个方法：其一是postProcessBeforeInitialization()，在(8)步调用；其二是Object postProcessAfterInitialization(Object bean, String beanName)，这个方法在此时调用，容器再次获得对Bean进行加工处理的机会；</li><li>如果在&lt;bean&gt;中指定Bean的作用范围是scope&#x3D;”prototype”，则将Bean返回给调用者，调用者负责Bean后续生命周期的管理，Spring不再管理这个Bean的生命周期。如果将作用范围设置为scope&#x3D;”singleton”，则将Bean放入Spring IoC容器的缓存池中，并将Bean引用返回给调用者，Spring继续对这些Bean进行后续的生命管理；</li><li>对于scope&#x3D;”singleton”的Bean（默认情况），当容器关闭时，将触发Spring对Bean后续生命周期的管理工作。如果Bean实现了DisposableBean接口，则将调用接口的destory()，可以在此编写释放资源、记录日志等操作；</li><li>对于scope&#x3D;”singleton”的Bean，如果通过&lt;bean&gt;的destory-method属性指定了Bean的销毁方法，那么Spring将执行Bean的这个方法，完成Bean资源的释放等操作。</li></ol><p>Bean的完整生命周期从Spring容器着手实例化Bean开始，直到最终销毁Bean。其中经过了许多关键点，每个关键点都涉及特定的方法调用，可以将这些方法大致分为4类：</p><ul><li>Bean自身的方法：如调用Bean构造方法实例化Bean、调用setter设置Bean的属性值以及通过&lt;bean&gt;的init-method和destory-method所指定的方法；</li><li>Bean级生命周期接口方法：如BeanNameAware、BeanFactoryAware、InitializingBean和DisposableBean，这些接口方法由Bean类直接实现；</li><li>容器级生命周期接口方法：图示中⭐标识的步骤是由InstantiationAwareBeanPostProcessor和BeanPostProcessor这两个接口实现的，一般称它们的实现类为“后处理器”。后处理器接口一般不由Bean本身实现，它们独立于Bean，实现类以容器附加装置的形式注册到Spring容器中，并通过接口反射为Spring容器扫描识别。当Spring创建任何Bean的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的。也可以自行编写后处理器，让其仅对感兴趣的Bean进行加工处理；</li><li>工厂后处理器接口方法：包括AspectJWeavingEnabler、CustomAutowireConfigurer、ConfigurationClassPostProcessor等方法。工厂后处理器也是容器级的，在应用上下文装配配置文件后立即调用。</li></ul><h2 id="ApplicationContext中Bean的生命周期"><a href="#ApplicationContext中Bean的生命周期" class="headerlink" title="ApplicationContext中Bean的生命周期"></a>ApplicationContext中Bean的生命周期</h2><p>Bean在应用上下文中的生命周期和在BeanFactory中的生命周期类似，不同的是，如果Bean实现了org.springframework.context.ApplicationContextAware接口，则会增加一个调用接口方法setApplicationContext()的步骤。  </p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>Spring定义了多种作用域：</p><ul><li>单例（singleton），在整个应用中，只创建bean的一个实例。</li><li>原型（prototype），每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。</li><li>会话（session），在web应用中，为每个会话创建一个bean实例。</li><li>请求（request），在web应用中，为每个请求创建一个bean实例。</li></ul><p>默认情况下，Spring的所有bean都是单例（singleton）的。使用@Scope注解来选择其它作用域，它可与@Component、@Bean一起使用。两种方式（推荐1）：</p><p>1. </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span>SCOPE_PROTOTYPE<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AClass</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AClass</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">doGetBean</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在xxxConfig类中使用@Bean注解声明bean时和上述方式相同。<br>会话和请求作用域，使用场景是web应用，从命名理解：会话作用域是指该bean的生命周期和一个会话的起始保持一致，比如典型的电商场景，用户登录，搜索商品，加入购物车，购买，付费，结束，这个流程就是一个完整的会话；请求作用域是指用户从发起一个请求开始，到服务器相应该请求的过程。这两种作用域的bean就是在该场景下，随着会话&#x2F;请求的生命周期实例化到销毁，典型的，如电商场景中的”购物车”。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">BeanWrapper</span> <span class="token function">createBeanInstance</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">RootBeanDefinition</span> mbd<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Make sure bean class is actually resolved at this point.</span><span class="token comment">// 解析出 Class</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> beanClass <span class="token operator">=</span> <span class="token function">resolveBeanClass</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>beanClass <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isNonPublicAccessAllowed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span><span class="token string">"Bean class isn't public, and non-public access not allowed: "</span> <span class="token operator">+</span> beanClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 如果工厂方法不为空，则是用工厂方法初始化</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getFactoryMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token comment">// 相关知识点看另一篇文章关于FactoryBean的</span><span class="token keyword">return</span> <span class="token function">instantiateUsingFactoryMethod</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Shortcut when re-creating the same bean...</span><span class="token comment">// 如果不是第一次创建，比如第二次创建 prototype bean。</span><span class="token comment">// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span><span class="token comment">// 所以注释说叫shortcut</span><span class="token keyword">boolean</span> resolved <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> autowireNecessary <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>args <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>constructorArgumentLock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>resolvedConstructorOrFactoryMethod <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 有已经解析过的构造方法</span>resolved <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>autowireNecessary <span class="token operator">=</span> mbd<span class="token punctuation">.</span>constructorArgumentsResolved<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 如果已经解析过则使用解析好的构造方法不需要再次锁定</span><span class="token keyword">if</span> <span class="token punctuation">(</span>resolved<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>autowireNecessary<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 构造方法自动注入</span><span class="token keyword">return</span> <span class="token function">autowireConstructor</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// 默认构造方法</span><span class="token keyword">return</span> <span class="token function">instantiateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Need to determine the constructor...</span><span class="token comment">// 判断是否采用有参构造函数</span><span class="token comment">// 构造器自动装配</span><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ctors <span class="token operator">=</span> <span class="token function">determineConstructorsFromBeanPostProcessors</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ctors <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span>mbd<span class="token punctuation">.</span><span class="token function">getResolvedAutowireMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">.</span>AUTOWIRE_CONSTRUCTOR <span class="token operator">||</span>mbd<span class="token punctuation">.</span><span class="token function">hasConstructorArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token class-name">ObjectUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">autowireConstructor</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> ctors<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// No special handling: simply use no-arg constructor.</span><span class="token comment">// 使用无参构造器</span><span class="token keyword">return</span> <span class="token function">instantiateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="BeanFactory-vs-FactoryBean"><a href="#BeanFactory-vs-FactoryBean" class="headerlink" title="BeanFactory vs FactoryBean"></a>BeanFactory vs FactoryBean</h1><p>首先，它们都是spring framework里比较顶层的接口：BeanFactory可以看做最简版的容器形式，也给具体的IOC容器实现提供规范，比如ApplicationContext；FactoryBean为IOC容器中的Bean创建提供更加灵活的方式，通过给Bean的实现加上一个简单的工厂模式和装饰器模式，使得对Bean的配置更加便捷灵活。<br>从另一个角度讲，两者都是工厂，FactoryBean本身也是一个Factory，并且归BeanFactory管理。</p><h2 id="BeanFactory-1"><a href="#BeanFactory-1" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>以Factory结尾的都是工厂类&#x2F;接口。它是IOC容器的核心接口，其职责包括：实例化、定位、配置应用程序中的对象，以及建立这些对象间的依赖。FactoryBean只是一个接口，并非IOC容器的具体实现，但spring给出了很多种实现：ApplicationContext、DefaultListableBeanFactory、AnnotationConfigApplicationContext等。<br>其中AnnotationConfigApplicationContext是目前构建具体应用很常用的一个，它实现将以注解方式描述组成应用的对象和对象间的依赖关系。AnnotationConfigApplicationContext类将持有注解配置的所有元数据信息，并用这些元数据构建一个完全可配置的系统或应用。<br>再如，ApplicationContext，派生自BeanFactory，仍然是一个接口，但它提供一种更面向框架的方式工作，并且对上下文进行分层和实现继承关系。同时它还派生自MessageSource、ApplicationEventPublisher、HierarchicalBeanFactory、ResourcePatternResolver等接口，从而扩充了以下能力：</p><ul><li>MessageSource, 提供国际化的消息访问;</li><li>资源访问，如URL和文件;</li><li>事件传播;</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层;</li></ul><p>其他各种BeanFactory的子接口、子类也都是扩展了某种功能的类工厂，用于特定场景。</p><h3 id="主要方法："><a href="#主要方法：" class="headerlink" title="主要方法："></a>主要方法：</h3><p><img src="/cs/spring/BeanFactory.png" alt="BeanFactory methods" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/BeanFactory.png" class="lozad post-image"></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>从IOC容器中获取Bean(byName or byType)</li><li>检索IOC容器中是否包含指定的Bean</li><li>判断Bean是否为单例</li></ul><h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p>首先它是一个Bean，用于生产&#x2F;修饰其他Bean的工厂Bean，表现为一个工厂的职责，主要用到工厂模式、装饰器模式。通常情况下，spring容器担任工厂的角色，但也存在一些场景，比如某些Bean实例化过程复杂，需要配置大量信息，此时可以提供一个FactoryBean，用它来实现定制化的Bean实例化逻辑。FactoryBean接口对于Spring框架来说有着重要地位，自身就提供了70多个FactoryBean的实现。</p><h3 id="主要方法：-1"><a href="#主要方法：-1" class="headerlink" title="主要方法："></a>主要方法：</h3><p><img src="/cs/spring/FactoryBean.png" alt="BeanFactory methods" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/spring/FactoryBean.png" class="lozad post-image"></p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>FactoryBean在Spring中最为典型的一个应用就是用来创建AOP的代理对象。AOP实际上是Spring在运行时创建了一个代理对象，也就是说这个对象是在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说，AOP代理对象通过Java的<strong>反射机制</strong>，在运行时创建了一个代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——ProxyFactoryBean。</p><h1 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h1><p>Inversion of Control，控制反转，也称依赖注入（DI，Dependency Injection）。应用对象之间的解耦。<br>通常所讨论的依赖注入是将一个bean的引用注入到另一个bean的属性或构造器参数中，即将一个对象与另一个对象关联起来。java的反射是实现依赖注入的底层技术。依赖注入是Spring容器的内核，AOP、声明式事务等功能也都基于此。<br>Spring是一种容器框架，它帮助完成类的初始化和装配工作，让开发者从这些底层实现类的实例化、依赖关系装配等工作中解脱出来，专注于业务逻辑的开发工作。它通过配置文件或注解描述类和类之间的依赖关系，利用java的反射功能实例化Bean并建立Bean之间的依赖关系，自动完成类的初始化和依赖注入工作。此外，Spring还提供Bean实例缓存、生命周期管理、Bean实例代理、事件发布、资源装载等高级服务。<br>BeanFactory(com.springframework.beans.factory.BeanFactory)是Spring框架最核心的接口，它提供了高级IoC的配置机制。BeanFactory使管理不同类型的java对象成为可能，应用上下文(com.springframework.context.ApplicationContext)建立在BeanFactory基础之上，提供了更多面向应用的功能，如i18n和框架事件体系等，更易于创建实际应用。一般称BeanFactory为IoC容器，称ApplicationContext为应用上下文，有时也称后者为Spring容器。用途上，BeanFactory是Spring框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都可以直接使用ApplicationContext而非底层的BeanFactory。</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>如果说BeanFactory是Spring的”心脏“，那么ApplicationContext就是完整的”身躯“。ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置的方式实现。<br>ApplicationContext的主要实现类是ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，前者默认从类路径加载配置文件，后者默认从文件系统中装载配置文件。<br><img src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/ApplicationContext-hierarchy.png" alt="ApplicationContext类体系结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/ApplicationContext-hierarchy.png" class="lozad post-image"><br>可见，除继承HierarchicalBeanFactory和ListableBeanFactory接口外，ApplicationContext还通过多个其它接口扩展BeanFactory的功能：</p><ul><li>ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了ApplicationListener事件监听接口的Bean可以接收到容器事件，并对事件进行响应处理。在ApplicationContext抽象实现类AbstractApplicationContext中存在一个ApplicationEventMulticaster，它负责保存所有的监听器，以便在容器产生上下文事件时通知这些事件监听者；</li><li>MessageSource：为应用提供i18n国际化消息访问的功能；</li><li>ResourcePatternResolver：所有ApplicationContext实现类都实现了类似于PathMatchingResourcePatternResolver的功能，可以通过带前缀的ant风格的资源文件路径装载Spring配置文件；</li><li>LifeCycle：提供start()、和stop()，主要用于控制异步处理过程。在具体使用时，该接口同时被ApplicationContext实现以及具体Bean实现，ApplicationContext会将start&#x2F;stop的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度等目的。</li></ul><p>ConfigurableApplicationContext扩展于ApplicationContext，它新增了两个主要方法：refresh()、close()，使得ApplicationContext具有启动、刷新、关闭应用上下文的能力。在应用上下文关闭的情况下可以调用refresh()即可启动应用上下文，在已经启动的状态下调用refresh()则可清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利，但作为开发者并不需要过多关心它们。  </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>和BeanFactory初始化类似，如果配置文件放在类路径下，优先考虑使用ClassPathXmlApplicationContext实现；如果放在文件系统路径下，则优先考虑FileSystemXmlApplicationContext实现。也可以指定一组配置文件，Spring会完成自动整合。<br>获取ApplicationContext实例后，就可以像BeanFactory一样调用getBean(beaName)返回bean了。而ApplicationContext的初始化和BeanFactory有一个很大区别：后者在初始化容器时，并未初始化所有的Bean，直到第一次访问某个Bean时才实例化该目标Bean；而ApplicationContext则在初始化应用上下文时就实例化所有单实例的Bean。因此，ApplicationContext的初始化时间会比BeanFactory稍长。<br>Spring支持基于类注解的配置方式，主要功能来自JavaConfig的子项目。一个标注了@Configuration注解的POJO即可提供Spring所需的Bean配置信息。而且Spring为基于注解类的配置专门提供了ApplicationContext实现类：AnnotationConfigApplicationContext，可以直接调用方法实例化Bean，启动容器并装配Bean。</p><h2 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h2><p>WebApplicationContext是专门为Web应用准备的，它允许从相对于Web根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext中可以获得ServletContext的引用，整个Web应用上下文对象将作为属性放置到ServletContext中，以便Web应用环境可以访问Spring应用上下文。Spring专门为此提供了一个工具类WebApplicationContextUtils，通过该类的getWebApplicationContext(ServletContext sc)，可以从ServletContext中获取WebApplicationContext实例。<br>在非Web应用的环境下，Bean只有singleton、prototype两种作用域。WebApplicationContext为Bean添加了三个新的作用域：request、session、global session。<br><img src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/WebApplicationContext-hierarchy.png" alt="WebApplicationContext类体系结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/WebApplicationContext-hierarchy.png" class="lozad post-image"><br>ConfigurableWebApplicationContext扩展了WebApplicationContext，它允许通过配置的方式实例化WebApplicationContext，同时定义了两个重要方法：</p><ul><li>setServletContext(ServletContext servletContext)：为Spring设置Web应用上下文，以便二者整合；</li><li>setConfigLocations(String[] configLocations)：设置Spring配置文件地址，一般是相对于Web根目录的地址，如&#x2F;WEB-INF&#x2F;xxx-dao.xml、&#x2F;WEB-INF&#x2F;xxx-service.xml。用户也可以使用带资源类型前缀的地址，如classpath:com&#x2F;baidu&#x2F;beans.xml等。</li></ul><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>WebApplicationContext的初始化方式和BeanFactory、ApplicationContext有所区别，因为需要ServletContext实例。即必须在拥有Web容器的前提下才能完成启动工作，可以在web.xml中配置自启动的Servlet或定义Web容器监听器(ServletContextListener)，二者均可完成启动Spring Web应用上下文的工作。Spring为二者均提供了支持：</p><ul><li>org.springframework.web.context.ContextLoaderServlet</li><li>org.springframework.web.context.ContextLoaderListener</li></ul><p>二者内部都实现了启动WebApplicationContext实例的逻辑，只需根据Web容器的具体情况选择其一并在web.xml中完成配置即可。</p><p><strong>WebApplicationContext同样需要日志功能，可以将Log4J配置文件放置在类路径&#x2F;WEB-INF&#x2F;classes下以便启动Log4J引擎。或在web.xml文件指定自定义的配置文件位置。</strong></p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP是一种编程思想。<br>日志、安全、事务管理、缓存等，在软件系统中都是非常重要的功能，但它们与软件本身所关注的“功能”即业务逻辑，从概念上讲（应该）是分离的，然而它们散布嵌入在业务逻辑之中，需要在业务逻辑功能执行的过程中被动地触发。这些功能通常被称为横切关注点（cross-cutting concern）。把这些横切关注点与业务逻辑相分离就是面向切面编程（AOP，Aspect Oriented Programming），实现横切关注点与它们所影响的对象之间的解耦。<br>重用通用功能的方案一般为继承或委托，而切面是另一种实现该目标的方案。在使用面向切面编程时，仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以合何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。有两个好处：</p><ol><li>每个关注点都集中在一个地方，而不是分散在多处代码中；</li><li>服务模块更加简洁，因为它们都只包含主要关注点（核心功能）的代码，而次要关注的代码被转移到切面中。</li></ol><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><h3 id="增强-advice"><a href="#增强-advice" class="headerlink" title="增强 advice"></a>增强 advice</h3><p>切面的工作被称为增强。<br>增强定义了切面是什么以及何时使用（what and when）。除了描述切面要完成的工作，增强还解决了何时执行这个工作的问题：它应该应用在某个方法被调用之前、之后还是只在方法抛出异常时，等。<br>Spring切面支持5种类型的增强：</p><ol><li>前置增强（Before）：在目标方法被调用之前调用增强功能；</li><li>后置增强（After）：在目标方法完成之后调用增强，此时不会关心方法的输出是什么；</li><li>环绕增强（Around）：在被增强方法调用前后都执行自定义的行为；</li><li>返回增强（After-returning）：在目标方法成功执行之后调用增强；</li><li>异常增强（After-throwing）：在目标方法抛出异常之后调用增强。</li></ol><h3 id="连接点-join-point"><a href="#连接点-join-point" class="headerlink" title="连接点 join point"></a>连接点 join point</h3><p>应用增强的时机，被称为连接点。连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、甚至修改一个字段时，切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><h3 id="切点-pointcut"><a href="#切点-pointcut" class="headerlink" title="切点 pointcut"></a>切点 pointcut</h3><p>增强定义了切面的“what”和“when”，切点定义了切面的“where”，切点的定义会匹配增强所要织入的一个或多个连接点。通常使用明确的类和方法名，或利用正则表达式定义所匹配的类和方法名来指定这些切点。</p><h3 id="切面-aspect"><a href="#切面-aspect" class="headerlink" title="切面 aspect"></a>切面 aspect</h3><p>切面是增强和切点的结合。增强和切点共同定义了切面的全部内容——它是什么，在何时何处完成其功能。 </p><h3 id="引入-introduction"><a href="#引入-introduction" class="headerlink" title="引入 introduction"></a>引入 introduction</h3><p>引入允许向现有的类添加新方法或属性，从而在无需修改现有类的情况下，让这些类具有新的行为和状态。是一种特殊的增强。</p><h3 id="织入-weaving"><a href="#织入-weaving" class="headerlink" title="织入 weaving"></a>织入 weaving</h3><p>把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li></ul><h2 id="Spring中的AOP"><a href="#Spring中的AOP" class="headerlink" title="Spring中的AOP"></a>Spring中的AOP</h2><p>AOP框架在连接点模型上有强弱之分，比如有些允许在字段修饰符级别应用增强，有些只支持与方法调用相关的连接点。此外，框架织入切面的方式和时机也有所不同。但无论如何，<strong>创建切点来定义切面所织入的连接点是AOP框架的基本功能。</strong></p><p>Spring提供4种类型的AOP支持：</p><ul><li>基于代理的经典Spring AOP（现在来看笨重且复杂）；</li><li>纯POJO切面（需要xml配置）；</li><li>@AspectJ注解驱动的切面（本质上依然是基于代理的AOP）；</li><li>注入式AspectJ切面（基本的方法调用级别切面满足不了需求时）。</li></ul><p>前三种都是Spring AOP实现的变体。Spring AOP构建在<strong>动态代理</strong>基础之上，因此，Spring对AOP的支持局限于方法拦截。</p><h3 id="运行时增强对象"><a href="#运行时增强对象" class="headerlink" title="运行时增强对象"></a>运行时增强对象</h3><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理类封装了目标类，拦截被增强方法的调用，再把调用转发给真正的目标bean。即代理类处理方法的调用，执行额外的切面逻辑，并调用目标方法。<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdn.net/20160505123413155" class="lozad post-image"src="https://img-blog.csdn.net/20160505123413155"><br>Spring运行时才创建代理对象。</p><h3 id="切点类型"><a href="#切点类型" class="headerlink" title="切点类型"></a>切点类型</h3><p>Spring提供6种类型的切点：</p><ul><li>静态方法切点：org.springframework.aop.support.StaticMethodMatcherPointcut是静态方法切点的抽象基类，默认情况下它可以匹配所有的类。包含两个主要的子类：NameMatchMethodPointcut &amp; AbstractRegexpMethodPointcut，前者提供简单的字符串匹配方法签名，后者使用正则表达式匹配方法签名；</li><li>动态方法切点：org.springframework.aop.support.DynamicMethodMatcherPointcut是动态方法切点的抽象基类，默认情况下匹配所有的类；</li><li>注解切点：org.springframework.aop.support.annotation.AnnotationMatchingPointcut的实现类表示注解切点，支持在Bean中直接通过java5.0注解标签定义的切点；</li><li>表达式切点：org.springframework.aop.support.ExpressionPointcut接口主要是为了支持AspectJ切点表达式语法而定义的接口；</li><li>流程切点：org.springframework.aop.support.ControlFlowPointcut实现类表示控制流程切点。ControlFlowPointcut是一类特殊的切点，它根据程序执行堆栈的信息查看目标方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间件</title>
      <link href="//cs/mw/"/>
      <url>//cs/mw/</url>
      
        <content type="html"><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p><strong>re</strong>mote <strong>di</strong>ctionary <strong>s</strong>erver, redis, 是一个开源的内存中的数据结构存储系统，它可以用作：<strong>数据库、缓存和消息中间件</strong>。采用 <strong>单进程单线程</strong> 方式运行。<br>Redis 支持多种类型的数据结构，如字符串（Strings），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。<br><a href="https://www.runoob.com/mw/redis-intro.html">redis 教程</a></p><h2 id="查询速度"><a href="#查询速度" class="headerlink" title="查询速度"></a>查询速度</h2><p>Redis 采用基于内存的、单进程单线程模型的 KV 数据库，由 C 语言编写。官方提供的数据是可以达到 100000+ 的 QPS（每秒内查询次数）。</p><h2 id="高效查询的原因"><a href="#高效查询的原因" class="headerlink" title="高效查询的原因"></a>高效查询的原因</h2><ul><li>纯内存操作，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</li><li>数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>使用多路 I&#x2F;O 复用模型，非阻塞 IO；</li><li>底层模型不同，Redis 直接构建了专用的 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li></ul><h2 id="单线程的问题"><a href="#单线程的问题" class="headerlink" title="单线程的问题"></a>单线程的问题</h2><p>首先要明确，这里单线程是指，Redis 只使用一个线程来处理网络请求，而一个 Redis Server 处于运行状态时还是有多个线程的，比如用于持久化的子线程&#x2F;子进程。此外，进入 4.0 版本后，某些操作上开始支持多线程执行，不排除后续版本将整个服务都采用多线程的可能。<br><strong>显然，单线程无法发挥多核的优势，通常在单机开启多个 Redis 实例以充分利用多核环境资源</strong>。<br><a href="https://mp.weixin.qq.com/s/hCNUqpQAQI4Vu3HRi9ZKnA">为什么说Redis是单线程的</a></p><h2 id="基于-Key-Value-的-NoSQL-内存数据库"><a href="#基于-Key-Value-的-NoSQL-内存数据库" class="headerlink" title="基于 Key-Value 的 NoSQL 内存数据库"></a>基于 Key-Value 的 NoSQL 内存数据库</h2><p>也称数据结构服务器。<br>特点和优势：</p><ul><li>支持数据的持久化，可以将内存中的数据持久化到磁盘中，重启时再次加载使用；</li><li>不仅支持简单的 key-value 类型数据，同时还提供 list、set、zset、hash 等数据结构的存储；</li><li>支持数据备份，即 master-slave 模式的数据备份；</li><li>性能极高：读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s；</li><li>丰富的数据类型，提供了5种数据结构：String、List、Hash、Set、Ordered Set（ZSet）；</li><li>原子操作：Redis 的所有操作都是原子性的，同时还支持对几个操作全并后的原子性执行；</li><li>丰富的特性：支持 publish&#x2F;subscribe、通知 key 过期等特性。</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><img src="/cs/mw/mw/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B.JPG" class title="5种数据结构类型" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/mw/mw/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B.JPG" class="lozad post-image"><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>类似于其他编程语言中字符串的概念。<br>redis 中的 string 类型是二进制安全的，i.e. 可以包含任何数据，比如一张 .jpg 格式的图片。一个键最大存储量为 512 MB。</p><img src="/cs/mw/mw/string.JPG" class title="字符串" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/mw/mw/string.JPG" class="lozad post-image"><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>按照插入顺序有序存储多个字符串，相同元素可重复，双向操作（LPHSH、LPOP、RPUSH、RPOP）。<br>每个 list 最多存储元素数量：2^32 - 1。</p><img src="/cs/mw/mw/list.JPG" class title="列表" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/mw/mw/list.JPG" class="lozad post-image"><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>集合和列表都可以存储多个字符串，不同之处在于：列表可以存储多个相同的字符串，集合通过 <strong>散列表来保证存储的每个字符串都是不相同的</strong>。<br>redis 的集合使用无序（unordered）方式存储元素，不支持像列表一样将元素从某一端 push&#x2F;pop 的操作，相应地，使用 SADD&#x2F;SREM 添加&#x2F;移除元素。由于是通过哈希表实现的，所以添加&#x2F;移除&#x2F;查找的时间复杂度为 O(1)。<br>每个 set 最多存储元素数量：2^32 - 1。</p><img src="/cs/mw/mw/set.JPG" class title="集合" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/mw/mw/set.JPG" class="lozad post-image"><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>可以存储多个键值对之间的映射。<strong>官方推荐：尽可能使用hash存储数据。</strong><br>每个 hash 最多存储键值对数量：2^32 - 1。</p><img src="/cs/mw/mw/hash.JPG" class title="散列" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/mw/mw/hash.JPG" class="lozad post-image"><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>有序集合（zset）和散列一样，都用于存储键值对，不支持重复元素。不同之处在于：有序集合的键被称为成员（member），每个成员都是各不相同的；值被称为分值（score），必须为浮点数（分值可重复）。zset 既可以根据成员访问元素（和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。<br>每个 zset 最多存储键值对数量：2^32 - 1。<br><img src="/cs/mw/zset.JPG" alt="有序集合" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/mw/zset.JPG" class="lozad post-image"></p><h2 id="use-case"><a href="#use-case" class="headerlink" title="use case"></a>use case</h2><h3 id="作为分布式锁"><a href="#作为分布式锁" class="headerlink" title="作为分布式锁"></a>作为分布式锁</h3><p>分布式锁至少要满足三个属性要求：  </p><ul><li>安全方面（Safety property）：互斥。在任一时刻，只有一个client可以获取锁；</li><li>活性A（Liveness property）：无死锁。即便持有锁的client崩溃（crashed)或者网络被分裂（gets partitioned)，锁仍然可以被获取；</li><li>活性B（Liveness property）：容错。只要多数Redis节点活着，client就可以获取和释放锁。</li></ul><p>参见 <a href="https://redis.io/topics/distlock">redlock</a></p><h3 id="作为LRU缓存"><a href="#作为LRU缓存" class="headerlink" title="作为LRU缓存"></a>作为LRU缓存</h3><p>redis提供多种key淘汰机制：  </p><ul><li>noeviction: 不淘汰，当超过内存限制，抛出异常；</li><li>allkeys-lru: 在所有键中，选取最近最少使用的数据抛弃；</li><li>volatile-lru: 在设置了过期时间的所有键中，选取最近最少使用的数据抛弃；</li><li>allkeys-random: 在所有键中，随机抛弃；</li><li>volatile-random: 在设置了过期时间的所有键中，随机抛弃；</li><li>volatile-ttl: 在设置了过期时间的所有键中，抛弃存活时间最短的数据；<br><em>4.0 新增：</em></li><li>allkeys-lfu: 在所有键中，选取使用频率最少的数据抛弃；</li><li>volatile-lfu: 在设置了过期时间的所有键中，选取使用频率最少的数据抛弃；</li></ul><h2 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h2><p>redis提供不同的持久化选项：  </p><ul><li>RDB: 在指定的时间间隔内将内存中的数据集快照写入磁盘；</li><li>AOF(append only file): 将server接收到的每个操作日志以追加的方式写入文件；</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>6.0版本开始支持多线程。</p>]]></content>
      
      
      <categories>
          
          <category> mw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mw </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
