<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="懒懒懒蜗牛🐌">
  <link 
    rel="icon" 
    href="/img/little-prince.png">
  <title>spring</title>
  
    
      <meta 
        property="og:title" 
        content="spring">
    
    
      <meta 
        property="og:url" 
        content="https://lazy-snail.github.io/2018/06/03/spring/index.html">
    
    
      <meta 
        property="og:img" 
        content="/img/little-prince.png">
    
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2018-06-03">
      <meta 
        property="og:article:modified_time" 
        content="2022-06-29">
      <meta 
        property="og:article:author" 
        content="Neil">
      
        
          <meta 
            property="og:article:tag" 
            content="java">
        
      
    
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
      
      
      
      
        
        
        
        <script>
          function prismThemeChange() {
            if(document.getElementById('theme-color').dataset.mode === 'dark') {
              if(document.querySelector('[data-prism]')) {
                changeCSS('/js/lib/prism/prism-tomorrow.min.css', '[data-prism]', 'prism-tomorrow');
              } else {
                loadCSS('/js/lib/prism/prism-tomorrow.min.css', 'prism', 'prism-tomorrow');
              }
            } else {
              if(document.querySelector('[data-prism]')) {
                changeCSS('/js/lib/prism/prism.min.css', '[data-prism]', 'prism');
              } else {
                loadCSS('/js/lib/prism/prism.min.css', 'prism', 'prism');
              }
            }
          }
          prismThemeChange()
        </script>
      
      
        
        <link rel="stylesheet" href="/js/lib/prism/prism-line-numbers.min.css">
      
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
        prismThemeChange();
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
        prismThemeChange();
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
        prismThemeChange();
      }
    };
    setDarkmode();
    </script>
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
    
    <link rel="prefetch" href="//cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-svg.js" as="script">
  
  
  
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
<meta name="generator" content="Hexo 6.1.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
        <img 
          class="navbar-logo-img"
          width="32"
          height="32"
          src="/img/little-prince.png" 
          alt="blog logo">
      
      <span class="navbar-logo-dsc">懒蜗牛</span>
    </span>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          Home
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          Archive
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          Tags
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          Categories
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          About
        
      </a>
    
    <a 
      class="navbar-menu-item darknavbar" 
      id="dark">
      <i class="iconfont icon-weather"></i>
    </a>
    <a 
      class="navbar-menu-item searchnavbar" 
      id="search">
      <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i>
    </a>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      spring
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2018-06-03T07:15:38.000Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2018-06-03</span>
    </time>
    
      <span class="dot"></span>
      
        <a 
          href="/categories/java/" 
          class="post-meta-link">
          java
        </a>
      
    
    
      <span class="dot"></span>
      <span>8.4k words</span>
    
  </div>
  
    <div 
      class="post-meta post-show-meta" 
      style="margin-top: -10px;">
      <div style="display: flex; align-items: center;">
        <i 
          class="iconfont icon-biaoqian" 
          style="margin-right: 2px; font-size: 1.15rem;">
        </i>
        
          
          <a 
            href="/tags/java/" 
            class="post-meta-link">
            java
          </a>
        
      </div>
    </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <h1 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h1><p>包括Bean、Context、Core。<br><img src="/2018/06/03/spring/overview.png" alt="overview" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/overview.png" class="lozad post-image"></p>
<h2 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h2><p>spring的核心思想常常被称作BOP(Bean Oriented Programming)，面向Bean编程。Bean模块解决以下问题：</p>
<ol>
<li>bean的定义；</li>
<li>bean的创建；</li>
<li>bean的解析；</li>
</ol>
<p>作为业务开发通常只需要关心bean的创建，其他两个过程由spring内部完成。<br>Bean的整体架构是典型的工厂模式，最上层的接口是BeanFactory。ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBean是其子类，目的是为了区分Spring内部对象处理和转化的数据限制：<br>ListableBeanFactory: 表示这些Bean是可列表的，定义bean的集合；<br>HierarchicalBeanFactory: 表示这些Bean有继承关系，定义bean的关系；<br>AutowireCapableBeanFactory: 定义Bean的自动装配规则，定义bean的行为；<br><img src="/2018/06/03/spring/BeanFactory-hierarchy.png" alt="BeanFactory-hierarchy" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/BeanFactory-hierarchy.png" class="lozad post-image"></p>
<p>bean定义，主要由BeanDefinition描述，成功解析后都会被转化为BeanDefinition对象，之后所有的操作都会在BeanDefinition对象之上进行。层次关系如下：<br><img src="/2018/06/03/spring/BeanDefinition-hierarchy.png" alt="BeanDefinition-hierarchy" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/BeanDefinition-hierarchy.png" class="lozad post-image"></p>
<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>Bean包装的是一个个Object，Object中存储着业务所需的数据。那么，如何给这些数据以及它们之间的关系提供生存、运行环境——即保存对象的状态，就是Context要解决的问题。Context就是bean关系的集合，即IoC容器。<br>ApplicationContext是Context最上层的接口，层次关系如下：<br><img src="/2018/06/03/spring/ApplicationContext-hierarchy.png" alt="ApplicationContext-hierarchy" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/ApplicationContext-hierarchy.png" class="lozad post-image"><br>ApplicationContext能够标识一个应用环境的基本信息，继承了5个接口，用于拓展Context的功能，其中BeanFactory用于创建Bean，同时继承了ResourceLoader接口，用于访问任何外部资源。<br>子类主要包括：</p>
<ul>
<li>ConfigurableApplicationContext: 可动态配置和修改信息的Context，其下AbstractRefreshableApplicationContext最为常用。</li>
<li>WebApplicationContext: 为Web应用准备的Context，可以直接访问ServletContext。</li>
</ul>
<p>作为Ioc容器，Context是Spring其他大部分功能的基础，ApplicationContext必须完成的功能包括：</p>
<ul>
<li>标识一个应用环境；</li>
<li>利用BeanFactory创建Bean对象；</li>
<li>保存对象关系表；</li>
<li>捕获各种事件。</li>
</ul>
<h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><p>Spring发现、建立和维护Bean之间关系的一系列工具，实际上就是各种util。</p>
<p>Resource：core最重要的组成部分，主要定义了资源的访问方式，所有资源都抽象到了Resource接口中，主要作用：</p>
<ul>
<li>资源包装。Resource向上继承了InputStreamSource接口，所有的资源都通过InputStream来获取，从而屏蔽了资源提供者；</li>
<li>资源加载。Resource下的ResourceLoader接口，所有资源加载者统一实现该接口就能加载所有的资源，例如之前的ApplicationContext。</li>
</ul>
<p>与Context建立关系：ApplicationContext通过ResourcePatternResolver接口与ResourceLoader进行交互，来进行资源的加载、解析和描述。ResourcePatternResolver将资源封装整合，便于其他模块使用。<br><img src="/2018/06/03/spring/ResourceLoader-ApplicationContext.png" alt="ResourceLoader-ApplicationContext" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/ResourceLoader-ApplicationContext.png" class="lozad post-image"></p>
<h1 id="IoC-容器结构"><a href="#IoC-容器结构" class="headerlink" title="IoC 容器结构"></a>IoC 容器结构</h1><p>Spring IoC容器用于创建并管理Spring Bean对象以及Bean属性注入。通过ResourceLoader&#x2F;Resolver读取Bean的配置文件并转换成统一资源对象（Resource），然后通过BeanDefinitionReader转换成pring内部对Bean的描述对象（BeanDefinition），然后将其注册（BeanRegister）到容器中（BeanFactory），供以后转换成Bean对象使用。spring项目源代码很好地把它们划分到了不同的模块中，即上面的三个模块。而从资源读取、描述对象转换、注册使用这些阶段，从源码中又可以抽出以下6个组件：</p>
<ul>
<li>资源组件：Resource，对资源文件的描述，不同资源文件如xml、properties文件等，格式不同，最终都将被ResourceLoader加载获得相应的Resource对象；</li>
<li>资源加载组件：ResourceLoader：加载xml、properties等各类格式文件，解析文件，并生成Resource对象；</li>
<li>Bean容器组件：BeanFactory体系，IoC容器的核心；</li>
<li>Bean注册组件：SingletonBeanRegister&#x2F;AliasRegister，将BeanDefinition对象注册到BeanFactory（BeanDefinition Map）中去；</li>
<li>Bean描述组件：BeanDefinition体系，Spring内部对Bean描述的基本数据结构；</li>
<li>Bean构造组件：BeanDefinitionReader体系，读取Resource并将其数据转换成一个个BeanDefinition对象。</li>
</ul>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p>如各类型的文件，二进制流数据都是资源，是Spring内部对资源的统一描述，整个体系类图网如下：<br><img src="/2018/06/03/spring/resource.png" alt="Resource" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/resource.png" class="lozad post-image"></p>
<h2 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h2><p>ResourceLoader&#x2F;Resolver体系，负责资源的加载，这里的资源指的是xml、properties等文件资源，返回一个对应类型的Resource对象。<br><img src="/2018/06/03/spring/ResourceLoader.png" alt="ResourceLoader" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/ResourceLoader.png" class="lozad post-image"></p>
<h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p>对bean对象描述的基本数据结构。<br><img src="/2018/06/03/spring/BeanDefinition.png" alt="BeanDefinition" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/BeanDefinition.png" class="lozad post-image"></p>
<h2 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h2><p>Bean构造组件，BeanDefinitionReader体系，将Resource对象，转换成BeanDefinition对象，就是将内部资源数据转换成Spring Bean描述数据。就是将统一资源数据对象读取转换成相应内部对象。<br><img src="/2018/06/03/spring/BeanDefinitionReader.png" alt="BeanDefinitionReader" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/BeanDefinitionReader.png" class="lozad post-image"></p>
<h2 id="SingletonBeanRegister-x2F-AliasRegister"><a href="#SingletonBeanRegister-x2F-AliasRegister" class="headerlink" title="SingletonBeanRegister&#x2F;AliasRegister"></a>SingletonBeanRegister&#x2F;AliasRegister</h2><p>Bean注册组件，将BeanDefinition对象注册到BeanFactory中。<br><img src="/2018/06/03/spring/BeanRegister.png" alt="BeanRegister" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/BeanRegister.png" class="lozad post-image"></p>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>Bean容器组件，整个IoC容器核心，所谓Bean容器，就是这里装着Bean对象以及所需要的各种数据。其中BeanFactory是纯粹的Bean容器，用来存储描述Bean，无关其他环境，而像ApplicationContext，也是Bean容器，但它和应用环境息息相关，所以被称为应用上下文（环境）更恰当，从图中也能看出来，ApplicationContext不仅有着BeanFactory“血统”，同时也继承了EnvironmentCapable、MessageSource、ApplicationEventPublisher，即扩展了其许多额外功能，而其实现类则是和具体应用相关。<br><img src="/2018/06/03/spring/BeanFactory-component.png" alt="BeanFactory" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/BeanFactory-component.png" class="lozad post-image"></p>
<h1 id="SpringBoot启动过程"><a href="#SpringBoot启动过程" class="headerlink" title="SpringBoot启动过程"></a>SpringBoot启动过程</h1><h1 id="请求处理过程"><a href="#请求处理过程" class="headerlink" title="请求处理过程"></a>请求处理过程</h1><p>以典型的web应用为例，一个请求从接收到返回的处理过程相当复杂，如下图所示，主要经过DispatcherServlet、HandlerMapping、Controller、ViewResolver、Model等：<br><img src="/2018/06/03/spring/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="request handle" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" class="lozad post-image"></p>
<ol>
<li>客户端请求提交到DispatcherServlet；</li>
<li>由DisPatcherServlet控制器寻找一个或多个HandlerMapping，找到处理请求的Controller；</li>
<li>DispatcherServlet将请求提交到Controller；</li>
<li>Controller调用业务逻辑处理后返回ModelAndView；</li>
<li>DispatcherServlet寻找一个或多个ViewResolver视图解析器，找到ModelAndView指定的视图；</li>
<li>视图负责将结果显示到客户端。</li>
</ol>
<p>Spring MVC所有的请求都经过DispatcherServlet来统一分发，在 DispatcherServlet将请求分发给Controller之前需要借助Spring MVC提供的 HandlerMapping定位到具体的Controller。<br>HandlerMapping接口负责完成客户请求到Controller映射。<br>Controller接口将处理用户请求，这和Java Servlet扮演的角色是一致的。一旦Controller处理完用户请求，将返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。<br>从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。<br>ViewResolver接口（视图解析器）在Web应用中负责查找View对象，从而将相应结果渲染给客户。</p>
<h1 id="过滤器和拦截器"><a href="#过滤器和拦截器" class="headerlink" title="过滤器和拦截器"></a>过滤器和拦截器</h1><p>这张图解释了典型spring应用常用组件及触发顺序：<br><img src="/2018/06/03/spring/request.png" alt="request handle" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/request.png" class="lozad post-image"><br>过滤器在请求进入容器之后、进入servlet之前就被触发，此时还没有进入spring的管辖范围。拦截器是spring提供并管理的，所以它能获取IoC容器信息，比如拿到容器里的bean。</p>
<p>这张图解释了常用组件具体方法的执行顺序：<br><img src="/2018/06/03/spring/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt="request handle" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class="lozad post-image"></p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>Filter是JavaEE中Servlet规范的一个组件，它可以在http请求到达Servlet之前，被N个Filter处理：<br><img src="/2018/06/03/spring/filter.webp" alt="request handle" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/filter.webp" class="lozad post-image"><br>过滤器的实现是基于函数回调。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>过滤敏感词汇（防止sql注入）</li>
<li>设置字符编码</li>
<li>URL级别的权限访问控制</li>
<li>压缩响应信息</li>
</ul>
<h2 id="interceptor"><a href="#interceptor" class="headerlink" title="interceptor"></a>interceptor</h2><p>用于拦截Controller方法的执行，可以在方法执行、后添加自定义逻辑，类似于AOP编程思想。其实现是基于反射机制——动态代理。</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>拦截器本质上是面向切面编程（AOP），符合横切关注点的功能都可以放在拦截器中来实现，主要的应用场景包括：</p>
<ul>
<li>登录验证，判断用户是否登录。</li>
<li>权限验证，判断用户是否有权限访问资源，如校验token</li>
<li>日志记录，记录请求操作日志（用户ip，访问时间等），以便统计请求访问量。</li>
<li>处理cookie、本地化、国际化、主题等。</li>
<li>性能监控，监控请求处理时长等。</li>
<li>通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现）</li>
</ul>
<h1 id="后处理器"><a href="#后处理器" class="headerlink" title="后处理器"></a>后处理器</h1><h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><h1 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h1><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497692">https://cloud.tencent.com/developer/article/1497692</a></p>
<h1 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h1><p>Spring容器中Bean的生命周期由多个特定的阶段组成，每个阶段都允许外界对Bean加以控制。在Spring中可以从两个层面定义Bean的生命周期：Bean的作用范围；实例化Bean时所经历的一系列阶段。</p>
<h2 id="文字描述"><a href="#文字描述" class="headerlink" title="文字描述"></a>文字描述</h2><ol>
<li><p>Bean容器在配置文件中找到Spring Bean的定义。</p>
</li>
<li><p>Bean容器使用Java Reflection API创建Bean的实例。</p>
</li>
<li><p>如果声明了任何属性，声明的属性会被设置。如果属性本身是Bean，则将对其进行解析和设置。<br>以上步骤见“spring IoC 源码解析”。</p>
</li>
<li><p>如果Bean类实现BeanNameAware接口，则将通过传递Bean的名称来调用setBeanName()方法。<br>如果Bean类实现BeanClassLoaderAware接口，则将通过传递加载此Bean的ClassLoader对象的实例来调用setBeanClassLoader()方法。<br>如果Bean类实现BeanFactoryAware接口，则将通过传递BeanFactory对象的实例来调用setBeanFactory()方法。<br>如果有任何与BeanFactory关联的BeanPostProcessors对象已加载Bean，则将在设置Bean属性之前调用postProcessBeforeInitialization()方法。<br>如果Bean类实现了InitializingBean接口，则在设置了配置文件中定义的所有Bean属性后，将调用afterPropertiesSet()方法。<br>如果配置文件中的Bean定义包含init-method属性，则该属性的值将解析为Bean类中的方法名称，并将调用该方法。<br>如果为Bean Factory对象附加了任何Bean 后置处理器，则将调用postProcessAfterInitialization()方法。<br>如果Bean类实现DisposableBean接口，则当Application不再需要Bean引用时，将调用destroy()方法。<br>如果配置文件中的Bean定义包含destroy-method属性，那么将调用Bean类中的相应方法定义。</p>
</li>
</ol>
<h2 id="BeanFactory中Bean的生命周期"><a href="#BeanFactory中Bean的生命周期" class="headerlink" title="BeanFactory中Bean的生命周期"></a>BeanFactory中Bean的生命周期</h2><p><img src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/Spring-Bean-LifeCycle.png" alt="Bean生命周期" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/Spring-Bean-LifeCycle.png" class="lozad post-image"><br>具体过程：</p>
<ol>
<li>当调用者通过getBean(beanName)向容器请求某一个Bean时，如果容器注册了org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor接口，则在实例化Bean之前，将调用接口的postProcessBeforeInstantiation()；</li>
<li>根据配置情况调用Bean构造方法或工厂方法实例化Bean；</li>
<li>如果容器注册了InstantiationAwareBeanPostProcessor接口，那么在实例化Bean之后，调用该接口的postProcessAfterInstantiation()，可在这里对已经实例化的对象进行一些“梳妆打扮”；</li>
<li>如果Bean配置了属性信息，那么容器在这一步着手将配置值设置到Bean对应的属性中，不过在设置每个属性之前将先调用InstantiationAwareBeanPostProcessor接口的postProcessPropertyValues()；</li>
<li>调用Bean的属性设置方法设置属性值；</li>
<li>如果Bean实现了org.springframework.beans.factory.BeanNameAware接口，则将调用setBeanName()，将配置文件中该Bean对应的名称设置到Bean中；</li>
<li>如果Bean实现了org.springframework.beans.factory.BeanFactoryAware接口，则将调用setBeanFactory()，将BeanFactory容器实例设置到Bean中；</li>
<li>如果BeanFactory装配了org.springframework.beans.factory.config.BeanPostProcessor后处理器，则将调用BeanPostProcessor的Object postProcessBeforeInitialization(Object bean, String beanName)对Bean进行加工操作。其中，入参bean是当前正在处理的bean，beanName时当前bean的配置名，返回的对象为加工处理后的Bean。可以使用该方法对Bean进行处理，甚至改变Bean的行为。BeanPostProcessor在Spring框架中占有重要地位，为容器提供对Bean进行后续加工处理的切入点，Spring容器所提供的各种“神奇功能”，如AOP，动态代理等，都是通过它来实施的；</li>
<li>如果Bean实现了InitializingBean接口，则将调用接口的afterPropertiesSet()；</li>
<li>如果在&lt;bean&gt;中通过init-method属性定义了初始化方法，则将执行这个方法；</li>
<li>BeanPostProcessor后处理器定义了两个方法：其一是postProcessBeforeInitialization()，在(8)步调用；其二是Object postProcessAfterInitialization(Object bean, String beanName)，这个方法在此时调用，容器再次获得对Bean进行加工处理的机会；</li>
<li>如果在&lt;bean&gt;中指定Bean的作用范围是scope&#x3D;”prototype”，则将Bean返回给调用者，调用者负责Bean后续生命周期的管理，Spring不再管理这个Bean的生命周期。如果将作用范围设置为scope&#x3D;”singleton”，则将Bean放入Spring IoC容器的缓存池中，并将Bean引用返回给调用者，Spring继续对这些Bean进行后续的生命管理；</li>
<li>对于scope&#x3D;”singleton”的Bean（默认情况），当容器关闭时，将触发Spring对Bean后续生命周期的管理工作。如果Bean实现了DisposableBean接口，则将调用接口的destory()，可以在此编写释放资源、记录日志等操作；</li>
<li>对于scope&#x3D;”singleton”的Bean，如果通过&lt;bean&gt;的destory-method属性指定了Bean的销毁方法，那么Spring将执行Bean的这个方法，完成Bean资源的释放等操作。</li>
</ol>
<p>Bean的完整生命周期从Spring容器着手实例化Bean开始，直到最终销毁Bean。其中经过了许多关键点，每个关键点都涉及特定的方法调用，可以将这些方法大致分为4类：</p>
<ul>
<li>Bean自身的方法：如调用Bean构造方法实例化Bean、调用setter设置Bean的属性值以及通过&lt;bean&gt;的init-method和destory-method所指定的方法；</li>
<li>Bean级生命周期接口方法：如BeanNameAware、BeanFactoryAware、InitializingBean和DisposableBean，这些接口方法由Bean类直接实现；</li>
<li>容器级生命周期接口方法：图示中⭐标识的步骤是由InstantiationAwareBeanPostProcessor和BeanPostProcessor这两个接口实现的，一般称它们的实现类为“后处理器”。后处理器接口一般不由Bean本身实现，它们独立于Bean，实现类以容器附加装置的形式注册到Spring容器中，并通过接口反射为Spring容器扫描识别。当Spring创建任何Bean的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的。也可以自行编写后处理器，让其仅对感兴趣的Bean进行加工处理；</li>
<li>工厂后处理器接口方法：包括AspectJWeavingEnabler、CustomAutowireConfigurer、ConfigurationClassPostProcessor等方法。工厂后处理器也是容器级的，在应用上下文装配配置文件后立即调用。</li>
</ul>
<h2 id="ApplicationContext中Bean的生命周期"><a href="#ApplicationContext中Bean的生命周期" class="headerlink" title="ApplicationContext中Bean的生命周期"></a>ApplicationContext中Bean的生命周期</h2><p>Bean在应用上下文中的生命周期和在BeanFactory中的生命周期类似，不同的是，如果Bean实现了org.springframework.context.ApplicationContextAware接口，则会增加一个调用接口方法setApplicationContext()的步骤。  </p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>Spring定义了多种作用域：</p>
<ul>
<li>单例（singleton），在整个应用中，只创建bean的一个实例。</li>
<li>原型（prototype），每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。</li>
<li>会话（session），在web应用中，为每个会话创建一个bean实例。</li>
<li>请求（request），在web应用中，为每个请求创建一个bean实例。</li>
</ul>
<p>默认情况下，Spring的所有bean都是单例（singleton）的。使用@Scope注解来选择其它作用域，它可与@Component、@Bean一起使用。两种方式（推荐1）：</p>
<p>1. </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span>SCOPE_PROTOTYPE<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AClass</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AClass</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">doGetBean</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
在xxxConfig类中使用@Bean注解声明bean时和上述方式相同。<br>会话和请求作用域，使用场景是web应用，从命名理解：会话作用域是指该bean的生命周期和一个会话的起始保持一致，比如典型的电商场景，用户登录，搜索商品，加入购物车，购买，付费，结束，这个流程就是一个完整的会话；请求作用域是指用户从发起一个请求开始，到服务器相应该请求的过程。这两种作用域的bean就是在该场景下，随着会话&#x2F;请求的生命周期实例化到销毁，典型的，如电商场景中的”购物车”。</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">BeanWrapper</span> <span class="token function">createBeanInstance</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">RootBeanDefinition</span> mbd<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// Make sure bean class is actually resolved at this point.</span>
	<span class="token comment">// 解析出 Class</span>
	<span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> beanClass <span class="token operator">=</span> <span class="token function">resolveBeanClass</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>beanClass <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isNonPublicAccessAllowed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span>
				<span class="token string">"Bean class isn't public, and non-public access not allowed: "</span> <span class="token operator">+</span> beanClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// 如果工厂方法不为空，则是用工厂方法初始化</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getFactoryMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>
		<span class="token comment">// 相关知识点看另一篇文章关于FactoryBean的</span>
		<span class="token keyword">return</span> <span class="token function">instantiateUsingFactoryMethod</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// Shortcut when re-creating the same bean...</span>
	<span class="token comment">// 如果不是第一次创建，比如第二次创建 prototype bean。</span>
	<span class="token comment">// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span>
	<span class="token comment">// 所以注释说叫shortcut</span>
	<span class="token keyword">boolean</span> resolved <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">boolean</span> autowireNecessary <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>args <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>constructorArgumentLock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>resolvedConstructorOrFactoryMethod <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token comment">// 有已经解析过的构造方法</span>
				resolved <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				autowireNecessary <span class="token operator">=</span> mbd<span class="token punctuation">.</span>constructorArgumentsResolved<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 如果已经解析过则使用解析好的构造方法不需要再次锁定</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>resolved<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>autowireNecessary<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token comment">// 构造方法自动注入</span>
			<span class="token keyword">return</span> <span class="token function">autowireConstructor</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			<span class="token comment">// 默认构造方法</span>
			<span class="token keyword">return</span> <span class="token function">instantiateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// Need to determine the constructor...</span>
	<span class="token comment">// 判断是否采用有参构造函数</span>
	<span class="token comment">// 构造器自动装配</span>
	<span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ctors <span class="token operator">=</span> <span class="token function">determineConstructorsFromBeanPostProcessors</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ctors <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span>
			mbd<span class="token punctuation">.</span><span class="token function">getResolvedAutowireMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">.</span>AUTOWIRE_CONSTRUCTOR <span class="token operator">||</span>
			mbd<span class="token punctuation">.</span><span class="token function">hasConstructorArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token class-name">ObjectUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token function">autowireConstructor</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> ctors<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// No special handling: simply use no-arg constructor.</span>
	<span class="token comment">// 使用无参构造器</span>
	<span class="token keyword">return</span> <span class="token function">instantiateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="BeanFactory-vs-FactoryBean"><a href="#BeanFactory-vs-FactoryBean" class="headerlink" title="BeanFactory vs FactoryBean"></a>BeanFactory vs FactoryBean</h1><p>首先，它们都是spring framework里比较顶层的接口：BeanFactory可以看做最简版的容器形式，也给具体的IOC容器实现提供规范，比如ApplicationContext；FactoryBean为IOC容器中的Bean创建提供更加灵活的方式，通过给Bean的实现加上一个简单的工厂模式和装饰器模式，使得对Bean的配置更加便捷灵活。<br>从另一个角度讲，两者都是工厂，FactoryBean本身也是一个Factory，并且归BeanFactory管理。</p>
<h2 id="BeanFactory-1"><a href="#BeanFactory-1" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>以Factory结尾的都是工厂类&#x2F;接口。它是IOC容器的核心接口，其职责包括：实例化、定位、配置应用程序中的对象，以及建立这些对象间的依赖。FactoryBean只是一个接口，并非IOC容器的具体实现，但spring给出了很多种实现：ApplicationContext、DefaultListableBeanFactory、AnnotationConfigApplicationContext等。<br>其中AnnotationConfigApplicationContext是目前构建具体应用很常用的一个，它实现将以注解方式描述组成应用的对象和对象间的依赖关系。AnnotationConfigApplicationContext类将持有注解配置的所有元数据信息，并用这些元数据构建一个完全可配置的系统或应用。<br>再如，ApplicationContext，派生自BeanFactory，仍然是一个接口，但它提供一种更面向框架的方式工作，并且对上下文进行分层和实现继承关系。同时它还派生自MessageSource、ApplicationEventPublisher、HierarchicalBeanFactory、ResourcePatternResolver等接口，从而扩充了以下能力：</p>
<ul>
<li>MessageSource, 提供国际化的消息访问;</li>
<li>资源访问，如URL和文件;</li>
<li>事件传播;</li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层;</li>
</ul>
<p>其他各种BeanFactory的子接口、子类也都是扩展了某种功能的类工厂，用于特定场景。</p>
<h3 id="主要方法："><a href="#主要方法：" class="headerlink" title="主要方法："></a>主要方法：</h3><p><img src="/2018/06/03/spring/BeanFactory.png" alt="BeanFactory methods" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/BeanFactory.png" class="lozad post-image"></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>从IOC容器中获取Bean(byName or byType)</li>
<li>检索IOC容器中是否包含指定的Bean</li>
<li>判断Bean是否为单例</li>
</ul>
<h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p>首先它是一个Bean，用于生产&#x2F;修饰其他Bean的工厂Bean，表现为一个工厂的职责，主要用到工厂模式、装饰器模式。通常情况下，spring容器担任工厂的角色，但也存在一些场景，比如某些Bean实例化过程复杂，需要配置大量信息，此时可以提供一个FactoryBean，用它来实现定制化的Bean实例化逻辑。FactoryBean接口对于Spring框架来说有着重要地位，自身就提供了70多个FactoryBean的实现。</p>
<h3 id="主要方法：-1"><a href="#主要方法：-1" class="headerlink" title="主要方法："></a>主要方法：</h3><p><img src="/2018/06/03/spring/FactoryBean.png" alt="BeanFactory methods" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2018/06/03/spring/FactoryBean.png" class="lozad post-image"></p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>FactoryBean在Spring中最为典型的一个应用就是用来创建AOP的代理对象。AOP实际上是Spring在运行时创建了一个代理对象，也就是说这个对象是在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说，AOP代理对象通过Java的<strong>反射机制</strong>，在运行时创建了一个代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——ProxyFactoryBean。</p>
<h1 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h1><p>Inversion of Control，控制反转，也称依赖注入（DI，Dependency Injection）。应用对象之间的解耦。<br>通常所讨论的依赖注入是将一个bean的引用注入到另一个bean的属性或构造器参数中，即将一个对象与另一个对象关联起来。java的反射是实现依赖注入的底层技术。依赖注入是Spring容器的内核，AOP、声明式事务等功能也都基于此。<br>Spring是一种容器框架，它帮助完成类的初始化和装配工作，让开发者从这些底层实现类的实例化、依赖关系装配等工作中解脱出来，专注于业务逻辑的开发工作。它通过配置文件或注解描述类和类之间的依赖关系，利用java的反射功能实例化Bean并建立Bean之间的依赖关系，自动完成类的初始化和依赖注入工作。此外，Spring还提供Bean实例缓存、生命周期管理、Bean实例代理、事件发布、资源装载等高级服务。<br>BeanFactory(com.springframework.beans.factory.BeanFactory)是Spring框架最核心的接口，它提供了高级IoC的配置机制。BeanFactory使管理不同类型的java对象成为可能，应用上下文(com.springframework.context.ApplicationContext)建立在BeanFactory基础之上，提供了更多面向应用的功能，如i18n和框架事件体系等，更易于创建实际应用。一般称BeanFactory为IoC容器，称ApplicationContext为应用上下文，有时也称后者为Spring容器。用途上，BeanFactory是Spring框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都可以直接使用ApplicationContext而非底层的BeanFactory。</p>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>如果说BeanFactory是Spring的”心脏“，那么ApplicationContext就是完整的”身躯“。ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置的方式实现。<br>ApplicationContext的主要实现类是ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，前者默认从类路径加载配置文件，后者默认从文件系统中装载配置文件。<br><img src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/ApplicationContext-hierarchy.png" alt="ApplicationContext类体系结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/ApplicationContext-hierarchy.png" class="lozad post-image"><br>可见，除继承HierarchicalBeanFactory和ListableBeanFactory接口外，ApplicationContext还通过多个其它接口扩展BeanFactory的功能：</p>
<ul>
<li>ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了ApplicationListener事件监听接口的Bean可以接收到容器事件，并对事件进行响应处理。在ApplicationContext抽象实现类AbstractApplicationContext中存在一个ApplicationEventMulticaster，它负责保存所有的监听器，以便在容器产生上下文事件时通知这些事件监听者；</li>
<li>MessageSource：为应用提供i18n国际化消息访问的功能；</li>
<li>ResourcePatternResolver：所有ApplicationContext实现类都实现了类似于PathMatchingResourcePatternResolver的功能，可以通过带前缀的ant风格的资源文件路径装载Spring配置文件；</li>
<li>LifeCycle：提供start()、和stop()，主要用于控制异步处理过程。在具体使用时，该接口同时被ApplicationContext实现以及具体Bean实现，ApplicationContext会将start&#x2F;stop的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度等目的。</li>
</ul>
<p>ConfigurableApplicationContext扩展于ApplicationContext，它新增了两个主要方法：refresh()、close()，使得ApplicationContext具有启动、刷新、关闭应用上下文的能力。在应用上下文关闭的情况下可以调用refresh()即可启动应用上下文，在已经启动的状态下调用refresh()则可清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利，但作为开发者并不需要过多关心它们。  </p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>和BeanFactory初始化类似，如果配置文件放在类路径下，优先考虑使用ClassPathXmlApplicationContext实现；如果放在文件系统路径下，则优先考虑FileSystemXmlApplicationContext实现。也可以指定一组配置文件，Spring会完成自动整合。<br>获取ApplicationContext实例后，就可以像BeanFactory一样调用getBean(beaName)返回bean了。而ApplicationContext的初始化和BeanFactory有一个很大区别：后者在初始化容器时，并未初始化所有的Bean，直到第一次访问某个Bean时才实例化该目标Bean；而ApplicationContext则在初始化应用上下文时就实例化所有单实例的Bean。因此，ApplicationContext的初始化时间会比BeanFactory稍长。<br>Spring支持基于类注解的配置方式，主要功能来自JavaConfig的子项目。一个标注了@Configuration注解的POJO即可提供Spring所需的Bean配置信息。而且Spring为基于注解类的配置专门提供了ApplicationContext实现类：AnnotationConfigApplicationContext，可以直接调用方法实例化Bean，启动容器并装配Bean。</p>
<h2 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h2><p>WebApplicationContext是专门为Web应用准备的，它允许从相对于Web根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext中可以获得ServletContext的引用，整个Web应用上下文对象将作为属性放置到ServletContext中，以便Web应用环境可以访问Spring应用上下文。Spring专门为此提供了一个工具类WebApplicationContextUtils，通过该类的getWebApplicationContext(ServletContext sc)，可以从ServletContext中获取WebApplicationContext实例。<br>在非Web应用的环境下，Bean只有singleton、prototype两种作用域。WebApplicationContext为Bean添加了三个新的作用域：request、session、global session。<br><img src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/WebApplicationContext-hierarchy.png" alt="WebApplicationContext类体系结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/lazy-snail/ImageHosting/master/wiki/WebApplicationContext-hierarchy.png" class="lozad post-image"><br>ConfigurableWebApplicationContext扩展了WebApplicationContext，它允许通过配置的方式实例化WebApplicationContext，同时定义了两个重要方法：</p>
<ul>
<li>setServletContext(ServletContext servletContext)：为Spring设置Web应用上下文，以便二者整合；</li>
<li>setConfigLocations(String[] configLocations)：设置Spring配置文件地址，一般是相对于Web根目录的地址，如&#x2F;WEB-INF&#x2F;xxx-dao.xml、&#x2F;WEB-INF&#x2F;xxx-service.xml。用户也可以使用带资源类型前缀的地址，如classpath:com&#x2F;baidu&#x2F;beans.xml等。</li>
</ul>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>WebApplicationContext的初始化方式和BeanFactory、ApplicationContext有所区别，因为需要ServletContext实例。即必须在拥有Web容器的前提下才能完成启动工作，可以在web.xml中配置自启动的Servlet或定义Web容器监听器(ServletContextListener)，二者均可完成启动Spring Web应用上下文的工作。Spring为二者均提供了支持：</p>
<ul>
<li>org.springframework.web.context.ContextLoaderServlet</li>
<li>org.springframework.web.context.ContextLoaderListener</li>
</ul>
<p>二者内部都实现了启动WebApplicationContext实例的逻辑，只需根据Web容器的具体情况选择其一并在web.xml中完成配置即可。</p>
<p><strong>WebApplicationContext同样需要日志功能，可以将Log4J配置文件放置在类路径&#x2F;WEB-INF&#x2F;classes下以便启动Log4J引擎。或在web.xml文件指定自定义的配置文件位置。</strong></p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP是一种编程思想。<br>日志、安全、事务管理、缓存等，在软件系统中都是非常重要的功能，但它们与软件本身所关注的“功能”即业务逻辑，从概念上讲（应该）是分离的，然而它们散布嵌入在业务逻辑之中，需要在业务逻辑功能执行的过程中被动地触发。这些功能通常被称为横切关注点（cross-cutting concern）。把这些横切关注点与业务逻辑相分离就是面向切面编程（AOP，Aspect Oriented Programming），实现横切关注点与它们所影响的对象之间的解耦。<br>重用通用功能的方案一般为继承或委托，而切面是另一种实现该目标的方案。在使用面向切面编程时，仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以合何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。有两个好处：</p>
<ol>
<li>每个关注点都集中在一个地方，而不是分散在多处代码中；</li>
<li>服务模块更加简洁，因为它们都只包含主要关注点（核心功能）的代码，而次要关注的代码被转移到切面中。</li>
</ol>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><h3 id="增强-advice"><a href="#增强-advice" class="headerlink" title="增强 advice"></a>增强 advice</h3><p>切面的工作被称为增强。<br>增强定义了切面是什么以及何时使用（what and when）。除了描述切面要完成的工作，增强还解决了何时执行这个工作的问题：它应该应用在某个方法被调用之前、之后还是只在方法抛出异常时，等。<br>Spring切面支持5种类型的增强：</p>
<ol>
<li>前置增强（Before）：在目标方法被调用之前调用增强功能；</li>
<li>后置增强（After）：在目标方法完成之后调用增强，此时不会关心方法的输出是什么；</li>
<li>环绕增强（Around）：在被增强方法调用前后都执行自定义的行为；</li>
<li>返回增强（After-returning）：在目标方法成功执行之后调用增强；</li>
<li>异常增强（After-throwing）：在目标方法抛出异常之后调用增强。</li>
</ol>
<h3 id="连接点-join-point"><a href="#连接点-join-point" class="headerlink" title="连接点 join point"></a>连接点 join point</h3><p>应用增强的时机，被称为连接点。连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、甚至修改一个字段时，切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<h3 id="切点-pointcut"><a href="#切点-pointcut" class="headerlink" title="切点 pointcut"></a>切点 pointcut</h3><p>增强定义了切面的“what”和“when”，切点定义了切面的“where”，切点的定义会匹配增强所要织入的一个或多个连接点。通常使用明确的类和方法名，或利用正则表达式定义所匹配的类和方法名来指定这些切点。</p>
<h3 id="切面-aspect"><a href="#切面-aspect" class="headerlink" title="切面 aspect"></a>切面 aspect</h3><p>切面是增强和切点的结合。增强和切点共同定义了切面的全部内容——它是什么，在何时何处完成其功能。 </p>
<h3 id="引入-introduction"><a href="#引入-introduction" class="headerlink" title="引入 introduction"></a>引入 introduction</h3><p>引入允许向现有的类添加新方法或属性，从而在无需修改现有类的情况下，让这些类具有新的行为和状态。是一种特殊的增强。</p>
<h3 id="织入-weaving"><a href="#织入-weaving" class="headerlink" title="织入 weaving"></a>织入 weaving</h3><p>把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入：</p>
<ul>
<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>
</ul>
<h2 id="Spring中的AOP"><a href="#Spring中的AOP" class="headerlink" title="Spring中的AOP"></a>Spring中的AOP</h2><p>AOP框架在连接点模型上有强弱之分，比如有些允许在字段修饰符级别应用增强，有些只支持与方法调用相关的连接点。此外，框架织入切面的方式和时机也有所不同。但无论如何，<strong>创建切点来定义切面所织入的连接点是AOP框架的基本功能。</strong></p>
<p>Spring提供4种类型的AOP支持：</p>
<ul>
<li>基于代理的经典Spring AOP（现在来看笨重且复杂）；</li>
<li>纯POJO切面（需要xml配置）；</li>
<li>@AspectJ注解驱动的切面（本质上依然是基于代理的AOP）；</li>
<li>注入式AspectJ切面（基本的方法调用级别切面满足不了需求时）。</li>
</ul>
<p>前三种都是Spring AOP实现的变体。Spring AOP构建在<strong>动态代理</strong>基础之上，因此，Spring对AOP的支持局限于方法拦截。</p>
<h3 id="运行时增强对象"><a href="#运行时增强对象" class="headerlink" title="运行时增强对象"></a>运行时增强对象</h3><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理类封装了目标类，拦截被增强方法的调用，再把调用转发给真正的目标bean。即代理类处理方法的调用，执行额外的切面逻辑，并调用目标方法。<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdn.net/20160505123413155" class="lozad post-image"src="https://img-blog.csdn.net/20160505123413155"><br>Spring运行时才创建代理对象。</p>
<h3 id="切点类型"><a href="#切点类型" class="headerlink" title="切点类型"></a>切点类型</h3><p>Spring提供6种类型的切点：</p>
<ul>
<li>静态方法切点：org.springframework.aop.support.StaticMethodMatcherPointcut是静态方法切点的抽象基类，默认情况下它可以匹配所有的类。包含两个主要的子类：NameMatchMethodPointcut &amp; AbstractRegexpMethodPointcut，前者提供简单的字符串匹配方法签名，后者使用正则表达式匹配方法签名；</li>
<li>动态方法切点：org.springframework.aop.support.DynamicMethodMatcherPointcut是动态方法切点的抽象基类，默认情况下匹配所有的类；</li>
<li>注解切点：org.springframework.aop.support.annotation.AnnotationMatchingPointcut的实现类表示注解切点，支持在Bean中直接通过java5.0注解标签定义的切点；</li>
<li>表达式切点：org.springframework.aop.support.ExpressionPointcut接口主要是为了支持AspectJ切点表达式语法而定义的接口；</li>
<li>流程切点：org.springframework.aop.support.ControlFlowPointcut实现类表示控制流程切点。ControlFlowPointcut是一类特殊的切点，它根据程序执行堆栈的信息查看目标方法</li>
</ul>

  </div>
  <div>
    
      <div 
        class="post-note note-warning copyright" 
        style="margin-top: 42px">
        <p>
          <span style="font-weight: bold;">作者：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="/about">
            Neil
          </a>
        </p>
        <p>
          <span style="font-weight: bold;">文章链接：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="https://lazy-snail.github.io/2018/06/03/spring/">
            https://lazy-snail.github.io/2018/06/03/spring/
          </a>
        </p>
        <p><span style="font-weight: bold;">版权声明：</span>转载请注明出处</p>
      </div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2018/06/03/os/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">Prev</div>
          
            <div class="nav-title">os </div>
          
        </div>
      </a>
    </div>
  
  
    <div class="nav-item-next">
      <a 
        href="/2018/03/29/algs/" 
        class="nav-link">
        <div>
          <div class="nav-label">Next</div>
          
            <div class="nav-title">algs </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">1.</span> <span class="toc-text">核心模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bean"><span class="toc-number">1.1.</span> <span class="toc-text">bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#context"><span class="toc-number">1.2.</span> <span class="toc-text">context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#core"><span class="toc-number">1.3.</span> <span class="toc-text">core</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IoC-%E5%AE%B9%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">IoC 容器结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource"><span class="toc-number">2.1.</span> <span class="toc-text">Resource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceLoader"><span class="toc-number">2.2.</span> <span class="toc-text">ResourceLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinition"><span class="toc-number">2.3.</span> <span class="toc-text">BeanDefinition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinitionReader"><span class="toc-number">2.4.</span> <span class="toc-text">BeanDefinitionReader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SingletonBeanRegister-x2F-AliasRegister"><span class="toc-number">2.5.</span> <span class="toc-text">SingletonBeanRegister&#x2F;AliasRegister</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory"><span class="toc-number">2.6.</span> <span class="toc-text">BeanFactory</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">SpringBoot启动过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">请求处理过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">过滤器和拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#filter"><span class="toc-number">5.1.</span> <span class="toc-text">filter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.1.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#interceptor"><span class="toc-number">5.2.</span> <span class="toc-text">interceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">后处理器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">监听器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">8.</span> <span class="toc-text">三级缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.</span> <span class="toc-text">bean生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E6%8F%8F%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">文字描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.2.</span> <span class="toc-text">BeanFactory中Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.3.</span> <span class="toc-text">ApplicationContext中Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">9.4.</span> <span class="toc-text">作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BeanFactory-vs-FactoryBean"><span class="toc-number">10.</span> <span class="toc-text">BeanFactory vs FactoryBean</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory-1"><span class="toc-number">10.1.</span> <span class="toc-text">BeanFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">10.1.1.</span> <span class="toc-text">主要方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.1.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FactoryBean"><span class="toc-number">10.2.</span> <span class="toc-text">FactoryBean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%9A-1"><span class="toc-number">10.2.1.</span> <span class="toc-text">主要方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">10.2.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IoC"><span class="toc-number">11.</span> <span class="toc-text">IoC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext"><span class="toc-number">11.1.</span> <span class="toc-text">ApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">11.1.1.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebApplicationContext"><span class="toc-number">11.2.</span> <span class="toc-text">WebApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">11.2.1.</span> <span class="toc-text">初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AOP"><span class="toc-number">12.</span> <span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">12.1.</span> <span class="toc-text">相关术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA-advice"><span class="toc-number">12.1.1.</span> <span class="toc-text">增强 advice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%82%B9-join-point"><span class="toc-number">12.1.2.</span> <span class="toc-text">连接点 join point</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%82%B9-pointcut"><span class="toc-number">12.1.3.</span> <span class="toc-text">切点 pointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E9%9D%A2-aspect"><span class="toc-number">12.1.4.</span> <span class="toc-text">切面 aspect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-introduction"><span class="toc-number">12.1.5.</span> <span class="toc-text">引入 introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%87%E5%85%A5-weaving"><span class="toc-number">12.1.6.</span> <span class="toc-text">织入 weaving</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84AOP"><span class="toc-number">12.2.</span> <span class="toc-text">Spring中的AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A2%9E%E5%BC%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.2.1.</span> <span class="toc-text">运行时增强对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.2.2.</span> <span class="toc-text">切点类型</span></a></li></ol></li></ol></li></ol>
</div></main>
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="/img/little-prince.png" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">Neil</p>
<p class="author-description">there's a will there's a way</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>8</span>
    <span>Posts</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>6</span>
    <span>Categories</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>6</span>
    <span>Tags</span>
  </a>
</div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">1.</span> <span class="toc-text">核心模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bean"><span class="toc-number">1.1.</span> <span class="toc-text">bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#context"><span class="toc-number">1.2.</span> <span class="toc-text">context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#core"><span class="toc-number">1.3.</span> <span class="toc-text">core</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IoC-%E5%AE%B9%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">IoC 容器结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource"><span class="toc-number">2.1.</span> <span class="toc-text">Resource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceLoader"><span class="toc-number">2.2.</span> <span class="toc-text">ResourceLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinition"><span class="toc-number">2.3.</span> <span class="toc-text">BeanDefinition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinitionReader"><span class="toc-number">2.4.</span> <span class="toc-text">BeanDefinitionReader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SingletonBeanRegister-x2F-AliasRegister"><span class="toc-number">2.5.</span> <span class="toc-text">SingletonBeanRegister&#x2F;AliasRegister</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory"><span class="toc-number">2.6.</span> <span class="toc-text">BeanFactory</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">SpringBoot启动过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">请求处理过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">过滤器和拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#filter"><span class="toc-number">5.1.</span> <span class="toc-text">filter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.1.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#interceptor"><span class="toc-number">5.2.</span> <span class="toc-text">interceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">后处理器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">监听器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">8.</span> <span class="toc-text">三级缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.</span> <span class="toc-text">bean生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E6%8F%8F%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">文字描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.2.</span> <span class="toc-text">BeanFactory中Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.3.</span> <span class="toc-text">ApplicationContext中Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">9.4.</span> <span class="toc-text">作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BeanFactory-vs-FactoryBean"><span class="toc-number">10.</span> <span class="toc-text">BeanFactory vs FactoryBean</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory-1"><span class="toc-number">10.1.</span> <span class="toc-text">BeanFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">10.1.1.</span> <span class="toc-text">主要方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.1.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FactoryBean"><span class="toc-number">10.2.</span> <span class="toc-text">FactoryBean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%9A-1"><span class="toc-number">10.2.1.</span> <span class="toc-text">主要方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">10.2.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IoC"><span class="toc-number">11.</span> <span class="toc-text">IoC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext"><span class="toc-number">11.1.</span> <span class="toc-text">ApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">11.1.1.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebApplicationContext"><span class="toc-number">11.2.</span> <span class="toc-text">WebApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">11.2.1.</span> <span class="toc-text">初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AOP"><span class="toc-number">12.</span> <span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">12.1.</span> <span class="toc-text">相关术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA-advice"><span class="toc-number">12.1.1.</span> <span class="toc-text">增强 advice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%82%B9-join-point"><span class="toc-number">12.1.2.</span> <span class="toc-text">连接点 join point</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%82%B9-pointcut"><span class="toc-number">12.1.3.</span> <span class="toc-text">切点 pointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E9%9D%A2-aspect"><span class="toc-number">12.1.4.</span> <span class="toc-text">切面 aspect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-introduction"><span class="toc-number">12.1.5.</span> <span class="toc-text">引入 introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%87%E5%85%A5-weaving"><span class="toc-number">12.1.6.</span> <span class="toc-text">织入 weaving</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84AOP"><span class="toc-number">12.2.</span> <span class="toc-text">Spring中的AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A2%9E%E5%BC%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.2.1.</span> <span class="toc-text">运行时增强对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.2.2.</span> <span class="toc-text">切点类型</span></a></li></ol></li></ol></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>Categories
  </div>
  <div class="categories-list">
    
      <a href="/categories/algs/">
        <div class="categories-list-item">
          algs
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/java/">
        <div class="categories-list-item">
          java
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/mw/">
        <div class="categories-list-item">
          mw
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/cn/">
        <div class="categories-list-item">
          cn
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/db/">
        <div class="categories-list-item">
          db
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/os/">
        <div class="categories-list-item">
          os
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>hot tags
  </div>
  <div class="tags-list">
    
      <a 
        href="/tags/algs/" 
        title="algs">
        <div class="tags-list-item">algs</div>
      </a>
    
      <a 
        href="/tags/java/" 
        title="java">
        <div class="tags-list-item">java</div>
      </a>
    
      <a 
        href="/tags/mw/" 
        title="mw">
        <div class="tags-list-item">mw</div>
      </a>
    
      <a 
        href="/tags/cn/" 
        title="cn">
        <div class="tags-list-item">cn</div>
      </a>
    
      <a 
        href="/tags/db/" 
        title="db">
        <div class="tags-list-item">db</div>
      </a>
    
      <a 
        href="/tags/os/" 
        title="os">
        <div class="tags-list-item">os</div>
      </a>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">1.</span> <span class="toc-text">核心模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bean"><span class="toc-number">1.1.</span> <span class="toc-text">bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#context"><span class="toc-number">1.2.</span> <span class="toc-text">context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#core"><span class="toc-number">1.3.</span> <span class="toc-text">core</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IoC-%E5%AE%B9%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">IoC 容器结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource"><span class="toc-number">2.1.</span> <span class="toc-text">Resource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceLoader"><span class="toc-number">2.2.</span> <span class="toc-text">ResourceLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinition"><span class="toc-number">2.3.</span> <span class="toc-text">BeanDefinition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinitionReader"><span class="toc-number">2.4.</span> <span class="toc-text">BeanDefinitionReader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SingletonBeanRegister-x2F-AliasRegister"><span class="toc-number">2.5.</span> <span class="toc-text">SingletonBeanRegister&#x2F;AliasRegister</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory"><span class="toc-number">2.6.</span> <span class="toc-text">BeanFactory</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">SpringBoot启动过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">请求处理过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">过滤器和拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#filter"><span class="toc-number">5.1.</span> <span class="toc-text">filter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.1.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#interceptor"><span class="toc-number">5.2.</span> <span class="toc-text">interceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">后处理器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">监听器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">8.</span> <span class="toc-text">三级缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.</span> <span class="toc-text">bean生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E6%8F%8F%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">文字描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.2.</span> <span class="toc-text">BeanFactory中Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.3.</span> <span class="toc-text">ApplicationContext中Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">9.4.</span> <span class="toc-text">作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BeanFactory-vs-FactoryBean"><span class="toc-number">10.</span> <span class="toc-text">BeanFactory vs FactoryBean</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory-1"><span class="toc-number">10.1.</span> <span class="toc-text">BeanFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">10.1.1.</span> <span class="toc-text">主要方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.1.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FactoryBean"><span class="toc-number">10.2.</span> <span class="toc-text">FactoryBean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%9A-1"><span class="toc-number">10.2.1.</span> <span class="toc-text">主要方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">10.2.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IoC"><span class="toc-number">11.</span> <span class="toc-text">IoC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext"><span class="toc-number">11.1.</span> <span class="toc-text">ApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">11.1.1.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebApplicationContext"><span class="toc-number">11.2.</span> <span class="toc-text">WebApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">11.2.1.</span> <span class="toc-text">初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AOP"><span class="toc-number">12.</span> <span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">12.1.</span> <span class="toc-text">相关术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA-advice"><span class="toc-number">12.1.1.</span> <span class="toc-text">增强 advice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%82%B9-join-point"><span class="toc-number">12.1.2.</span> <span class="toc-text">连接点 join point</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%82%B9-pointcut"><span class="toc-number">12.1.3.</span> <span class="toc-text">切点 pointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E9%9D%A2-aspect"><span class="toc-number">12.1.4.</span> <span class="toc-text">切面 aspect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-introduction"><span class="toc-number">12.1.5.</span> <span class="toc-text">引入 introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%87%E5%85%A5-weaving"><span class="toc-number">12.1.6.</span> <span class="toc-text">织入 weaving</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84AOP"><span class="toc-number">12.2.</span> <span class="toc-text">Spring中的AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A2%9E%E5%BC%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.2.1.</span> <span class="toc-text">运行时增强对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.2.2.</span> <span class="toc-text">切点类型</span></a></li></ol></li></ol></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>Recent Posts
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2018-06-03</div>
        <a href="/2018/06/03/cn/"><div class="recent-posts-item-content">cn</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2018-06-03</div>
        <a href="/2018/06/03/cs/"><div class="recent-posts-item-content">cs</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2018-06-03</div>
        <a href="/2018/06/03/db/"><div class="recent-posts-item-content">db</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2018-06-03</div>
        <a href="/2018/06/03/java/"><div class="recent-posts-item-content">java</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2017 -
          
          2022
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          懒蜗牛
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
      <div class="footer-dsc">
        
        
        
      </div>
      
    
</footer> 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
      

  
  
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
      };
    </script>
    
<script src="//cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-svg.js"></script>

  
 
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
    
      <script> 
        loadScript('/js/lib/busuanzi.min.js') 
      </script>
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
     
    
    
      <script>
        setTimeout(() => {localSearch("search.json")}, 0)
      </script>
    
  </body>
</html>
