<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="懒懒懒蜗牛🐌">
  <link 
    rel="icon" 
    href="/img/little-prince.png">
  <title>database</title>
  
    
      <meta 
        property="og:title" 
        content="database">
    
    
      <meta 
        property="og:url" 
        content="https://lazy-snail.github.io/cs/db/index.html">
    
    
      <meta 
        property="og:img" 
        content="/img/little-prince.png">
    
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2022-07-17">
      <meta 
        property="og:article:modified_time" 
        content="2022-07-17">
      <meta 
        property="og:article:author" 
        content="Neil">
      
        
          <meta 
            property="og:article:tag" 
            content="db">
        
      
    
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
      
      
      
      
        
        
        
        <script>
          function prismThemeChange() {
            if(document.getElementById('theme-color').dataset.mode === 'dark') {
              if(document.querySelector('[data-prism]')) {
                changeCSS('/js/lib/prism/prism-tomorrow.min.css', '[data-prism]', 'prism-tomorrow');
              } else {
                loadCSS('/js/lib/prism/prism-tomorrow.min.css', 'prism', 'prism-tomorrow');
              }
            } else {
              if(document.querySelector('[data-prism]')) {
                changeCSS('/js/lib/prism/prism.min.css', '[data-prism]', 'prism');
              } else {
                loadCSS('/js/lib/prism/prism.min.css', 'prism', 'prism');
              }
            }
          }
          prismThemeChange()
        </script>
      
      
        
        <link rel="stylesheet" href="/js/lib/prism/prism-line-numbers.min.css">
      
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
        prismThemeChange();
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
        prismThemeChange();
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
        prismThemeChange();
      }
    };
    setDarkmode();
    </script>
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
    
    <link rel="prefetch" href="//cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-svg.js" as="script">
  
  
  
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
<meta name="generator" content="Hexo 6.1.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
        <img 
          class="navbar-logo-img"
          width="32"
          height="32"
          src="/img/little-prince.png" 
          alt="blog logo">
      
      <span class="navbar-logo-dsc">懒蜗牛</span>
    </span>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          Home
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          Archive
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          Tags
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          Categories
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          About
        
      </a>
    
    <a 
      class="navbar-menu-item darknavbar" 
      id="dark">
      <i class="iconfont icon-weather"></i>
    </a>
    <a 
      class="navbar-menu-item searchnavbar" 
      id="search">
      <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i>
    </a>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      database
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2022-07-16T18:25:55.988Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2022-07-17</span>
    </time>
    
      <span class="dot"></span>
      
        <a 
          href="/categories/db/" 
          class="post-meta-link">
          db
        </a>
      
    
    
      <span class="dot"></span>
      <span>17.3k words</span>
    
  </div>
  
    <div 
      class="post-meta post-show-meta" 
      style="margin-top: -10px;">
      <div style="display: flex; align-items: center;">
        <i 
          class="iconfont icon-biaoqian" 
          style="margin-right: 2px; font-size: 1.15rem;">
        </i>
        
          
          <a 
            href="/tags/db/" 
            class="post-meta-link">
            db
          </a>
        
      </div>
    </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h2><p>多数博客会用“书的目录”作解释，这是个很好的例子，为小白科普CS常识的时候可以用。<br>作为开发可以从另一个角度理解：假设我们有100w行单列的数据，比如人名，如何提高“找到特定名字”的效率呢？简单直接地，我们想到的是树结构来存储，比如最熟悉的BST，它的查找效率非常高，lg(n)级别的查询次数，百万数据的也只需要20次左右，但是考虑到数据是持久化到存储介质的，和内存、CPU存在巨大的执行速度的差异，20次依然太多了。继续优化的方向并没有转变，专门为数据库而设计的各种B-tree应运而生，简单理解就是，从原来的二分，所需数据在左侧或者右侧，改为比如，按首字母序，分为26块，所需数据肯定在26中的某一块，这样一次查找就可以把范围缩小到数据量的1&#x2F;26。<br>其他诸如平衡性、B树到B+树、聚簇&#x2F;非聚簇、聚集&#x2F;非聚集（注意和前一组不同）等概念，也都是在此基础上，结合软硬件特性所提出来的“优化手段”。（这里未讨论hash索引、位图索引、全文索引等特殊场景下的特殊方案。）</p>
<h2 id="为什么要有索引"><a href="#为什么要有索引" class="headerlink" title="为什么要有索引"></a>为什么要有索引</h2><p><em>上面这段话好像没有说明白为啥要有索引，我直接对100w数据排序到硬盘不就行了？</em><br>直接排序在单列数据当然是可行的，且操作效率也都很高。问题是数据库（问这个问题的应该回去重学数据库）表有很多字段，如果表只有一个索引，自然可以这样做。如果想添加两个&#x2F;多个索引，又不能同时按照两种方式对数据进行排序，比如一个关于姓名的索引和一个电话号码索引，这种情况就无法排序。将索引从数据行中整体分离出来，就可以创建多个索引，并且不需要对原始数据排序，但搜索过程即先在索引中找到对应值，然后根据匹配的记录找到对应的数据行。此外，索引行数据通常比表里的数据行更短，插入&#x2F;删除值时，为保持排序顺序，来回移动较短的索引值，比来回移动较长的数据行更加容易。</p>
<p><strong>IO 设备是计算机系统的瓶颈</strong><br><strong>索引是数据库中用来优化查询速度的最为重要的技术手段。</strong></p>
<h1 id="常用索引类型"><a href="#常用索引类型" class="headerlink" title="常用索引类型"></a>常用索引类型</h1><h2 id="B-索引"><a href="#B-索引" class="headerlink" title="B+索引"></a>B+索引</h2><p>首先从大家默认的MySQL数据库默认的InnoDB存储引擎默认的用户创建索引类型说起：B+索引。它是目前关系型数据库系统中查找最为常用和最为有效的索引（大概是InnoDB团队自己说的）。<br>B+索引的发展和演变过程就是上面提到的那样，就是B-tree的一类变种。</p>
<p>这就不可避免地要继续延伸索引的发展史了，从BST开始，因缺乏社交活动而时间精力异常充沛的程序员（中的大神）们尝试了很多索引方案，<strong>BST</strong> 很快显露出其不仅仅在作为索引上的短板：最差性能是线性的；于是新的轮子–<strong>AVL</strong> 诞生了，它解决了平衡性的问题，把一棵树塞得满满的，新的问题又来了：维护平衡的代价太高，继续造轮子——<strong>RBT（红黑树）</strong>，这棵树已经非常优秀了，被广泛应用于STL、linux进程调度、IO多路复用（epoll）、nginx、java TreeMap等；看上去拿来作索引的底层数据结构也挺好，很快新的问题又来了：还是反复提到的，硬盘这个猪队友的速度实在太拖后腿，以至于这么优秀的轮子依然不能用，百万量级就需要20多次磁盘访问，这之间巨大的数据鸿沟是第一段内容提到的，具体就是至少为纳秒与毫秒的差距。具体可以看下这里：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24726196">让 CPU 告诉你硬盘和网络到底有多慢</a></p>
<h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h3><p>B-tree就是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，每个内节点有多个分支)。<br><img src="/cs/db/B-tree.png" alt="B-tree" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/B-tree.png" class="lozad post-image"><br>B-tree已经具有了“有效降低磁盘查询次数”的特点，具有 <strong>高扇出性</strong> 的特点，一般高度在 2-4 层，意即查找某一键值的行记录最多只需要 2-4 次 I&#x2F;O。并且具有以下特点：</p>
<ol>
<li>定义任意非叶子结点最多只有M个儿子，且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M&#x2F;2, M]；</li>
<li>每个结点存放至少M&#x2F;2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li>
<li>非叶子结点的关键字个数&#x3D;指向儿子的指针个数-1；</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li>
<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>
<li>所有叶子结点位于同一层；</li>
</ol>
<p>它最终慢慢退出，或者说新的更合适的B+索引取而代之的原因是：<strong>B-tree在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题</strong>。在数据库中基于范围的查询是非常频繁的，而B-tree对于此类操作效率太低，因为它在节点中存储索引和数据，而数据域的存在导致B-tree一次能够读入内存的数据范围减少（相比于只把索引读入内存），从而在”减少磁盘IO“这一关键优化上依然存在很大空间。B+索引也就是B-tree的基础上，解决了这一问题：把数据域转移到叶子节点，所有非叶子节点只保存索引。</p>
<h3 id="B-tree-1"><a href="#B-tree-1" class="headerlink" title="B+tree"></a>B+tree</h3><p>在B-tree的基础上进行改造，具有不同于后者的特性：</p>
<ol>
<li>非叶子节点的子树指针与关键字个数相同；</li>
<li>非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复)；</li>
<li>为所有叶子节点增加一个链指针；</li>
<li>所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)；</li>
<li>非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层；</li>
<li>更适合于文件系统；<br><img src="/cs/db/B+tree.png" alt="B+tree" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/B+tree.png" class="lozad post-image"></li>
</ol>
<p>B+tree的优点，也就是它更适合作索引数据结构的原因：</p>
<ol>
<li>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</li>
<li>B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
<li>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</li>
</ol>
<p><strong>B+ 树索引并不能找到一个给定键值的具体行，而是查找该行所在的页，然后通过把页读入内存，再在内存中进行查找，最后得到要查找的数据行</strong>。且可以进一步分为聚集索引（Clustered Index）和辅助索引（Secondary Index），叶子节点存放着所有的数据，不同之处是，叶子节点存放的是否是一整行的信息。</p>
<h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>按照每张表的主键构造一棵 B+ 树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点成为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同 B+ 树数据结构一样，每个数据页都通过一个双向链表来进行链接。由于实际的数据页只能按照一棵 B+ 树进行排序，因此每张表只能拥有一个聚集索引。查询优化器倾向于采用聚集索引，因为能够在叶子节点上直接找到数据，对于主键的排序查找和范围查找速度都非常快。聚集索引的存储并不是物理上连续的（维护成本将非常高），而是逻辑上连续的。</p>
<h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>叶子节点并不包含行记录的全部数据，除了包含键值以外，每个叶子节点的索引行中还包含了一个书签，用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来查找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后通过主键索引来找到一个完整的行记录。<br><em>例：如果在一棵高度为3的辅助索引树中查找数据，那么需要对这棵辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此共需要6次逻辑IO访问以得到最终的一个数据页。</em></p>
<h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><p>基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（Hash Code），哈希码是一个比较小的值，并且不同键值的行计算出来的哈希码是不同的。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。<br>MySQL中，只有 Memory 引擎显式支持哈希索引，也是 Memory 引擎表默认索引类型，并且支持非唯一哈希索引。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中，所以哈希索引适合于精确查找；InnoDB 引擎支持的哈希索引是自适应的，会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p>
<h2 id="位图索引（BitMap-BitMap-index）"><a href="#位图索引（BitMap-BitMap-index）" class="headerlink" title="位图索引（BitMap BitMap index）"></a>位图索引（BitMap BitMap index）</h2><p>建立B+树索引的条件：高选择性的列(后续内容）。对于低选择性的列（这里应该描述成：只有固定几个值可选的列）如性别、婚否等，位图索引可能是个好的选择：<br><img src="/cs/db/%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95.jpg" alt="位图索引" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95.jpg" class="lozad post-image"><br><strong>适用场景</strong></p>
<ul>
<li>只有几个固定值的列；</li>
<li>不会频繁更新；<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LBSer/p/3322630.html">位图索引原理</a></li>
</ul>
<h2 id="全文索引（Full-Text-Search-Index"><a href="#全文索引（Full-Text-Search-Index" class="headerlink" title="全文索引（Full-Text Search Index)"></a>全文索引（Full-Text Search Index)</h2><p><strong>将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。</strong><br><em>MyISAM支持全文索引，InnoDB 从 1.2.x 版本开始支持全文索引。Memory、NDB、Archive等不支持全文索引。</em></p>
<details>
  <summary>全文索引</summary>
    <p>
    
</p><h3 id="倒排索引技术"><a href="#倒排索引技术" class="headerlink" title="倒排索引技术"></a>倒排索引技术</h3><p>全文索引通常使用倒排索引（Inverted Index）来实现：在辅助表（Auxiliary Table）中存储了单词与单词自身在一个&#x2F;多个文档中所在位置之间的映射，这通常利用关联数组实现，有两种表现形式：</p>
<ul>
<li>Inverted File Index，表现形式为 {单词，单词所在文档 ID}；</li>
<li>Full Inverted Index，表现形式为{单词，（单词所在文档 ID，在具体文档中的位置1，位置2…）}<br>示例如下：<br><img src="/cs/db/%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%E7%A4%BA%E4%BE%8B.PNG" alt="全文索引" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%E7%A4%BA%E4%BE%8B.PNG" class="lozad post-image"></li>
</ul>
<h3 id="InnoDB-全文索引"><a href="#InnoDB-全文索引" class="headerlink" title="InnoDB 全文索引"></a>InnoDB 全文索引</h3><p>采用 Full Inverted Index 的方式，将（DocumentId， Position1, Position2…）视为一个 ilist。故在全文索引的表中，有两个列：word字段、ilist字段，并且在word字段上设有索引。此外，由于 InnoDB 在ilist字段中存放了 Position 信息，故可以进行 Proximity Search（MyISAM不支持该特性）。<br>为提高全文检索的<strong>并行性能</strong>，InnoDB中共有6张 Auxiliary Table，目前每张表根据 word 的 Latin 编码进行分区。Auxiliary Table 是存放在磁盘上的持久表。此外，还有一个 FTS Index Cache（全文检索索引缓存），用来提高全文检索的行能。它是一个红黑树结构，根据（word，ilist）进行排序。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li>每张表只能有一个全文索引的索引；</li>
<li>由多列组合而成的全文索引的索引列必须使用相同的字符集和排序规则；</li>
<li>不支持没有单词界定符（delimiter）的语言，如中、日、韩等语言。</li>
</ul>
<h3 id="相关性："><a href="#相关性：" class="headerlink" title="相关性："></a>相关性：</h3><p>在 WHERE 中使用 MATCH 函数，查询返回的结果是根据相关性（Relevance）进行降序排序的，即相关性最高的结果放在第一位，0表示没有任何相关性。计算条件：</p>
<ul>
<li>word是否在文档中出现；</li>
<li>word在文档中出现的次数；</li>
<li>word在索引列中的数量；</li>
<li>多少个文档包含该word。</li>
</ul>
<h3 id="BOOLEAN"><a href="#BOOLEAN" class="headerlink" title="BOOLEAN"></a>BOOLEAN</h3><p>全文检索可以使用 IN BOOLEAN MODE 修饰符，此时查询字符串的前后字符会有特殊的含义，如：</p>
<ul>
<li>+ word：表示word必须存在；</li>
<li>- word：表示word必须被排除；</li>
<li>@distance：可选，表示字符字节间距最大值；</li>
<li>&gt;：表示出现该词时增加相关性；</li>
<li>&lt;：表示出现该词时降低相关性；</li>
<li>*：表示以该词开头的单词，如lik*，可以是lik、like、likes…</li>
<li>“：表示短语；</li>
<li>~：表示允许出现该单词，但相关性为负</li>
<li>etc.</li>
</ul>
<h3 id="Query-Expansion"><a href="#Query-Expansion" class="headerlink" title="Query Expansion"></a>Query Expansion</h3><p>全文索引的扩展查询，通常在查询的关键词太短，用户需要 implied knowledge（隐含知识）时进行。如，对于单词 database 的查询，用户可能希望查询的不仅仅是 database 的文档，可能还指那些包含 MySQL、Oracle、DB2、RDBMS 等的单词，这时可以使用 Query Expansion 模式来开启全文索引的 implied knowledge。<br>通过在查询短语中添加 WITH QUERY EXPANSION 或 IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION 可以开启 blind query expansion（automatic relevance feedback）。该查询分为两个阶段：</p>
<ol>
<li>根据索引的单词进行全文索引查询；</li>
<li>根据第一阶段产生的分词再进行一次全文检索的查询。</li>
</ol>
<p>由于 Query Expansion 的全文检索可能带来许多非相关性的查询，因此在使用时需要非常谨慎。<br>    </p><p></p>
</details>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>之所以InnoDB等数据库、数据库引擎选择B+而非其他类型的索引作为默认索引类型，除了上述B+索引的优势外，B+索引天然支持范围查找，这也是大部分关系型数据库的场景。</p>
<h1 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h1><h2 id="哪些场景需要索引"><a href="#哪些场景需要索引" class="headerlink" title="哪些场景需要索引"></a>哪些场景需要索引</h2><p>承前，索引的出现是为了解决（大数据量）情况下的查询效率问题。</p>
<ol>
<li>根据前面说的sql执行顺序，可以确定第一条是否添加索引的判断依据：该列数据是不是出现在where后。</li>
<li>并非在所有的查询条件中出现的列都需要添加索引。对于添加 B+ 树索引的一般经验是，<strong>在访问表中很少一部分时考虑使用 B+ 树索引</strong>。<br>如果一个字段取值范围很广，重复出现较少，即属于高选择性字段，此时使用 B+ 树索引比较合适。否则，如性别、类型等字段，可取值范围很小（性别显然只能筛选 50%），即属于低选择性字段，此时不适合使用 B+ 树索引（适合使用前面说的位图索引）。事实上，在低选择性的字段上，即使建立了如 B 树索引，数据库可能也不会使用，而是仍然以全扫描（如果没有其他可用索引）的方式进行查找，因为此时使用这种索引可能反而降低性能。</li>
</ol>
<h2 id="哪些数据适合创建索引"><a href="#哪些数据适合创建索引" class="headerlink" title="哪些数据适合创建索引"></a>哪些数据适合创建索引</h2><ol>
<li><strong>为用于搜索、排序、分组的列创建索引，而对于用作输出显示的列不需要建立索引</strong>。<br>即，最佳索引候选列是出现在 WHERE、连接、ORDER BY、GROUP BY 子句中的列，而出现在 SELECT 关键字后面的输出列表里的列则不是很好的选择。<br><img src="/cs/db/%E7%B4%A2%E5%BC%95%E5%88%97%E9%80%89%E6%8B%A9.PNG" alt="索引列选择" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/%E7%B4%A2%E5%BC%95%E5%88%97%E9%80%89%E6%8B%A9.PNG" class="lozad post-image"></li>
<li><strong>认真考虑数据列基数</strong><br>列的基数（cardinality）是指它所容纳的所有非重复值的个数。相对于表的总行数来说，列的基数越大（也就是包含的唯一值越多，重复值越少，即上述的高选择性的列），使用索引的效果越好。</li>
<li><strong>选择合适的索引类型</strong><br>对于精确查找（使用 &#x3D;、&lt;&gt; 的查找），那么使用 MEMORY 的默认索引类型，即 hash 索引，可能效果更好：hash 的精确查找速度非常快，而对范围匹配表现欠佳；所以对于范围查找，使用 B+ 树类型的索引效果更好，InnoDB、MyISAM、MEMORY 等都支持 B 树索引。</li>
<li><strong>索引短小值</strong><br>应尽量选择较小的数据类型。如，当使用 MEDIUMINT 列便能够容纳所需要存储的数据时，就不要选用 BIGINT，如果值的长度都不会超过 25 个字符，那么就不要使用 CHAR(100)。短小的值可以提高索引的处理性能：<blockquote>
<p>短小的值操作更快，从而加快索引查找速度；<br>短小的值可以让索引更小，从而减少磁盘 I&#x2F;O；<br>对于短小的键值，键缓存里的索引块可以容纳更多的键值，也就可以在更少的磁盘 I&#x2F;O 下读取更多的索引块，从而提高找到键值的几率。</p>
</blockquote>
</li>
<li><strong>索引字符串值的前缀</strong><br>要对字符串列建立索引，应该尽可能指定前缀长度。如，对于一个 CHAR(200) 列，如果大多数值的前 10 个 或 20 个字符都是唯一的，那么就可以不用为整个列进行索引，而只为前 10 个或 20 个字符进行索引，这样可以节省大量的索引空间，而且能够加速查询；但只索引列的第一个字符恐怕不行，因为会导致索引无法获得大量的唯一值。</li>
<li><strong>不要建立过多的索引</strong><br>显然，索引的建立并非无代价的，要考虑对性能和存储的影响。过多的索引也会导致</li>
</ol>
<h3 id="辅助手段"><a href="#辅助手段" class="headerlink" title="辅助手段"></a>辅助手段</h3><p>为数据选择利于高效查询的数据类型。<br><strong>多用数字运算，少用字符串运算</strong><br>数字运算通常比字符串运算更快。尽可能使用数字表示数据，如以点记号表示的 IP 地址，可以采用 4 组数字依次存入 INT UNSIGNED，而非直接使用字符串，尽管更方便，但数字对数据操作更高效，且更加节省空间。<br><strong>把数据列声明为 NOT NULL</strong><br>这可以加快查询，因为查询处理期间不再需要检查该列的值是否可以为 NULL，也有利于编写更简洁的 sql 语句。如果必须考虑 NULL 的情况，也可以考虑默认值等方式。<br><strong>考虑使用 ENUM 列</strong><br>如果必须采用字符串的列，恰好其基数很小（差异值较少），可以考虑转用 ENUM 列，即内部实际上采用数字形式存储，从而获得数字运算的处理速度。<br><strong>使用 PROCEDURE ANALYSE()</strong><br>运行 PROCEDURE ANALYSE()，可以根据输出得出一些优化手段。<br><strong>整理表碎片</strong><br>对频繁修改的表，尤其是包含可变长数据列的表，往往会产生大量碎片，导致空间浪费。定期使用 OPTIMIZE TABLE，可以消除&#x2F;减少碎片化的 InnoDB、MyISAM 表的空间浪费，并有助于防止性能降低。适用于各存储引擎的碎片整理方式是：先用 mysqldump 转储表，再利用该转储文件重建之：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump db_name table_name <span class="token operator">></span> <span class="token keyword">dump</span><span class="token punctuation">.</span><span class="token keyword">sql</span>
mysql db_name <span class="token operator">&lt;</span> <span class="token keyword">dump</span><span class="token punctuation">.</span><span class="token keyword">sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>压缩数据</strong><br>把数据压缩到 BLOB 或 TEXT 列。使用 BLOB 或 TEXT 列来存储那些可以在应用程序中对其进行压缩和解压的数据，使之能够使用单个索引操作找出所有内容的目的。这种方法特别适用于存储那些难以用标准表数据结构表示的数据，或者会随时间变化的数据。<br><strong>把 BLOB 或 TEXT 列剥离处出来形成一个单独的表</strong><br>将 BLOB 或 TEXT 列单独存入一个附表，可以更好地管理原表里的数据</p>
<h2 id="如何使用索引"><a href="#如何使用索引" class="headerlink" title="如何使用索引"></a>如何使用索引</h2><p><strong>一个索引是否适合某个查询的“三星系统”</strong></p>
<ul>
<li>索引将相关的记录放到一起则获得一星；</li>
<li>索引中的数据顺序和查找中的排练顺序一致则获得二星；</li>
<li>索引中的列包含了查询中需要的全部列则获得三星。</li>
</ul>
<p><strong>利用最左前缀</strong><br>当创建包含 n 个列的复合索引时，实际上会创建 n 个索引，即相当于多个索引，因为索引中最左边的任意数据列集合都可以用于匹配各个行。这样的集合即为 <strong>最左前缀</strong>。<br>假设：多个列的复合索引中包含列：county、state、city，索引中行的排列顺序为 country&#x2F;state&#x2F;city。那么，行首先会按照 county&#x2F;state 顺序排序，然后按 country 顺序排序，这意味着，即使在查询中只指定了 county 值，或者只指定了 country 和 state 值，MySQL 也可以充分利用索引。因此，索引可用于搜索这些列组合：<br>country, state, city<br>country, state<br>country<br>对于没有包含最左前缀的搜索，如按照 state 或者 city 来搜索，MySQL 则无法使用该索引；而如果要所搜 country 和 city（索引的第 1、3 列，跳过第 2 列），那么索引能够找到与 country 匹配的行以缩小搜索范围，但无法继续用于 city 列。</p>
<h2 id="索引代价"><a href="#索引代价" class="headerlink" title="索引代价"></a>索引代价</h2><p>主要体现在索引导致的写操作效率降低和空间占用两方面。</p>
<h3 id="降低写操作效率"><a href="#降低写操作效率" class="headerlink" title="降低写操作效率"></a>降低写操作效率</h3><p>写入操作（插入、删除、更新等）同时需要更新索引，所以表上的索引越多，需要做出的索引修改操作越多。所以在写操作频繁的表中，需要一些优化措施。</p>
<h3 id="占用空间"><a href="#占用空间" class="headerlink" title="占用空间"></a>占用空间</h3><p>索引会占用磁盘空间，尤其在多个索引的表中，索引可能导致很快达到表大小上限，这跟具体存储引擎有关：</p>
<ul>
<li>InnoDB 中，使用独立表空间的表，索引 + 数据行有文件大小限制，受操作系统影响；使用系统表空间则所有表和索引共享同一个存储空间池，添加索引会使存储空间减少得很快，但总大小不受操作系统的影响，逻辑上可以配置多个文件，所以可以使用磁盘扩容表空间。</li>
<li>MyISAM 中，大量的索引可能导致索引文件比数据文件更快达到文件大小的上限。</li>
</ul>
<h3 id="B-x2F-B-树索引的限制"><a href="#B-x2F-B-树索引的限制" class="headerlink" title="B&#x2F;B+树索引的限制"></a>B&#x2F;B+树索引的限制</h3><ul>
<li>如果不是按照索引的最左列开始查找，则无法使用该索引；</li>
<li>不能跳过索引中的列。即，如果一个索引中含有三个列，则只有在使用了第一、二列的情况下，才能使用第三列；</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引查找。如果范围查询列值的数量有限，可以通过使用多个等于条件替代之。<br>etc.</li>
</ul>
<h2 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h2><ul>
<li>对于 MyISAM 表，其数据保留在数据文件中，索引值保留在索引文件中，即使用数据的物理位置引用被索引的行，并使用前缀压缩技术使得索引更小，一个表可以有多个索引，但它们都保存在同一个索引文件里。索引文件里的每个索引都由一组有序的关键字行构成，这组关键字行主要用于快速访问数据文件；</li>
<li>对于 InnoDB 表，默认情况下，只使用一个表空间，用于管理所有的 InnoDB 数据存储和索引存储，也可以修改配置，让它创建的每个表都有自己的表空间，但此时，给定表的数据和索引也同样保存在同一个表空间文件。同样地，InnoDB 将索引值当作一组有序值。InnoDB 存储引擎表是索引组织表，即表中数据按照主键顺序存放，即根据主键引用被索引的行。</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>事务（Transaction）</strong> 是数据库区别于文件系统的重要特性之一。事务会把数据库从一种一致状态转变为另一种一致状态：提交工作时，可以确保所有修改要么都被保存好了，要么都不保存。</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ul>
<li>原子性（Atomicity）：指数据库的事务是不可分割的工作单位，即事务中任何一个SQL语句执行失败，已经成功的部分也必须撤销，数据库会退到执行事务之前的状态；</li>
<li>一致性（Consistency）：指事务将数据库从一种一致状态转变为下一种一致状态，在事务开始前和结束后，数据库的完整性约束没有被破坏，如列值的唯一性等；</li>
<li>隔离性（Isolation）：也称并发控制（Concurrency Control）、可串行化（Serializability）、锁（Locking）等。要求每个读写事务的对象对其它事务的操作对象之间能够相互分离，即该事务提交前对其它事务都不可见，通常使用锁来实现。当前数据库系统都提供了一种粒度锁（Granular Lock）的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务的并发度；</li>
<li>持久性（Durability）：事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。持久性保证事务系统的高可靠性（High Reliability），但不能保证高可用性（High Availability）：_从事务本身的角度保证结果的永久性，但无法避免数据库本身的故障，如RAID卡损坏、自然灾害等_；</li>
</ul>
<p>_尽管理论上事务的定义需要满足这四个特性，但数据库厂商出于各种目的并不一定会完全遵循该准则_。</p>
<h1 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h1><p>从事务理论的角度来说，可以把事务分为以下几个类型：</p>
<h2 id="扁平事务（Flat-Transactions）"><a href="#扁平事务（Flat-Transactions）" class="headerlink" title="扁平事务（Flat Transactions）"></a>扁平事务（Flat Transactions）</h2><p>最简单的一种，也是实际生产环境中使用最为频繁的。所有操作都处于同一层次，由 BEGIN WORK 开始，由 COMMIT WORK &#x2F; ROLLBACK WORK 结束，其间的操作都是原子的——要么都执行，要么都回滚。是应用程序成为原子操作的基本组成模块。三种执行结果如下：</p>
<img src="/cs/db/db/flat-transaction.jpg" class title="三种结果" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/db/flat-transaction.jpg" class="lozad post-image">

<h2 id="带有保存点的扁平事务（Flat-Transactions-with-Savepoints）"><a href="#带有保存点的扁平事务（Flat-Transactions-with-Savepoints）" class="headerlink" title="带有保存点的扁平事务（Flat Transactions with Savepoints）"></a>带有保存点的扁平事务（Flat Transactions with Savepoints）</h2><p>允许事务执行过程中回滚到同一事务中较早的一个状态——某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（Savepoint）用来通知系统应该记住事务当前的状态，以便之后发生错误时，事务能回滚到保存点的状态。（扁平事务隐式在起始点设置一个保存点，即只能回滚到事务开始的状态）。保存点用 SAVE WORK 函数来建立。在发生系统崩溃时会丢失所有保存点，因为保存点是易失的（Volatile），而非持久的（Persistent），这意味着进行恢复时，事务需要从开始处重新执行而不能从最近的一个保存点继续执行。</p>
<img src="/cs/db/db/savepoint-transaction.jpg" class title="在事务中使用保存点" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/db/savepoint-transaction.jpg" class="lozad post-image">

<h2 id="链事务（Chained-Transactions）"><a href="#链事务（Chained-Transactions）" class="headerlink" title="链事务（Chained Transactions）"></a>链事务（Chained Transactions）</h2><p>可以看作保存点模式的一个变种。在提交事务时，释放不需要的数据对象（如事务所持有的锁），将必要的处理上下文隐式地传给下一个要开始的事务（提交事务操作和开始下一个事务操作将合并为一个原子操作）。这意味着，下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样：</p>
<img src="/cs/db/db/chained-transaction.jpg" class title="链事务工作方式" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/db/chained-transaction.jpg" class="lozad post-image">
<p>链事务的回滚仅限于当前事务，即只能恢复到最近一个保存点。</p>
<h2 id="嵌套事务（Nested-Transactions）"><a href="#嵌套事务（Nested-Transactions）" class="headerlink" title="嵌套事务（Nested Transactions）"></a>嵌套事务（Nested Transactions）</h2><p>层次结构框架，由一个顶层事务（top-level transaction）控制各个层次的事务，之下嵌套的事务称为子事务（subtransaction），其控制每一个局部的变换。</p>
<img src="/cs/db/db/nested-transaction.jpg" class title="嵌套事务的层次结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/db/nested-transaction.jpg" class="lozad post-image">
<p><strong>嵌套事务的定义</strong></p>
<ul>
<li>由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务；</li>
<li>处在叶节点的事务是扁平事务，但每个子事务从根到叶节点的距离可以不同；</li>
<li>位于根节点的事务称为顶层事务，其他事务为子事务。事务的前驱（predecessor）称为父事务（parent），下一层称为子事务（child）；</li>
<li>子事务既可以提交也可以回滚，但它的提交操作并不会马上生效，除非其父事务已经提交。因此，任何子事务都在顶层事务提交后才真正的提交；</li>
<li>树中的任意一个事务的回滚都会引起它的所有子事务一同回滚，因此，子事务仅保留 A、C、I 特性，不具有 D 的特性。</li>
</ul>
<p>在Moss的理论中，实际的工作是交由叶子节点完成的，即只有叶子节点的事务才能才能访问数据库、发送信息、获取其他类型的资源。而高层的事务仅负责逻辑控制，决定何时调用相关的子事务。即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务：</p>
<img src="/cs/db/db/%E6%A8%A1%E6%8B%9F.jpg" class title="保存点技术模拟嵌套事务" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/db/%E6%A8%A1%E6%8B%9F.jpg" class="lozad post-image">

<h2 id="分布式事务（Distributed-Transactions）"><a href="#分布式事务（Distributed-Transactions）" class="headerlink" title="分布式事务（Distributed Transactions）"></a>分布式事务（Distributed Transactions）</h2><p>通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）。<br>假如一个用户在 ATM 机上进行银行的转账操作，例如持卡人从招商银行存储卡转账 10000 元到工商银行的存储卡。这种情况下，可以将 ATM 机视为节点 A，招商银行的后台数据库视为节点 B，工商银行的后台数据库视为 C，这个转账的操作可分解为以下的步骤：</p>
<blockquote>
<ol>
<li>节点 A 发出转账命令</li>
<li>节点 B 执行存储卡中的余额减去 10000</li>
<li>节点 C 执行存储卡终端的余额增加 10000</li>
<li>节点 A 通知用户操作完成或者节点 A 通知用户操作失败</li>
</ol>
</blockquote>
<p>这里需要使用到分布式事务，因为节点 A 不能通过一台数据库就完成任务，其需要访问网络中两个节点的数据库，而在每个节点的数据库执行的实务操作又都是扁平的，对于分布式事务，其同样需要满足 ACID 特性，要么都发生，要么都失效。对于上述例子，如果 2、3 步中任何一个操作失败，都会导致整个分布式事务回滚，若非这样，结果不可预知。</p>
<p><strong>InnoDB 支持的事务类型</strong><br>InnoDB存储引擎支持扁平事务、带有保存点的事务、链事务、分布式事务。MySQL数据库、InnoDB存储引擎都不原生支持嵌套事务，可通过带有保存点的扁平事务来模拟串行的嵌套事务。注意，使用分布式事务时，InnoDB 的事务隔离级别必须设置为 SERIALIZABLE。</p>
<h1 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h1><p>事务的原子性、一致性、持久性通过数据库的 redo log 和 undo log 完成。redo log 称为重做日志，用来保证事务的原子性、持久性，undo log 用来保证事务的一致性。事务的隔离性由锁来实现。<br>_undo 不是 redo 的逆过程_。redo 和 undo 都可以看作是一种恢复操作，redo 恢复提交事务修改的页操作，undo 回滚行记录到某个特定版本：两者记录的内容不同，并且 redo 通常是物理日志，记录的是页的物理修改操作，undo 是逻辑日志，根据每行记录进行记录。</p>
<h2 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h2><p>重做日志记录了事务的行为，由两部分组成：内存中的重做日志缓冲（redo log buffer），易失的；重做日志文件（redo log file），持久的物理保存。都是以512字节的块进行存储：重做日志块（redo log block）。<br>通过 Force Log at Commit 机制实现事务的持久性，即当事务提交（commit）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的commit操作完成才算完成。这里的日志分为两部分：redo log 和 undo log。redo log 基本是顺序写的，在数据库运行时不需要对 redo log 的文件进行读取操作，undo log 是需要进行随机读写的。<br>为确保日志写入重做日志文件，重做日志缓冲写入文件系统缓存后，会进行一次fsync操作，以将缓冲写入磁盘文件，该同步操作的参数 innodb_flush_log_at_trx_commit 可以手动设置：</p>
<ul>
<li>1（默认）：事务提交时必须调用一次fsync操作；</li>
<li>0：事务提交时不调用fsync，而是放到 master thread 中完成（默认每秒调用一次）；</li>
<li>2：仅写入文件系统缓存，不进行fsync操作。宕机情况下会丢失未刷新到磁盘日志文件的那部分事务。</li>
</ul>
<h2 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h2><p>对事务进行回滚操作。与redo存放在重做日志文件中不同，undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment），位于共享表空间内。undo 是逻辑日志，只是将数据库逻辑地恢复到原来的样子，所有的修改都被逻辑地取消了：对于每个 INSERT，回滚执行一个 DELETE，相应的 DELETE、UPDATE也是同样执行一个相反的操作，将修改前的行放回去。<br>除了回滚操作，另一个作用是完成 MVCC：当拥护读取一行记录时，若该记录已经被其它事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读。<br>_uodo log 会产生 redo log，也就是 uodo log 的产生会伴随这 redo log 的产生，因为 undo log 也需要持久性的保护_。</p>
<p><strong>uodo log 格式</strong><br>InnoDB 中，undo log 分为：<br>insert undo log：在 INSERT 操作中产生的 undo log。因为 INSERT 操作记录只对本事务可见（隔离性的要求），对其它事务不可见，所以可以在事务提交后直接删除；<br>update undo log：在 DELETE、UPDATE 操作中产生的 undo log，该 undo log 需要提供 MVCC 机制，因此不能在事务提交时就删除，提交时放入 undo log 链表，等待 purge 线程进行最后的删除。</p>
<h2 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h2><p>用于最终完成 DELETE、UPDATE 操作。DELETE、UPDATE 操作可能不直接删除原有数据，可以仅将该行主键的 delete flag 设置为 1，行记录本身暂时不执行删除操作，而是延时到最终的 purge 操作中完成。这样设计是因为 InnoDB 支持 MVCC，所以记录不能在事务提交时立即进行处理。这时其它事务可能正在引用这行，故需要保存记录之前的版本。若该行记录已经不被任何其它事务引用，即可进行真正的删除操作。</p>
<h2 id="group-commit"><a href="#group-commit" class="headerlink" title="group commit"></a>group commit</h2><p>为提高磁盘 fsync 操作的效率，数据库提供 group commit 功能使得一次 fsync 操作可以刷新多个事务日志到磁盘文件。</p>
<h2 id="XA-规范"><a href="#XA-规范" class="headerlink" title="XA 规范"></a>XA 规范</h2><p>XA 是 X&#x2F;Open DTP 组织（X&#x2F;Open DTP group）定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供（MySQL、Oracle、SQL Server、DB2等数据库都本地支持）。在这个模型中，包括：</p>
<ul>
<li>应用程序（Application Program）：定义事务的边界，指定全局事务中的操作；</li>
<li>事务管理器（Transaction Manager）：协调参与全局事务中的各个事务，需要和参与全局事务的所有资源管理器进行通信；</li>
<li>资源管理器（Resource Managers）：提供访问事务资源的方法，通常一个数据库就是一个资源管理器。</li>
<li>通信资源管理器（CRM）。</li>
</ul>
<p>两阶提交协议和三阶提交协议就是根据这一思想衍生出来的。可以说两阶段提交其实就是实现 XA 分布式事务的关键(两阶段提交主要保证了分布式事务的原子性)。</p>
<h2 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h2><p>two phase commit protocol，2PC。在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的 ACID 特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，两阶段提交的算法思路可以概括为：<strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作</strong>。</p>
<p>所谓的两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。</p>
<h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>事务管理器（事务协调者）给每个资源管理器（事务参与者）发送 Prepare 消息，每个参与者要么直接返回失败（如权限验证失败），要么在本地执行事务，并且写本地的 redo 和 undo 日志，但不提交，而是处于一种“准备好了”的状态：</p>
<ol>
<li>协调者向所有参与者询问是否可以执行提交操作（vote），并开始等待它们的响应；</li>
<li>参与者执行询问发起为止的所有事务操作，并将 undo 和 redo 信息写入日志；</li>
<li>各参与者响应协调者发起的询问，如果参与者成功执行事务操作，返回“同意”，否则返回“终止”。</li>
</ol>
<h3 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h3><p>如果协调者收到了（任一）参与者的失败消息或者超时，那么直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息。参与者根据收到的指令执行回滚&#x2F;提交操作，随之释放所有事务处理过程中使用的锁资源(必须在最后阶段释放锁资源)。不管最后结果如何，第二阶段都会结束当前事务。</p>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><img src="/cs/db/db/2pc-commit.png" class title="提交" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/db/2pc-commit.png" class="lozad post-image">
<p>如果进入提交阶段（所有参与者都返回的是“同意”消息）：</p>
<ol>
<li>协调者节点向所有参与者节点发出“正式提交(commit)”的请求。</li>
<li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li>
<li>参与者节点向协调者节点发送”完成”消息。</li>
<li>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</li>
</ol>
<h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><img src="/cs/db/db/2pc-fail.png" class title="回滚" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/db/2pc-fail.png" class="lozad post-image">
<p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p>
<ol>
<li>协调者节点向所有参与者节点发出“回滚操作(rollback)”的请求。</li>
<li>参与者节点利用之前写入的 undo 信息执行回滚，并释放在整个事务期间内占用的资源。</li>
<li>参与者节点向协调者节点发送“回滚完成”消息。</li>
<li>协调者节点受到所有参与者节点反馈的“回滚完成”消息后，取消事务。</li>
</ol>
<h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><ul>
<li>协调者正常，参与方 crash<br>若参与方在准备阶段 crash，则协调者收不到 Prepared 回复，协调方不会发送 commit 命令，事务不会真正提交。若参与方在提交阶段提交，当它恢复后可以通过从其它参与方或者协调方获取事务是否应该提交，并作出相应的响应。</li>
<li>协调者 crash，参与者正常<br>可以通过选出新的协调者解决。</li>
<li>协调者和参与方都 crash<br>两阶段提交无法完美解决。尤其是当协调者发送出 commit 命令后，唯一收到 commit 命令的参与者也 crash，此时其它参与方不能从协调者和已经 crash 的参与者那儿了解事务提交状态。但如同上一节两阶段提交前提条件所述，两阶段提交的前提条件之一是所有 crash 的节点最终都会恢复，所以当收到 commit 的参与方恢复后，其它节点可从它那里获取事务状态并作出相应操作。</li>
</ul>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul>
<li>同步阻塞问题<br>执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li>
<li>单点故障<br>由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）。</li>
<li>数据不一致<br>在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了 commit 请求。而在这部分参与者接到commit请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li>
<li>无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li>
</ul>
<h2 id="三阶段提交协议"><a href="#三阶段提交协议" class="headerlink" title="三阶段提交协议"></a>三阶段提交协议</h2><p>three phase commit protocol，3PC。2PC 的改进版。3PC 主要解决的单点故障问题，并减少阻塞。</p>
<p>[参考]<br><a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/681">http://www.hollischuang.com/archives/681</a></p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问，提供数据的 <strong>完整性和一致性</strong>。<br>多用户、数据库驱动的应用中，很大的一个难点是：一方面要最大程度地利用数据库的并发访问，一方面要确保每个用户能以一致的方式读取和修改数据。为此有了锁（locking）机制。</p>
<p><strong>不同数据库的锁实现机制一般不同</strong><br>MySQL 中，MyISAM 引擎使用表锁，并发读没有问题，但并发插入的性能就要差很多了。InnoDB 引擎提供一致性的非锁定读、行级锁支持。行级锁没有相关额外的开销，并可以同时得到并发性和一致性。</p>
<h2 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h2><p>MySQL 中共有 4 种锁。</p>
<ul>
<li>表锁</li>
<li>页锁</li>
<li>行锁（少数独立存储引擎才有，如 InnoDB）</li>
<li>元数据锁：5.5 版本加入的新特性。仅对表中的元数据启用，当有线程开始使用表时，元数据锁就会锁住表的所有元数据。</li>
</ul>
<p><strong>元数据</strong><br>DDL 语句的更改信息，如 CREATE、DROP、ALTER 等修改方案的语句。老版本中引入元数据是为了解决线程可以在其他线程中的并发事务使用相同表的情况下修改表定义或是删除表的问题。</p>
<h2 id="latch-和-lock"><a href="#latch-和-lock" class="headerlink" title="latch 和 lock"></a>latch 和 lock</h2><p>这是锁中容易混淆的两个概念。两者都可以称为“锁”。</p>
<ul>
<li>latch 一般称为闩锁（轻量级的锁），对象是线程，因为其要求锁定的时间必须非常短，若持续时间长，则应用的性能会非常差，InnoDB 中，latch 又分为 mutex（互斥量）和 rwlock （读写锁）。目的是用来保证并发线程操作临界资源的正确性，通常没有死锁检测的机制；</li>
<li>lock 的对象是事务，用来锁定的是数据库中的对象，如表、页、行等，一般 lock 的对象仅在事务 commit&#x2F;rollback 后进行释放（不同事务隔离级别释放的时间可能不同），有死锁检测机制。<img src="/cs/db/db/lock%E4%B8%8Elatch%E5%AF%B9%E6%AF%94.PNG" class title="lock vs latch" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/db/lock%E4%B8%8Elatch%E5%AF%B9%E6%AF%94.PNG" class="lozad post-image"></li>
</ul>
<h1 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h1><h2 id="标准行级锁"><a href="#标准行级锁" class="headerlink" title="标准行级锁"></a>标准行级锁</h2><p>InnoDB 提供两种标准的行级锁：</p>
<ul>
<li><strong>共享锁（S Lock）</strong>：允许事务读一行数据；</li>
<li><strong>排他锁（X Lock）</strong>：允许事务删除或更新一行数据；</li>
</ul>
<p><strong>锁兼容（Lock Compatible）</strong>：如果一个事务 T1 已经获得了行 r 的共享锁，那么另外的事务 T2 可以立即获得行 r 的共享锁，因为读取并不会改变行 r 的数据，这种情况就是锁兼容。S 和 X 都是行锁，兼容是指对同一行记录（row）锁的兼容性情况。</p>
<h3 id="行级锁优缺点"><a href="#行级锁优缺点" class="headerlink" title="行级锁优缺点"></a>行级锁优缺点</h3><p>InnoDB 行锁效率很高，占用内存也很少，但细粒度的行锁在锁定的时候仍然会带来额外开销，比表锁、页锁消耗的内存要多；细粒度意味着锁的请求数量可能较多，而较多的锁会占用资源，降低性能；在执行对大部分数据的 GROUP BY 操作或频繁扫描很多数据时，性能会明显下降。</p>
<h2 id="意向锁（表级）"><a href="#意向锁（表级）" class="headerlink" title="意向锁（表级）"></a>意向锁（表级）</h2><p>InnoDB 支持多粒度（granular）锁定，允许 <strong>事务在行级上的锁和表级上的锁同时存在</strong>。为此，InnoDB 支持一种额外的 <strong>表级别锁</strong>——意向锁。可以理解为意向锁将锁定的对象分为多个层次，意味着事务希望在更细粒度（fine granularity）上进行加锁，先要在粗粒度上加相应的意向锁，以表明在接下来的动作想要获取该记录的锁。<br>如果将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，则首先需要对粗粒度的对象上锁。如，对页上的记录 r 上 X 锁，那么分别要对数据库A、对应表、对应页上意向锁 IX，最后对记录 r 上 X 锁。如果其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成才能继续。</p>
<img src="/cs/db/db/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.PNG" class title="层次结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/db/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.PNG" class="lozad post-image">
<p>意向锁作为表级锁，其设计目的是为了在一个事务中揭示下一行将被请求的锁类型。意向锁的枷锁过程是自动的，无需用户干预。<br>InnoDB 支持两种意向锁：</p>
<ul>
<li><strong>意向共享锁（IS Lock）</strong>：事务想要获得一张表中某几行的共享锁；</li>
<li><strong>意向排他锁（IX Lock）</strong>：事务想要获得一张表中某几行的排他锁。</li>
</ul>
<p>由于 InnoDB 支持的是行级别的锁，因此意向锁不会阻塞除全表扫描以外的任何请求。锁的兼容性如下：</p>
<img src="/cs/db/db/InnoDB%E9%94%81%E5%85%BC%E5%AE%B9%E6%80%A7.PNG" class title="InnoDB 锁的兼容性" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/db/InnoDB%E9%94%81%E5%85%BC%E5%AE%B9%E6%80%A7.PNG" class="lozad post-image">

<h2 id="一致性非锁定读（Consistent-Nonlocking-Read）"><a href="#一致性非锁定读（Consistent-Nonlocking-Read）" class="headerlink" title="一致性非锁定读（Consistent Nonlocking Read）"></a>一致性非锁定读（Consistent Nonlocking Read）</h2><p>指 InnoDB 通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会因此去等待行上的锁释放。而是，InnoDB 会去读取该行的一个快照数据：</p>
<img src="/cs/db/db/%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB.PNG" class title="一致性非锁定读" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/db/%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB.PNG" class="lozad post-image">
<p>之所以称之为非锁定读，因为不需要等待访问的行上 X 锁的释放。<br>快照数据是指该行的之前版本的数据，一个行记录可能有不止一个快照数据，该实现是通过 undo 段来完成，而 undo 用来在事务中回滚数据，因此快照数据本身没有额外开销。此外，读取快照数据不需要上锁，因为没有事务需要对历史数据进行修改操作。<br>非锁定读机制极大提高了数据库的并发性，这是 InnoDB 默认设置下的读取方式。但在不同事务隔离级别下，读取的方式不同：</p>
<ul>
<li><strong>READ COMMITTED</strong>：总是读取行的最新版本，锁定则读最新快照版本；</li>
<li><strong>REPEATABLE</strong>：总是读取事务开始时的行数据。</li>
</ul>
<h2 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h2><p>对于增删改语句，InnoDB 会自动给涉及的数据集加排他锁，而对普通的 SELECT 语句则不会加任何锁。某些情况下如典型的事务、存储过程等，用户需要显式地对数据库读取操作加锁，以保证数据逻辑的一致性。InnoDB 对于 SELECT 语句支持两种一致性的锁定读（Locking Read）操作：</p>
<ul>
<li><strong>SELECT…FOR UPDATE</strong>：对读取的行记录加一个 X 锁，</li>
<li><strong>SELECT…LOCK IN SHARE MODE</strong>：对读取的行记录加一个 S 锁。</li>
</ul>
<p>上述语句必须在一个事务中，当事务提交了，锁也就释放了。因此要加上  BEGIN，START TRANSACTION 或 SET AUTOCOMMIT&#x3D;0。</p>
<h2 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h2><p>InnoDB 中，如果外键列没有显式添加索引，则自动对其添加一个索引，以避免表锁。</p>
<h2 id="锁算法"><a href="#锁算法" class="headerlink" title="锁算法"></a>锁算法</h2><p>InnoDB 3 种行锁算法：</p>
<ul>
<li><strong>Record Lock</strong>：单个行记录上的锁，总是锁住索引记录，如果表上没有索引，则使用隐式的主键进行锁定；</li>
<li><strong>Gap Lock</strong>：间隙锁，锁定一个范围，但不包含记录本身；</li>
<li><strong>Next-Key Lock</strong>：Record Lock + Gap Lock，锁定一个范围，并锁定记录本身。能够解决幻读问题。当查询的索引含有唯一属性时，InnoDB 会将其优化降级为 Record Lock，即仅锁住索引本身而不再是范围。</li>
</ul>
<h2 id="Next-Key-锁"><a href="#Next-Key-锁" class="headerlink" title="Next-Key 锁"></a>Next-Key 锁</h2><p>当我们用范围条件（而非相等条件）检索数据并请求锁时，InnoDB 会给符合条件的已有数据记录项加锁，对于键值在条件范围内但并不存在的记录，叫做“间隙（Gap）”，InnoDB 也会对这个间隙加锁，这就是所谓的 Next-Key 锁机制。<br>如，emp 表有 101 条记录，其 empid 值分别为 1、2、3…101，则以下语句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> empid <span class="token operator">></span> <span class="token number">100</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这条查询语句就是范围检索，InnoDB 不仅会对符合条件的 empid 记录，这里只有 101 一行加锁，也会对 empid &gt; 100 的“间隙”加锁，尽管并不存在这样的数据，但考虑这样一个场景，如果其他事务试图插入 empid &gt; 100 的数据，此时就不会成功，因为该范围被锁定，插入操作会失败。而如果不采取该锁机制，则插入有可能会成功，就会出现幻读现象。<br>显然，这种锁机制会阻塞符合条件查询内键值的并发插入，这往往造成严重的锁等待和性能问题，因此，在并发场景下，应该考虑优化业务逻辑，尽量使用相等条件进行检索，避免范围检索。但要注意一个问题：如果使用相等条件查询，而查询结果不存在这样的记录，那么 InnoDB 会使用 Next-Key 锁，这就意味着，几乎将全部的范围都锁定了。</p>
<p>_事务隔离级别为 READ COMMITTED 时，仅采用 Record Lock_。</p>
<h2 id="锁导致的问题"><a href="#锁导致的问题" class="headerlink" title="锁导致的问题"></a>锁导致的问题</h2><p>因为事务隔离性的要求，锁只会带来三种问题：</p>
<ul>
<li>脏读</li>
<li>不可重复读</li>
<li>丢失更新</li>
</ul>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>指由于不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源。阻塞并不是一件坏事，是为了确保事务可以并发且正常执行。超时会跑出1205错误。调整参数↓<br>innodb_lock_wait_timeout：设置等待时间（默认50秒），可动态调整；<br>innodb_rollback_on_timeout：设置是否在等待超时时对进行中的事务进行回滚操作（默认OFF，不回滚），静态的，不可在启动时修改。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>解决死锁最简单的方式是不要有等待，将任何的等待都转化为回滚，并且重新开始事务。然而这将导致并发性能的下降甚至所有的事务都无法进行。<br>另一种解决方法是超时，即当事务相互等待时，当其中一个事务等待时间超过设置的阈值，进行回滚操作，这时其它事务就有可能继续执行。InnoDB中超时设置参数：innodb_lock_wait_timeout（默认50秒）。<br>超时机制虽然简单，但若超时的事务所占权重较大，如操作更新了很多行，占用了较多的 undo log，此时回滚该事务的时间相比于其它事务所占用的时间可能更多。因此除了超时机制外，当前数据库普遍采用 wait_for graph（等待图）的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。等待图要求数据库保存以下两种信息：</p>
<ul>
<li>锁的信息链表；</li>
<li>事务等待链表；</li>
</ul>
<p>通过上述链表构造出一张图，如果这个图中存在回路，就代表存在死锁，此时 InnoDB 选择一个 undo 量最小的事务进行回滚，并报告一个立即可见的错误，如果不能解除死锁，则继续选择回滚，直到死锁解除。<br>等待图的死锁检测通常采用深度优先的非递归算法实现（1.2.x版本之后，之前采用递归的深度优先算法实现）。</p>
<h2 id="乐观锁-vs-悲观锁"><a href="#乐观锁-vs-悲观锁" class="headerlink" title="乐观锁 vs 悲观锁"></a>乐观锁 vs 悲观锁</h2><p>互斥同步、非互斥同步，并发控制技术手段上的概念。<br><strong>乐观锁（Optimistic Lock）</strong><br>假设数据一般情况下不会发生并发冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。如果冲突，则返回错误，让用户决定如何去做，这意味着乐观锁不能解决脏读问题，其实现算是一种 CAS 操作。其实现：</p>
<ul>
<li>使用数据版本记录机制实现。为数据增加一个版本标识，如“version”，每更新一次数据，则对标识进行一次累加操作。</li>
<li>时间戳（timestamp）记录机制：在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果不一致则冲突。</li>
</ul>
<p>适用于多读少写的场景，可以提高吞吐率。</p>
<p><strong>悲观锁（Pessimistic Lock）</strong><br>假定数据会发生并发冲突，从而以预防冲突的方式屏蔽可能违反数据完整性的冲突操作。简言之就是每次读写数据都认为会被其他线程修改，所以都需要先上锁。java synchronized 就属于悲观锁的一种实现。</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>MySQL 体系结构如图所示：<br><img src="/cs/db/mysql-arch.png" alt="MySQL体系结构" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/mysql-arch.png" class="lozad post-image"><br>由上图可以看出，MySQL由以下几部分组成：</p>
<ul>
<li>连接池组件；</li>
<li>管理服务和工具组件；</li>
<li>SQL 接口组件；</li>
<li>查询分析器组件；</li>
<li>优化器组件；</li>
<li>缓冲（Cache）组件；</li>
<li>插件式存储引擎；</li>
<li>物理文件；</li>
</ul>
<p>其中，MySQL 数据库区别于其他数据库的最重要的一个特点就是其<strong>插件式</strong>的表存储引擎。并且为这种架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，作为底层物理结构的实现，每个存储引擎按照自己的意愿进行开发。MySQL 的核心就在于存储引擎。<br><strong>存储引擎是基于表的，而不是数据库。</strong></p>
<h2 id="常用存储引擎对比"><a href="#常用存储引擎对比" class="headerlink" title="常用存储引擎对比"></a>常用存储引擎对比</h2><p><img src="/cs/db/mysql-engine-vs.png" alt="存储引擎特性对比" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/mysql-engine-vs.png" class="lozad post-image"><br>可以看出，不同存储引擎对诸如事务、全文索引等的支持是不同的；另外对B-树等索引、锁机制等的具体算法实现也有很大差异。</p>
<p>选取 MySQL 中较为常用的 InnoDB、MyISAM、MEMORY、Archive 四个存储引擎作为对比。它们都有各自适用的环境，这取决于其独有的一些特征。主要体现在性能、事务、并发控制、参照完整性、缓存、 故障恢复，备份及回存等几个方面。</p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><ul>
<li>MySQL 5.7.x 默认的存储引擎为 InnoDB，被设计成适用于高并发读写的情况。使用MVCC(Multi-Version Concurrency Control)以及行级锁来提供遵从ACID的事务支持，提供了具有__提交、回滚和崩溃恢复能力的事务安全__，对比MyISAM的存储引擎，InnoDB 写处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</li>
<li>提供<strong>外键约束</strong>（MySQL 中只有 InnoDB 支持外键约束）。在创建外键的时候，父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括restrict、cascade、set null和no action。其中restrict和no action相同，是指限制在子表有关联的情况下，父表不能更新；casecade表示父表在更新或删除时，更新或者删除子表对应的记录；set null 则表示父表在更新或者删除的时候，子表对应的字段被set null。</li>
<li>在行级别上对表数据上锁，提供非锁定读。行级锁没有相关额外的开销，并可以同时得到并发性和一致性。</li>
<li>使用 Next-Key Lock 算法来避免不可重复读问题。MySQL 文档中将不可重复读问题定义为（Phantom Problem），即幻读问题。</li>
</ul>
<p>适合场景：</p>
<ul>
<li>可靠性要求较高</li>
<li>要求事务</li>
<li>表更新和查询都相当频繁，锁定表的可能性较大，等</li>
</ul>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>不支持事务，也不支持外键。访问速度快，占用内存较少。数据文件和索引文件可以分开存储，平均分配IO以获取更快的速度。每个MyISAM表在磁盘上存储3个文件：</p>
<ul>
<li>.frm（存储表定义）</li>
<li>MYD（MYData，存储数据）</li>
<li>MYI（MYIndex，存储索引）</li>
</ul>
<p>MyISAM表支持3种不同的存储格式：</p>
<ul>
<li>静态(固定长度)表</li>
<li>动态表</li>
<li>压缩表</li>
</ul>
<p>其中静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度定义补足空格，但是在访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。同时需要注意：在某些情况下可能需要返回字段后的空格，而使用这种格式时后面到空格会被自动处理掉。<br>动态表包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。<br>压缩表由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。</p>
<p>适合场景：</p>
<ul>
<li>对事务完整性没有要求；</li>
<li>插入不频繁、查询非常频繁；等</li>
</ul>
<p><strong>MERGE</strong><br>MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，MERGE表中并没有数据，对MERGE类型的表可以进行查询、更新、删除的操作，这些操作实际上是对内部的MyISAM表进行操作。对于对MERGE表进行的插入操作，是根据INSERT_METHOD子句定义的插入的表，可以有3个不同的值，first和last值使得插入操作被相应的作用在第一个或最后一个表上，不定义这个子句或者为NO，表示不能对这个MERGE表进行插入操作。可以对MERGE表进行drop操作，这个操作只是删除MERGE表的定义，对内部的表没有任何影响。MERGE在磁盘上保留2个以MERGE表名开头文件：.frm文件存储表的定义；.MRG文件包含组合表的信息，包括MERGE表由哪些表组成，插入数据时的依据。可以通过修改.MRG文件来修改MERGE表，但是修改后要通过flush table刷新。</p>
<h2 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h2><p>MEMORY使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm。MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。<br>默认情况下，MEMORY数据表使用散列索引，利用这种索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了。因此，散列索引值适合使用在”&#x3D;”和”&lt;&#x3D;&gt;”的操作符中，不适合使用在”&lt;”或”&gt;”操作符中，也同样不适合用在order by字句里。如果确实要使用”&lt;”或”&gt;”或betwen操作符，可以使用B-tree索引来加快速度。<br>存储在MEMORY数据表里的数据行使用的是长度不变的格式，因此加快处理速度，这意味着不能使用BLOB和TEXT这样长度可变的数据类型。VARCHAR是一种可变长类型，但因为它在MySQL内部被当作长度固定不变的CHAR类型，所以可以使用。</p>
<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>上述索引的作用中最关键的地方在于“优化查询速度”，那首先需要了解的是，一条sql语句，它的执行顺序是怎样的，才能更好地理解如何加速，以及背后的为什么能够加速。（比这个“首先”更首先需要了解的是，为什么要“优化”？无非一：数据量太大了；二：数据量太大了内存存不下而硬盘又太慢但又不得不放在硬盘上因为它很便宜。根因是数据量太大了，以至于不优化的话又回到了点个按钮可以喝杯咖啡再回来看结果的原始状态，用户就要爆炸，用户一爆炸老板就要爆炸，so…）<br>sql语句执行可能会划分为多个操作步骤，如下图，一个典型的sql查询，总共分为11步，其中每一步都会产生一张中间状态的虚表，作为下一步的输入，最后一步的虚表作为返回结果，其他步骤的虚表对用户透明。<br><img src="/cs/db/sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt="sql执行顺序" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/cs/db/sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class="lozad post-image"><br>其中，每一步的大致过程如下：</p>
<ol>
<li>FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1。</li>
<li>ON: 对虚表VT1进行ON筛选，只有那些符合&lt;join-condition&gt;的行才会被记录在虚表VT2中。</li>
<li>JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3，如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li>
<li>WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合&lt;where-condition&gt;的记录才会被插入到虚拟表VT4中。</li>
<li>GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5。</li>
<li>CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6。</li>
<li>HAVING： 对虚拟表VT6应用having过滤，只有符合&lt;having-condition&gt;的记录才会被 插入到虚拟表VT7中。</li>
<li>SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。</li>
<li>DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9。</li>
<li>ORDER BY: 将虚拟表VT9中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表VT10。</li>
<li>LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。</li>
</ol>
<p><strong>理解上述步骤之后，不难发现，为什么连接查询很可能导致低效（笛卡尔积：m * n），同时也可以看出，如果想要做一些查询优化工作，那么就要从 on、where 开始着手（join 中 on 等同于 where），对过滤条件中的字段加以优化（即挑选索引时的考虑因素）。</strong></p>
<h2 id="sql分析"><a href="#sql分析" class="headerlink" title="sql分析"></a>sql分析</h2><h3 id="explain分析"><a href="#explain分析" class="headerlink" title="explain分析"></a>explain分析</h3><p><strong>语法</strong>：explain + SQL语句<br>执行explain分析语句的结果列中，有几列是与索引使用情况相关的：</p>
<ol>
<li>type：join 类型，判断此次查询是全表扫描还是索引扫描等信息；</li>
<li>possible_keys：指出MySQL能使用哪个索引在该表中找到行；</li>
<li>key：显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL；</li>
<li>key_len：显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL；</li>
<li>ref：显示使用哪个列或常数与key一起从表中选择行。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5babb52c6fb9a05cd676c0f7">语句执行分析</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008131735">Explain 使用分析</a></p>

  </div>
  <div>
    
      <div 
        class="post-note note-warning copyright" 
        style="margin-top: 42px">
        <p>
          <span style="font-weight: bold;">作者：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="/about">
            Neil
          </a>
        </p>
        <p>
          <span style="font-weight: bold;">文章链接：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="https://lazy-snail.github.io/cs/db/">
            https://lazy-snail.github.io/cs/db/
          </a>
        </p>
        <p><span style="font-weight: bold;">版权声明：</span>转载请注明出处</p>
      </div>
    
  </div>
</article>
<div class="nav">
  
  
    <div class="nav-item-next">
      <a 
        href="/cs/os/" 
        class="nav-link">
        <div>
          <div class="nav-label">Next</div>
          
            <div class="nav-title">OS </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">索引是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%B4%A2%E5%BC%95"><span class="toc-text">为什么要有索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">常用索引类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E7%B4%A2%E5%BC%95"><span class="toc-text">B+索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-tree"><span class="toc-text">B-tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-tree-1"><span class="toc-text">B+tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="toc-text">辅助索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95"><span class="toc-text">Hash索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95%EF%BC%88BitMap-BitMap-index%EF%BC%89"><span class="toc-text">位图索引（BitMap BitMap index）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%EF%BC%88Full-Text-Search-Index"><span class="toc-text">全文索引（Full-Text Search Index)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E6%8A%80%E6%9C%AF"><span class="toc-text">倒排索引技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-text">InnoDB 全文索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6"><span class="toc-text">限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%80%A7%EF%BC%9A"><span class="toc-text">相关性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOOLEAN"><span class="toc-text">BOOLEAN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Query-Expansion"><span class="toc-text">Query Expansion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA"><span class="toc-text">索引创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95"><span class="toc-text">哪些场景需要索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">哪些数据适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E6%89%8B%E6%AE%B5"><span class="toc-text">辅助手段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">如何使用索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%A3%E4%BB%B7"><span class="toc-text">索引代价</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E4%BD%8E%E5%86%99%E6%93%8D%E4%BD%9C%E6%95%88%E7%8E%87"><span class="toc-text">降低写操作效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">占用空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-x2F-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">B&#x2F;B+树索引的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8"><span class="toc-text">索引存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ACID"><span class="toc-text">ACID</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%88%86%E7%B1%BB"><span class="toc-text">事务分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1%EF%BC%88Flat-Transactions%EF%BC%89"><span class="toc-text">扁平事务（Flat Transactions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E4%BF%9D%E5%AD%98%E7%82%B9%E7%9A%84%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1%EF%BC%88Flat-Transactions-with-Savepoints%EF%BC%89"><span class="toc-text">带有保存点的扁平事务（Flat Transactions with Savepoints）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E4%BA%8B%E5%8A%A1%EF%BC%88Chained-Transactions%EF%BC%89"><span class="toc-text">链事务（Chained Transactions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%EF%BC%88Nested-Transactions%EF%BC%89"><span class="toc-text">嵌套事务（Nested Transactions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88Distributed-Transactions%EF%BC%89"><span class="toc-text">分布式事务（Distributed Transactions）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">事务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redo"><span class="toc-text">redo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undo"><span class="toc-text">undo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#purge"><span class="toc-text">purge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#group-commit"><span class="toc-text">group commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XA-%E8%A7%84%E8%8C%83"><span class="toc-text">XA 规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE"><span class="toc-text">两阶段提交协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="toc-text">准备阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5"><span class="toc-text">提交阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4"><span class="toc-text">提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A"><span class="toc-text">回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E9%94%99"><span class="toc-text">容错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE"><span class="toc-text">三阶段提交协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E9%94%81"><span class="toc-text">MySQL 锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#latch-%E5%92%8C-lock"><span class="toc-text">latch 和 lock</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB%E9%94%81"><span class="toc-text">InnoDB锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-text">标准行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">行级锁优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88%E8%A1%A8%E7%BA%A7%EF%BC%89"><span class="toc-text">意向锁（表级）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%88Consistent-Nonlocking-Read%EF%BC%89"><span class="toc-text">一致性非锁定读（Consistent Nonlocking Read）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-text">一致性锁定读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E5%92%8C%E9%94%81"><span class="toc-text">外键和锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%AE%97%E6%B3%95"><span class="toc-text">锁算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Next-Key-%E9%94%81"><span class="toc-text">Next-Key 锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">锁导致的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-vs-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">乐观锁 vs 悲观锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">常用存储引擎对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB"><span class="toc-text">InnoDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM"><span class="toc-text">MyISAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MEMORY"><span class="toc-text">MEMORY</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-text">查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sql%E5%88%86%E6%9E%90"><span class="toc-text">sql分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#explain%E5%88%86%E6%9E%90"><span class="toc-text">explain分析</span></a></li></ol></li></ol></li></ol>
</div></main>
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="/img/little-prince.png" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">Neil</p>
<p class="author-description">there's a will there's a way</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>9</span>
    <span>Posts</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>8</span>
    <span>Categories</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>8</span>
    <span>Tags</span>
  </a>
</div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">索引是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%B4%A2%E5%BC%95"><span class="toc-text">为什么要有索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">常用索引类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E7%B4%A2%E5%BC%95"><span class="toc-text">B+索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-tree"><span class="toc-text">B-tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-tree-1"><span class="toc-text">B+tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="toc-text">辅助索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95"><span class="toc-text">Hash索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95%EF%BC%88BitMap-BitMap-index%EF%BC%89"><span class="toc-text">位图索引（BitMap BitMap index）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%EF%BC%88Full-Text-Search-Index"><span class="toc-text">全文索引（Full-Text Search Index)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E6%8A%80%E6%9C%AF"><span class="toc-text">倒排索引技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-text">InnoDB 全文索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6"><span class="toc-text">限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%80%A7%EF%BC%9A"><span class="toc-text">相关性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOOLEAN"><span class="toc-text">BOOLEAN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Query-Expansion"><span class="toc-text">Query Expansion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA"><span class="toc-text">索引创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95"><span class="toc-text">哪些场景需要索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">哪些数据适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E6%89%8B%E6%AE%B5"><span class="toc-text">辅助手段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">如何使用索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%A3%E4%BB%B7"><span class="toc-text">索引代价</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E4%BD%8E%E5%86%99%E6%93%8D%E4%BD%9C%E6%95%88%E7%8E%87"><span class="toc-text">降低写操作效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">占用空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-x2F-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">B&#x2F;B+树索引的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8"><span class="toc-text">索引存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ACID"><span class="toc-text">ACID</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%88%86%E7%B1%BB"><span class="toc-text">事务分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1%EF%BC%88Flat-Transactions%EF%BC%89"><span class="toc-text">扁平事务（Flat Transactions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E4%BF%9D%E5%AD%98%E7%82%B9%E7%9A%84%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1%EF%BC%88Flat-Transactions-with-Savepoints%EF%BC%89"><span class="toc-text">带有保存点的扁平事务（Flat Transactions with Savepoints）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E4%BA%8B%E5%8A%A1%EF%BC%88Chained-Transactions%EF%BC%89"><span class="toc-text">链事务（Chained Transactions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%EF%BC%88Nested-Transactions%EF%BC%89"><span class="toc-text">嵌套事务（Nested Transactions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88Distributed-Transactions%EF%BC%89"><span class="toc-text">分布式事务（Distributed Transactions）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">事务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redo"><span class="toc-text">redo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undo"><span class="toc-text">undo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#purge"><span class="toc-text">purge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#group-commit"><span class="toc-text">group commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XA-%E8%A7%84%E8%8C%83"><span class="toc-text">XA 规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE"><span class="toc-text">两阶段提交协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="toc-text">准备阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5"><span class="toc-text">提交阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4"><span class="toc-text">提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A"><span class="toc-text">回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E9%94%99"><span class="toc-text">容错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE"><span class="toc-text">三阶段提交协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E9%94%81"><span class="toc-text">MySQL 锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#latch-%E5%92%8C-lock"><span class="toc-text">latch 和 lock</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB%E9%94%81"><span class="toc-text">InnoDB锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-text">标准行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">行级锁优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88%E8%A1%A8%E7%BA%A7%EF%BC%89"><span class="toc-text">意向锁（表级）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%88Consistent-Nonlocking-Read%EF%BC%89"><span class="toc-text">一致性非锁定读（Consistent Nonlocking Read）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-text">一致性锁定读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E5%92%8C%E9%94%81"><span class="toc-text">外键和锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%AE%97%E6%B3%95"><span class="toc-text">锁算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Next-Key-%E9%94%81"><span class="toc-text">Next-Key 锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">锁导致的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-vs-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">乐观锁 vs 悲观锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">常用存储引擎对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB"><span class="toc-text">InnoDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM"><span class="toc-text">MyISAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MEMORY"><span class="toc-text">MEMORY</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-text">查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sql%E5%88%86%E6%9E%90"><span class="toc-text">sql分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#explain%E5%88%86%E6%9E%90"><span class="toc-text">explain分析</span></a></li></ol></li></ol></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>Categories
  </div>
  <div class="categories-list">
    
      <a href="/categories/algs/">
        <div class="categories-list-item">
          algs
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/aqad/">
        <div class="categories-list-item">
          aqad
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/cn/">
        <div class="categories-list-item">
          cn
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/cs/">
        <div class="categories-list-item">
          cs
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/db/">
        <div class="categories-list-item">
          db
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/java/">
        <div class="categories-list-item">
          java
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/mw/">
        <div class="categories-list-item">
          mw
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/os/">
        <div class="categories-list-item">
          os
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>hot tags
  </div>
  <div class="tags-list">
    
      <a 
        href="/tags/java/" 
        title="java">
        <div class="tags-list-item">java</div>
      </a>
    
      <a 
        href="/tags/os/" 
        title="os">
        <div class="tags-list-item">os</div>
      </a>
    
      <a 
        href="/tags/mw/" 
        title="mw">
        <div class="tags-list-item">mw</div>
      </a>
    
      <a 
        href="/tags/db/" 
        title="db">
        <div class="tags-list-item">db</div>
      </a>
    
      <a 
        href="/tags/cs/" 
        title="cs">
        <div class="tags-list-item">cs</div>
      </a>
    
      <a 
        href="/tags/cn/" 
        title="cn">
        <div class="tags-list-item">cn</div>
      </a>
    
      <a 
        href="/tags/aqad/" 
        title="aqad">
        <div class="tags-list-item">aqad</div>
      </a>
    
      <a 
        href="/tags/algs/" 
        title="algs">
        <div class="tags-list-item">algs</div>
      </a>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">索引是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%B4%A2%E5%BC%95"><span class="toc-text">为什么要有索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">常用索引类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E7%B4%A2%E5%BC%95"><span class="toc-text">B+索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-tree"><span class="toc-text">B-tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-tree-1"><span class="toc-text">B+tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="toc-text">辅助索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95"><span class="toc-text">Hash索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95%EF%BC%88BitMap-BitMap-index%EF%BC%89"><span class="toc-text">位图索引（BitMap BitMap index）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%EF%BC%88Full-Text-Search-Index"><span class="toc-text">全文索引（Full-Text Search Index)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E6%8A%80%E6%9C%AF"><span class="toc-text">倒排索引技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-text">InnoDB 全文索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6"><span class="toc-text">限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%80%A7%EF%BC%9A"><span class="toc-text">相关性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOOLEAN"><span class="toc-text">BOOLEAN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Query-Expansion"><span class="toc-text">Query Expansion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA"><span class="toc-text">索引创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95"><span class="toc-text">哪些场景需要索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">哪些数据适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E6%89%8B%E6%AE%B5"><span class="toc-text">辅助手段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">如何使用索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%A3%E4%BB%B7"><span class="toc-text">索引代价</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E4%BD%8E%E5%86%99%E6%93%8D%E4%BD%9C%E6%95%88%E7%8E%87"><span class="toc-text">降低写操作效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">占用空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-x2F-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">B&#x2F;B+树索引的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8"><span class="toc-text">索引存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ACID"><span class="toc-text">ACID</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%88%86%E7%B1%BB"><span class="toc-text">事务分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1%EF%BC%88Flat-Transactions%EF%BC%89"><span class="toc-text">扁平事务（Flat Transactions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E4%BF%9D%E5%AD%98%E7%82%B9%E7%9A%84%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1%EF%BC%88Flat-Transactions-with-Savepoints%EF%BC%89"><span class="toc-text">带有保存点的扁平事务（Flat Transactions with Savepoints）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E4%BA%8B%E5%8A%A1%EF%BC%88Chained-Transactions%EF%BC%89"><span class="toc-text">链事务（Chained Transactions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%EF%BC%88Nested-Transactions%EF%BC%89"><span class="toc-text">嵌套事务（Nested Transactions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88Distributed-Transactions%EF%BC%89"><span class="toc-text">分布式事务（Distributed Transactions）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">事务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redo"><span class="toc-text">redo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undo"><span class="toc-text">undo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#purge"><span class="toc-text">purge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#group-commit"><span class="toc-text">group commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XA-%E8%A7%84%E8%8C%83"><span class="toc-text">XA 规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE"><span class="toc-text">两阶段提交协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="toc-text">准备阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5"><span class="toc-text">提交阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4"><span class="toc-text">提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A"><span class="toc-text">回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E9%94%99"><span class="toc-text">容错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE"><span class="toc-text">三阶段提交协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E9%94%81"><span class="toc-text">MySQL 锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#latch-%E5%92%8C-lock"><span class="toc-text">latch 和 lock</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB%E9%94%81"><span class="toc-text">InnoDB锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-text">标准行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">行级锁优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88%E8%A1%A8%E7%BA%A7%EF%BC%89"><span class="toc-text">意向锁（表级）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%88Consistent-Nonlocking-Read%EF%BC%89"><span class="toc-text">一致性非锁定读（Consistent Nonlocking Read）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-text">一致性锁定读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E5%92%8C%E9%94%81"><span class="toc-text">外键和锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%AE%97%E6%B3%95"><span class="toc-text">锁算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Next-Key-%E9%94%81"><span class="toc-text">Next-Key 锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">锁导致的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-vs-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">乐观锁 vs 悲观锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">常用存储引擎对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB"><span class="toc-text">InnoDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM"><span class="toc-text">MyISAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MEMORY"><span class="toc-text">MEMORY</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-text">查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sql%E5%88%86%E6%9E%90"><span class="toc-text">sql分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#explain%E5%88%86%E6%9E%90"><span class="toc-text">explain分析</span></a></li></ol></li></ol></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>Recent Posts
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-07-17</div>
        <a href="/cs/db/"><div class="recent-posts-item-content">database</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-07-17</div>
        <a href="/cs/os/"><div class="recent-posts-item-content">OS</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-07-17</div>
        <a href="/cs/aqad/"><div class="recent-posts-item-content">a question a day</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-07-17</div>
        <a href="/cs/java/"><div class="recent-posts-item-content">java</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2017 -
          
          2022
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          懒蜗牛
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
      <div class="footer-dsc">
        
        
        
      </div>
      
    
</footer> 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
      

  
  
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
      };
    </script>
    
<script src="//cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-svg.js"></script>

  
 
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
    
      <script> 
        loadScript('/js/lib/busuanzi.min.js') 
      </script>
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
     
    
    
      <script>
        setTimeout(() => {localSearch("search.json")}, 0)
      </script>
    
  </body>
</html>
